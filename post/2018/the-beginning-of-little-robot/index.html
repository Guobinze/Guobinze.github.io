<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 生命在于折腾，写一个前端资讯推送服务 · Minibase</title><meta name="description" content="生命在于折腾，写一个前端资讯推送服务 - Colafornia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">生命在于折腾，写一个前端资讯推送服务</h1><div class="post-info">Sep 11, 2018</div><div class="post-content"><p><img src="https://s2.ax1x.com/2019/06/01/V1wi2d.jpg" width="600"></p>
<p>去年年底开始写的一个小项目，断断续续做了些优化，在此简单的记录一下。</p>
<a id="more"></a>
<h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p>起源是之前一直没什么机会接触到 Node 项目，工作中接触到的也仅限于用 Node 写脚本，做一些小工具，与服务器上跑的 Node 服务相差甚远。所以想写一个在服务器上跑的 Node 小项目练手。</p>
<p>一直喜欢用 RSS 订阅资讯这种方式，简单高效，与其每天不定时地接收推送，打开各网站 App 来接收资讯，不如自己拿到主动权集中在同一时间段统一阅读。这样避免了每天不定时接受信息的焦虑堆积，但是又常常想不起来打开😅，过了一周打开 Reeder，发现累积的未读资讯又爆炸了，人真是很难满足。</p>
<p>于是决定自己搞个资讯推送服务吧，满足自己的核心诉求，<strong>每个工作日早上 10 点微信推送 RSS 前端资讯的更新</strong>，这样就可以在每天抵达工位的时候舒舒服服浏览一下新鲜事，挑一些有用的存起来慢慢研读。</p>
<p>项目仓库： <a href="https://github.com/Colafornia/little-robot" target="_blank" rel="external">https://github.com/Colafornia/little-robot</a></p>
<p>推送大概长这样：</p>
<p><img src="https://s2.ax1x.com/2019/06/01/V1wi2d.jpg" width="600"></p>
<p>现在推送源主要是各厂的知乎专栏，大佬们的个人博客，掘金前端热门文章，都是我自己的个人口味。</p>
<p>下面来讲一下开发（与自己给自己加需求）历程。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>最开始感觉这个需求是很简单的，具体操作可以分解为：</p>
<ol>
<li>写一个配置文件，把我想抓取的 RSS 源地址写在里面</li>
<li>找一个能解析 RSS 的 npm 包，遍历配置文件里的源，解析之后处理数据</li>
<li>仅筛出在过去 24 小时内更新的文章，把数据处理一下，汇总成一段字符串，用微信推送</li>
<li>以上写出的脚本通过定时任务跑起来，done！</li>
</ol>
<p>最后选择了 <a href="https://github.com/bobby-brennan/rss-parser" target="_blank" rel="external">rss-parser</a> 作为解析工具包，<a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="external">PushBear</a> 作为推送服务，<a href="https://github.com/node-schedule/node-schedule" target="_blank" rel="external">node-schedule</a> 任务调度工具写出来了一版。</p>
<p>然后就发现自己知识的匮乏了，没有考虑到脚本部署到服务器上时，进程守护的问题，于是研习了一波 <a href="https://github.com/Unitech/pm2" target="_blank" rel="external">pm2</a>，完美完成任务。</p>
<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>项目写到这里其实是可以凑和用了，但是看起来很 low 很难受。主要问题有：</p>
<ol>
<li>当时 RSS 源大概有四五十个，一次性遍历解析所有的源经常会有超时或者出错的</li>
<li>RSS 源写在配置文件里，每次想添加、修改源都需要改代码，很 low</li>
<li><a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="external">PushBear</a> 这个推送服务只能存储三天内的推送，三天前，一周前的推送内容都看不了，这也很难受</li>
<li>掘金的 RSS 源内容不多，也不是按照热门程度排序的（也可能是我姿势不对😅），不太符合要求</li>
</ol>
<p>第一点稍微有点复杂，可能现在解决的方案依然很原始。出现第一个问题一是需要控制请求的并发数量，二是 RSS 源本身有一定的不稳定性。目前的解决方案是：</p>
<ol>
<li>把抓取任务和推送任务分开，预留出可以循环抓取三次的时间，后面两次只抓取之前失败的源</li>
<li>用 <a href="https://github.com/caolan/async" target="_blank" rel="external">async</a> 的 <code>mapLimit</code> 和 <code>timeout</code> 方法设置最大并发数量和超时时间</li>
</ol>
<p>大致代码如下（有一些细节处理没贴上来）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抓取定时器 ID</span></div><div class="line"><span class="keyword">let</span> fetchInterval = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 抓取次数</span></div><div class="line"><span class="keyword">let</span> fetchTimes = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPushSchedule</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    schedule.scheduleJob(<span class="string">'00 30 09 * * *'</span>, () =&gt; &#123;</div><div class="line">        <span class="comment">// 抓取任务</span></div><div class="line">        log.info(<span class="string">'rss schedule fetching fire at '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">        activateFetchTask();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    schedule.scheduleJob(<span class="string">'00 00 10 * * *'</span>, () =&gt; &#123;</div><div class="line">        <span class="comment">// 发送任务</span></div><div class="line">        log.info(<span class="string">'rss schedule delivery fire at '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">        <span class="keyword">let</span> message = makeUpMessage();</div><div class="line">        log.info(message);</div><div class="line">        sendToWeChat(message);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">activateFetchTask</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  fetchInterval = setInterval(fetchRSSUpdate, <span class="number">120000</span>);</div><div class="line">  fetchRSSUpdate();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchRSSUpdate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    fetchTimes++;</div><div class="line">    <span class="keyword">if</span> (toFetchList.length &amp;&amp; fetchTimes &lt; <span class="number">4</span>) &#123;</div><div class="line">        <span class="comment">// 若抓取次数少于三次，且仍存在未成功抓取的源</span></div><div class="line">        log.info(<span class="string">`第<span class="subst">$&#123;fetchTimes&#125;</span>次抓取，有 <span class="subst">$&#123;toFetchList.length&#125;</span> 篇`</span>);</div><div class="line">        <span class="comment">// 最大并发数为15，超时时间设置为 8000ms</span></div><div class="line">        <span class="keyword">return</span> mapLimit(toFetchList, <span class="number">15</span>, (source, callback) =&gt; &#123;</div><div class="line">            timeout(parseRSS(source, callback), <span class="number">8000</span>);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    log.info(<span class="string">'fetching is done'</span>);</div><div class="line">    clearInterval(fetchInterval);</div><div class="line">    <span class="keyword">return</span> fetchDataCb();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样基本解决了 90% 以上的抓取问题，保证了脚本的稳定性。</p>
<p>针对 RSS 源写在配置文件里，每次想添加、修改源都需要改代码的问题，解决方法很简单，把源配置写到 MongoDB 里也就好了，有一些 GUI 软件可以直接在图形界面来添加、修改数据。</p>
<p>为了解决推送服务只能存储三天内的推送，决定新增一个每周五的周抓取任务，抓取一周内的新文章，把内容作为 issue 发到仓库。也还算是一个解决方案。</p>
<p><img src="https://s2.ax1x.com/2019/06/01/V1wVqP.jpg" width="480"></p>
<p>针对掘金的 RSS 源问题，最后决定直接调用掘金的接口来取数据，这就可以随心所欲按自己的需求来了，每天只抓取❤️点赞数在 70 以上的文章。</p>
<p>顺便给抓取的文章时间范围加了一个偏移值，避免筛掉质量好但是由于刚刚发布点赞较少的文章。感觉自己棒棒哒~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterArticlesByDateAndCollection</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> threshold = <span class="number">70</span>;</div><div class="line">    <span class="comment">// articles 是已按❤️数由高到低排序的文章列表</span></div><div class="line">    <span class="keyword">let</span> results = articles.filter((article) =&gt; &#123;</div><div class="line">        <span class="comment">// 偏移值五小时，避免筛掉质量好但是由于刚刚发布点赞较少的文章</span></div><div class="line">        <span class="keyword">return</span> moment(article.createdAt).isAfter(moment(startTime).subtract(<span class="number">5</span>, <span class="string">'hours'</span>))</div><div class="line">            &amp;&amp; moment(article.createdAt).isBefore(moment(endTime).subtract(<span class="number">5</span>, <span class="string">'hours'</span>))</div><div class="line">            &amp;&amp; article.collectionCount &gt; threshold;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 掘金文章最多收录 8 篇，避免信息爆炸</span></div><div class="line">    <span class="keyword">return</span> results.slice(<span class="number">0</span>, <span class="number">8</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个期间也充分感受到了日志的重要性，在数据库里新增了一个表用来存每天的推送内容。</p>
<p>另外在 <a href="https://pushbear.ftqq.com/admin/#/" target="_blank" rel="external">PushBear</a> 上新添加了一个 Channel 来给自己推送日志，每天在抓取任务完成后，先给我发送一下抓取到的内容，如果发现有任何问题，我可以自己登服务器紧急修复一下（这么想来还是很 low 😅）。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>做完以上改动之后，脚本稳定地跑了快半年，这期间我也一直在忙着搬砖，没什么精力再来改造它。</p>
<p>一直没做推广，但某天突然发现已经有了三十多个用户在订阅这个服务，于是良心发现，本着对用户负责（也是自己有了新的想练习的技术👻）,就又做了一次改造。</p>
<p>此时项目的问题有：</p>
<ol>
<li>没有文章去重，如果文章在知乎专栏发了，掘金也发了，作者个人博客也发了的话，就相当于会重复出现几次</li>
<li>推送的时间间隔不精确，都是当前时间的过去 24 小时来筛的</li>
<li>脚本直连数据库进行存取操作也不太好，感觉这个形式做成 server，对外暴露 api 更合理（等哪天想写个 RSS 阅读器也就用上了）</li>
<li>每次代码有更新，依赖有更新，都 ssh 上服务器然后 <code>npm install</code> 感觉也不太专业，有提升空间（其实就是想用 <code>docker</code> 了）</li>
</ol>
<p>1，2 问题很好解决，每次抓取之前先查一下日志，上次推送的具体时间。每抓到新文章时，再与最近 7 天日志里的文章比对一下，重复的不放到抓取结果中，也就解决了。</p>
<p>对于问题 3，于是决定搭建 Koa Server，先把从 MongoDB 读取推送源，存取推送日志变成 api。</p>
<p>目录结构如下，添加 <code>Model</code> 与 <code>Controller</code>。把 RSS 抓取脚本与掘金爬虫放到 task 文件。</p>
<p><img src="https://s2.ax1x.com/2019/06/01/V1wQ2j.jpg" width="400"></p>
<p>没什么难点，就可以调用 api 来获取 RSS 源了：</p>
<p><img src="https://s2.ax1x.com/2019/06/01/V1w8rq.jpg" width="500"></p>
<p>此时想到了一个重要问题，<strong>身份验证</strong>。肯定不能把所有 api 都随意暴露出去，让外界可以任意调用，这也就相当于把数据库都暴露出去了。</p>
<p>最终决定用 <code>JSON Web Token（缩写 JWT）</code> 作为认证方案，主要原因是 JWT 适合一次性、短时间的命令认证，目前我的服务仅限于服务器端的 api 调用，每天的使用时间也不长，无需签发有效期很长的令牌。</p>
<p>Koa 有一个 <a href="https://github.com/koajs/jwt" target="_blank" rel="external">jwt</a> 的中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line">app.use(jwtKoa(&#123; secret: config.secretKey &#125;).unless(&#123;</div><div class="line">    path: [<span class="regexp">/^\/api\/source/</span>, <span class="regexp">/^\/api\/login/</span>]</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>加上中间件后，除了 <code>/api/source</code> 与 <code>/api/login</code> 接口就都需要经过 jwt 认证才能访问了。</p>
<p>因此写了一个 <code>/api/login</code> 接口，用于签发令牌，拿到令牌之后，把令牌设置到请求头里就可以通过认证了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// api/base.js</span></div><div class="line"><span class="comment">// 用于封装 axios</span></div><div class="line"><span class="comment">// http request 拦截器</span></div><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</div><div class="line"><span class="keyword">const</span> Instance = axios.create(&#123;</div><div class="line">    baseURL: <span class="string">`http://localhost:<span class="subst">$&#123;config.port&#125;</span>/api`</span>,</div><div class="line">    timeout: <span class="number">3000</span>,</div><div class="line">    headers: &#123;</div><div class="line">        post: &#123;</div><div class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Instance.interceptors.request.use(</div><div class="line">    (config) =&gt; &#123;</div><div class="line">        <span class="comment">// jwt 验证</span></div><div class="line">        <span class="keyword">const</span> token = config.token;</div><div class="line">        <span class="keyword">if</span> (token) &#123;</div><div class="line">            config.headers[<span class="string">'Authorization'</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;,</div><div class="line">    error =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>如果请求头里没有正确的 token，则会返回 <code>Authentication Error</code>。</p>
<p>至于问题 4，现在服务比较简单，也只在一个机器上部署，手动登机器 npm install 问题还不大，如果机器很多，依赖项也复杂的话，很容易出问题，具体参见<a href="https://zhuanlan.zhihu.com/p/39209596" target="_blank" rel="external">科普文：为什么不能在服务器上 npm install ？</a>。</p>
<p>于是决定基于 <code>Docker</code> 做构建部署。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> daocloud.io/node:<span class="number">8.4</span>.<span class="number">0</span>-<span class="keyword">onbuild</span></div><div class="line"><span class="keyword">COPY</span> package*.json ./</div><div class="line"><span class="keyword">RUN</span> npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div class="line"><span class="keyword">RUN</span> cnpm install</div><div class="line"><span class="keyword">RUN</span> echo "Asia/Shanghai" &gt; /etc/timezone</div><div class="line"><span class="keyword">RUN</span> dpkg-reconfigure -f noninteractive tzdata</div><div class="line"><span class="keyword">COPY</span> . .</div><div class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></div><div class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span>, <span class="string">"$value1"</span>, <span class="string">"$value2"</span>, <span class="string">"$value3"</span>]</div></pre></td></tr></table></figure>
<p>用的比较简单，主要就是负责安装依赖，启动服务。需要注意的主要有两点：</p>
<ol>
<li>国内拉去外网的镜像很慢，像 Node 官方的镜像我都拉了好久都没拉下来，这样的话推荐使用国内的镜像，比如我用的 DaoCloud，还有阿里云镜像等等</li>
<li>由于推送服务是对时间敏感的，基础镜像的时区并不是国内时区，要手动设置一下</li>
</ol>
<p>然后去 <a href="https://dashboard.daocloud.io/" target="_blank" rel="external">DaoCloud</a> 等提供公有云服务的网站授权访问 Github 仓库，连接自己的主机，就可以实现持续集成，自动构建部署我们的镜像了。具体步骤可参考<a href="https://zhuanlan.zhihu.com/p/37961402" target="_blank" rel="external">基于 Docker 打造前端持续集成开发环境</a>。</p>
<p><img src="https://s2.ax1x.com/2019/06/01/V1wwRJ.jpg" alt="daocloud"></p>
<p>本次优化大概就到这里了。接下来要做的可能是提供一个推送历史查看页面，优先级不是很高，有时间再做吧（顺便练习一下 Nginx）。</p>
<p>现在的实现方案可能还是有很不合理的地方，欢迎提出建议。</p>
</div></article></div></main><footer><div class="paginator"><a href="/post/2018/translation-blink-render/" class="prev">PREV</a><a href="/post/2018/character-encoding/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>