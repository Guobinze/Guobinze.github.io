<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Minibase</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.colafornia.me/"/>
  <updated>2020-04-17T13:33:52.019Z</updated>
  <id>https://blog.colafornia.me/</id>
  
  <author>
    <name>Colafornia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>年轻人的第一次裸辞找工作面试记录</title>
    <link href="https://blog.colafornia.me/post/2020/2020-interviews/"/>
    <id>https://blog.colafornia.me/post/2020/2020-interviews/</id>
    <published>2020-04-17T14:00:00.000Z</published>
    <updated>2020-04-17T13:33:52.019Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2020-interview.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;16年本科毕业，一直以来也没太多面试经历。&lt;/p&gt;
&lt;p&gt;今年三月初裸辞，赶上疫情，有蛮多时间进行面试，按时间顺序面了伴鱼/好未来/OPPO/贝壳/滴滴/Shopee/头条/快手/阿里，在此特地总结一下。&lt;/p&gt;
&lt;p&gt;前面的面试都记得很认真，到后面精神和体力值都指数级下降，面经就记录得越发简洁了……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;&lt;p&gt;先放面经，主要贴一下与项目没太大关系的知识点考察题目&lt;/p&gt;
&lt;h3 id=&quot;伴鱼（C轮在线教育公司）Offer&quot;&gt;&lt;a href=&quot;#伴鱼（C轮在线教育公司）Offer&quot; class=&quot;headerlink&quot; title=&quot;伴鱼（C轮在线教育公司）Offer&quot;&gt;&lt;/a&gt;伴鱼（C轮在线教育公司）&lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;一开始投了两家教育类公司，算是我老东家的竞品，业务比较类似所以第一波来面。三轮技术面体验非常好，收到 offer 之后大前端负责人也给了很多关于选组与个人发展的建议。&lt;/p&gt;
&lt;h4 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;看代码说输出，常规 EventLoop 题目&lt;/li&gt;
&lt;li&gt;看代码说输出，考察 JavaScript 参数按值传递&lt;/li&gt;
&lt;li&gt;说说内存堆栈&lt;/li&gt;
&lt;li&gt;Fiber 架构&lt;/li&gt;
&lt;li&gt;尤雨溪说 Vue3 没有采用 Fiber，依然很快，为什么 （这是个好题目）&lt;/li&gt;
&lt;li&gt;懒加载与动态 import 语法的坑&lt;/li&gt;
&lt;li&gt;Webpack 怎么给 chunk 包命名，再说说怎么合理分包&lt;/li&gt;
&lt;li&gt;说说怎么本地调试 npm 包，考察 npm link&lt;/li&gt;
&lt;li&gt;WeakMap 是什么，相比 Object 有什么优点&lt;/li&gt;
&lt;li&gt;有没有写过 Webpack 插件，讲讲 Webpack 原理&lt;/li&gt;
&lt;li&gt;老生常谈说说从输入 url 到页面加载发生了什么，面试官追问了网络应用层以下的内容&lt;/li&gt;
&lt;li&gt;Promise 的状态，Promise.all 是干什么的&lt;/li&gt;
&lt;li&gt;Promise.then.catch.then 会执行吗&lt;/li&gt;
&lt;li&gt;HTTP 缓存&lt;/li&gt;
&lt;li&gt;简短聊了聊项目，顺着简历提到的性能优化点问了一些内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面&quot;&gt;&lt;a href=&quot;#二面&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;CI / CD怎么做的&lt;/li&gt;
&lt;li&gt;Docker 分层是什么，怎么做&lt;/li&gt;
&lt;li&gt;Tree-shaking 原理&lt;/li&gt;
&lt;li&gt;新版 React 的特性&lt;/li&gt;
&lt;li&gt;对 React 做的优化&lt;/li&gt;
&lt;li&gt;Hooks VS HOC/ Render Props&lt;/li&gt;
&lt;li&gt;给 Render props 传 pure component 有优化吗，解决了什么问题 （也是个埋坑问题）&lt;/li&gt;
&lt;li&gt;HTML 渲染机制， CSS 阻塞渲染吗&lt;/li&gt;
&lt;li&gt;合成层怎么触发，怎么分的&lt;/li&gt;
&lt;li&gt;Node 端 Event Loop&lt;/li&gt;
&lt;li&gt;微前端了解多少，如果让你做微前端的技术选型，你怎么考虑&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面&quot;&gt;&lt;a href=&quot;#三面&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;p&gt;三面是大前端负责人，疯狂问项目，也考察了对业务的思考和看法，没有什么具体的知识点就没记了&lt;/p&gt;
&lt;h3 id=&quot;好未来（中台）技术面通过，放弃-Offer&quot;&gt;&lt;a href=&quot;#好未来（中台）技术面通过，放弃-Offer&quot; class=&quot;headerlink&quot; title=&quot;好未来（中台）技术面通过，放弃 Offer&quot;&gt;&lt;/a&gt;好未来（中台）&lt;code&gt;技术面通过，放弃 Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;题目很神奇，恍惚回到了四年前找实习的时候 = = 两轮技术面但都没问什么有用的，就没怎么记&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSS 定位方式， sticky 的使用场景&lt;/li&gt;
&lt;li&gt;说说 CSS3 新属性&lt;/li&gt;
&lt;li&gt;居中方式， flex布局怎么做&lt;/li&gt;
&lt;li&gt;script 标签的 async 和 defer 属性&lt;/li&gt;
&lt;li&gt;怎么实现一个扑克牌翻转效果&lt;/li&gt;
&lt;li&gt;怎么实现一个富文本编辑器&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;OPPO（智能搜索-base-北京）-Offer&quot;&gt;&lt;a href=&quot;#OPPO（智能搜索-base-北京）-Offer&quot; class=&quot;headerlink&quot; title=&quot;OPPO（智能搜索 base 北京） Offer&quot;&gt;&lt;/a&gt;OPPO（智能搜索 base 北京） &lt;code&gt;Offer&lt;/code&gt;&lt;/h2&gt;&lt;h4 id=&quot;一面-1&quot;&gt;&lt;a href=&quot;#一面-1&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;JSBridge 原理&lt;/li&gt;
&lt;li&gt;React 16 中 Diff 算法的变化&lt;/li&gt;
&lt;li&gt;向一个 DOM 后面插入节点怎么做&lt;/li&gt;
&lt;li&gt;怎么实现 lodash.get 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-1&quot;&gt;&lt;a href=&quot;#二面-1&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;CDN 的特点，用 CDN 资源为什么快（分布式节点，回源，缓存，CDN 主动拉取）&lt;/li&gt;
&lt;li&gt;Vue 与 React 的区别&lt;/li&gt;
&lt;li&gt;浏览器渲染相关的思考，怎么优化，对平时开发有什么启示&lt;/li&gt;
&lt;li&gt;Node 的特点，为什么适合高并发&lt;/li&gt;
&lt;li&gt;Node 服务部署，运维&lt;/li&gt;
&lt;li&gt;Node 框架用的什么， Koa 与 Express 相比有什么不同&lt;/li&gt;
&lt;li&gt;简历项目挨个聊&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-1&quot;&gt;&lt;a href=&quot;#三面-1&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;介绍一个项目&lt;/li&gt;
&lt;li&gt;懒加载怎么做&lt;/li&gt;
&lt;li&gt;说说其它性能优化方式&lt;/li&gt;
&lt;li&gt;浏览器缓存&lt;/li&gt;
&lt;li&gt;路由模式&lt;/li&gt;
&lt;li&gt;HTTPS 原理&lt;/li&gt;
&lt;li&gt;ContentType 模式，formData 里面是什么结构&lt;/li&gt;
&lt;li&gt;数据上报怎么做，除了 img 标签&lt;/li&gt;
&lt;li&gt;git workflow，merge 与 rebase 的区别&lt;/li&gt;
&lt;li&gt;Promise 原理&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;四面&quot;&gt;&lt;a href=&quot;#四面&quot; class=&quot;headerlink&quot; title=&quot;四面&quot;&gt;&lt;/a&gt;四面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Node 底层了解多少&lt;/li&gt;
&lt;li&gt;React 冷启动很慢，为什么，哪些地方可以优化&lt;/li&gt;
&lt;li&gt;用户弱网环境问题排查与优化&lt;/li&gt;
&lt;li&gt;性能数据上报怎么实现，什么时候上报&lt;/li&gt;
&lt;li&gt;CSRF 防范方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;贝壳（如视）-Offer&quot;&gt;&lt;a href=&quot;#贝壳（如视）-Offer&quot; class=&quot;headerlink&quot; title=&quot;贝壳（如视） Offer&quot;&gt;&lt;/a&gt;贝壳（如视） &lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;如视是贝壳的 VR 业务线，链家、自如 app 里的 VR 看房就是他们做的，很好的团队，做的事情也很酷！&lt;/p&gt;
&lt;h4 id=&quot;一面-2&quot;&gt;&lt;a href=&quot;#一面-2&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;JSBridge 原理&lt;/li&gt;
&lt;li&gt;开发 WebView 遇到过哪些问题&lt;/li&gt;
&lt;li&gt;开发直播应用的心得体会（算是与简历项目相关）&lt;/li&gt;
&lt;li&gt;如何设计一个日志分析，现场还原系统（记录画面）&lt;/li&gt;
&lt;li&gt;实现一个单例&lt;/li&gt;
&lt;li&gt;算法，括号匹配问题，Leetcode Easy 题目小变形&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-2&quot;&gt;&lt;a href=&quot;#二面-2&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;SSO 鉴权流程&lt;/li&gt;
&lt;li&gt;samesite cookie&lt;/li&gt;
&lt;li&gt;toB 和 toC 业务特点，区别&lt;/li&gt;
&lt;li&gt;在上家公司遇到了什么问题，怎么解决的，技术和非技术都可以说说&lt;/li&gt;
&lt;li&gt;Electron 播放音视频踩过什么坑吗&lt;/li&gt;
&lt;li&gt;CSRF 防范方法&lt;/li&gt;
&lt;li&gt;Buffer 与 Stream&lt;/li&gt;
&lt;li&gt;createObjectURL 与 canvas.toDataURL&lt;/li&gt;
&lt;li&gt;base64 是什么&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-2&quot;&gt;&lt;a href=&quot;#三面-2&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;p&gt;聊项目为主，问了一些个人规划职业发展的问题&lt;/p&gt;
&lt;h3 id=&quot;滴滴（网约车-C端）-Offer&quot;&gt;&lt;a href=&quot;#滴滴（网约车-C端）-Offer&quot; class=&quot;headerlink&quot; title=&quot;滴滴（网约车 C端） Offer&quot;&gt;&lt;/a&gt;滴滴（网约车 C端） &lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;从晚上五点开始，连着面三轮，流程很快&lt;/p&gt;
&lt;h4 id=&quot;一面-3&quot;&gt;&lt;a href=&quot;#一面-3&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;TypeScript 里有哪些 JavaScript 没有的类型&lt;/li&gt;
&lt;li&gt;React Hooks 原理&lt;/li&gt;
&lt;li&gt;节流防抖的使用场景&lt;/li&gt;
&lt;li&gt;Event Loop&lt;/li&gt;
&lt;li&gt;数组与对象有哪些遍历方式，for…in 与 Object.keys 有什么区别&lt;/li&gt;
&lt;li&gt;ES6 的 Module 与 CommonJS&lt;/li&gt;
&lt;li&gt;Promise 有哪些方法，都是做什么的&lt;/li&gt;
&lt;li&gt;按需加载怎么做&lt;/li&gt;
&lt;li&gt;实现 Bind&lt;/li&gt;
&lt;li&gt;实现一个乱序算法&lt;/li&gt;
&lt;li&gt;实现一个深拷贝&lt;/li&gt;
&lt;li&gt;跨域场景与常规解决方案&lt;/li&gt;
&lt;li&gt;HTTP 缓存&lt;/li&gt;
&lt;li&gt;垂直居中与盒子模型&lt;/li&gt;
&lt;li&gt;图片跑马灯效果怎么实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-3&quot;&gt;&lt;a href=&quot;#二面-3&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;JSBridge 原理&lt;/li&gt;
&lt;li&gt;如何自己实现一个组件按需加载&lt;/li&gt;
&lt;li&gt;Webpack 原理，追问让说的更细一些&lt;/li&gt;
&lt;li&gt;Webpack 热更新原理&lt;/li&gt;
&lt;li&gt;Flex 布局&lt;/li&gt;
&lt;li&gt;BFC 的原理和使用场景&lt;/li&gt;
&lt;li&gt;CI/CD 怎么做的，哪些有提效&lt;/li&gt;
&lt;li&gt;说一件让你有成就感的事情&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-3&quot;&gt;&lt;a href=&quot;#三面-3&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;TypeScript type 与 interface 的区别&lt;/li&gt;
&lt;li&gt;React Fiber&lt;/li&gt;
&lt;li&gt;Babel loader 原理&lt;/li&gt;
&lt;li&gt;Node Stream 是干什么的&lt;/li&gt;
&lt;li&gt;写一个 ES5 继承&lt;/li&gt;
&lt;li&gt;写一个 twoSum 算法&lt;/li&gt;
&lt;li&gt;Webpack 常用优化方式&lt;/li&gt;
&lt;li&gt;Webpack 原理&lt;/li&gt;
&lt;li&gt;React 里 key 做什么的&lt;/li&gt;
&lt;li&gt;z-index 干啥的，有哪些条件会形成层叠上下文&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Shopee-卖家平台-base-深圳-Offer&quot;&gt;&lt;a href=&quot;#Shopee-卖家平台-base-深圳-Offer&quot; class=&quot;headerlink&quot; title=&quot;Shopee (卖家平台 base 深圳) Offer&quot;&gt;&lt;/a&gt;Shopee (卖家平台 base 深圳) &lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;疫情期间被家里催着回北方，就还是拒了 offer&lt;/p&gt;
&lt;h4 id=&quot;一面（各种基础题，没记多少）&quot;&gt;&lt;a href=&quot;#一面（各种基础题，没记多少）&quot; class=&quot;headerlink&quot; title=&quot;一面（各种基础题，没记多少）&quot;&gt;&lt;/a&gt;一面（各种基础题，没记多少）&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;CSS 块级元素与行内元素， BFC 等等&lt;/li&gt;
&lt;li&gt;各种看输出题目，event loop，原型链&lt;/li&gt;
&lt;li&gt;写一个大数加法&lt;/li&gt;
&lt;li&gt;写一个数组拍平&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-4&quot;&gt;&lt;a href=&quot;#二面-4&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;遍历 Object 属性的方式，哪些可以只遍历自有属性&lt;/li&gt;
&lt;li&gt;async 的异常捕获&lt;/li&gt;
&lt;li&gt;如何并发执行 async&lt;/li&gt;
&lt;li&gt;针对 HTTP 请求的优化方案&lt;/li&gt;
&lt;li&gt;icon 是怎么引入的， iconfont 里面怎么识别我们引入的 icon&lt;/li&gt;
&lt;li&gt;如何检测浏览器、服务器是否支持 http2.0&lt;/li&gt;
&lt;li&gt;Sentry 这类监控怎么监控错误的，对于跨域脚本错误呢&lt;/li&gt;
&lt;li&gt;GraphQL 接口的性能与质量，单机QPS多少，单核还是多核部署（这个算问项目）&lt;/li&gt;
&lt;li&gt;怎么做懒加载，如果我们想点击一个按钮，然后动态加载 modal，要怎么做&lt;/li&gt;
&lt;li&gt;mobx 和 redux&lt;/li&gt;
&lt;li&gt;实现一个记忆函数&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;头条（广告系统）Offer&quot;&gt;&lt;a href=&quot;#头条（广告系统）Offer&quot; class=&quot;headerlink&quot; title=&quot;头条（广告系统）Offer&quot;&gt;&lt;/a&gt;头条（广告系统）&lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;快被二面虐哭了&lt;/p&gt;
&lt;h4 id=&quot;一面-4&quot;&gt;&lt;a href=&quot;#一面-4&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;移动端自适应方案&lt;/li&gt;
&lt;li&gt;几道看输出的题目，考察变量声明提升，暂时性死区，原型链&lt;/li&gt;
&lt;li&gt;React 虚拟 DOM diff 算法&lt;/li&gt;
&lt;li&gt;Webpack HMR 原理&lt;/li&gt;
&lt;li&gt;说几个 HTTP Content-Type&lt;/li&gt;
&lt;li&gt;cookie 的属性有哪些，都是干啥的&lt;/li&gt;
&lt;li&gt;React 组件间通信机制&lt;/li&gt;
&lt;li&gt;React 路由模式原理&lt;/li&gt;
&lt;li&gt;JSBridge 原理&lt;/li&gt;
&lt;li&gt;手写实现 Promise.all，后面还有加上并发限制的几个小变形&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-5&quot;&gt;&lt;a href=&quot;#二面-5&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;聊聊 React Fiber，Fiber 是依据什么切分任务的&lt;/li&gt;
&lt;li&gt;显示器刷新率与浏览器帧率&lt;/li&gt;
&lt;li&gt;瀑布流计算逻辑&lt;/li&gt;
&lt;li&gt;CSS 幽灵空白节点与解决方案&lt;/li&gt;
&lt;li&gt;CSS 行内元素的 baseline 问题&lt;/li&gt;
&lt;li&gt;写个深拷贝&lt;/li&gt;
&lt;li&gt;Object.create 是干啥的，自己实现一个&lt;/li&gt;
&lt;li&gt;JavaScript 里的包装类型&lt;/li&gt;
&lt;li&gt;聊聊 JavaScript 的语法解析， JIT 等等&lt;/li&gt;
&lt;li&gt;WebAssembly 了解么，是干啥的&lt;/li&gt;
&lt;li&gt;说说最近很火的面试题 a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3&lt;/li&gt;
&lt;li&gt;聊聊尾递归&lt;/li&gt;
&lt;li&gt;HTTPS 原理&lt;/li&gt;
&lt;li&gt;HTTP 缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-4&quot;&gt;&lt;a href=&quot;#三面-4&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;介绍一个项目&lt;/li&gt;
&lt;li&gt;这个项目还有哪些可以做的优化，技术优化，产品优化等等&lt;/li&gt;
&lt;li&gt;错误监控的实现原理&lt;/li&gt;
&lt;li&gt;数据上报的几种方案比较&lt;/li&gt;
&lt;li&gt;挨个问了问简历里大佬比较感兴趣的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;快手（中台）Offer&quot;&gt;&lt;a href=&quot;#快手（中台）Offer&quot; class=&quot;headerlink&quot; title=&quot;快手（中台）Offer&quot;&gt;&lt;/a&gt;快手（中台）&lt;code&gt;Offer&lt;/code&gt;&lt;/h3&gt;&lt;h4 id=&quot;一面-5&quot;&gt;&lt;a href=&quot;#一面-5&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;聊了很久项目，各种项目&lt;/li&gt;
&lt;li&gt;Webpack 常见优化手段&lt;/li&gt;
&lt;li&gt;Webpack 里有几种哈希，都是干什么的&lt;/li&gt;
&lt;li&gt;实现 LRU&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-6&quot;&gt;&lt;a href=&quot;#二面-6&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;介绍一个项目&lt;/li&gt;
&lt;li&gt;介绍一下 React Hooks，相比于 HOC 它有什么特点，解决了什么问题&lt;/li&gt;
&lt;li&gt;Mobx 如何监听到 Object array 的元素属性变化&lt;/li&gt;
&lt;li&gt;开发移动端与 PC 端项目有什么不同&lt;/li&gt;
&lt;li&gt;JSBridge 原理，怎么解决安全问题&lt;/li&gt;
&lt;li&gt;实现 Promise.all，加上一些变形&lt;/li&gt;
&lt;li&gt;写个 treeToArray，再写个 arrayToTree&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-5&quot;&gt;&lt;a href=&quot;#三面-5&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;移动端适配方案，rem 解决了什么问题，为什么要采用 rem&lt;/li&gt;
&lt;li&gt;只用原生 API 实现一个拖拽跟随效果（好题目，又扩展地问了很多问题，有空再写写）&lt;/li&gt;
&lt;li&gt;除了你一面说的那些，Webpack 还有什么优化手段（这个问法好厉害…）&lt;/li&gt;
&lt;li&gt;深入考察了一波 CSS 绝对定位，相对定位，块级元素的本身概念&lt;/li&gt;
&lt;li&gt;拐着弯问了个 @import 的特性和坑&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;阿里（钉钉-base-北京）HR面挂&quot;&gt;&lt;a href=&quot;#阿里（钉钉-base-北京）HR面挂&quot; class=&quot;headerlink&quot; title=&quot;阿里（钉钉 base 北京）HR面挂&quot;&gt;&lt;/a&gt;阿里（钉钉 base 北京）&lt;code&gt;HR面挂&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;作为面试季的结束，这个结果挺酸爽的……&lt;/p&gt;
&lt;p&gt;总体感觉钉钉重点考察候选人对业务甚至商业模式的理解，hr 面都详细地问了做的事情对业务的帮助与影响，当前业务模式下技术有哪些手段可以降低项目成本等等&lt;/p&gt;
&lt;p&gt;由于已经到了面试季的最尾声了，题目几乎都没怎么记，其实挺多知识点的切入，扩展方式都很赞&lt;/p&gt;
&lt;h4 id=&quot;一面-6&quot;&gt;&lt;a href=&quot;#一面-6&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;聊项目&lt;/li&gt;
&lt;li&gt;React Fiber&lt;/li&gt;
&lt;li&gt;比较一下 Mixin / HOC / Hooks&lt;/li&gt;
&lt;li&gt;数据劫持的几种方式&lt;/li&gt;
&lt;li&gt;手写 compareVersion 两种解法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二面-7&quot;&gt;&lt;a href=&quot;#二面-7&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;聊项目，有没有调研过业界竞品的技术方案&lt;/li&gt;
&lt;li&gt;CI 怎么做的， E2E测试的具体收益，适用于哪些场景&lt;/li&gt;
&lt;li&gt;扫码登录的实现逻辑&lt;/li&gt;
&lt;li&gt;JSBridge 原理&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;三面-6&quot;&gt;&lt;a href=&quot;#三面-6&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;各种聊项目，对过往工作经历里的一些业务理解（各种对业务的理解，有哪些深挖的点）&lt;/li&gt;
&lt;li&gt;聊虚拟 DOM 和 diff 算法，与真实 DOM 对比&lt;/li&gt;
&lt;li&gt;聊闭包&lt;/li&gt;
&lt;li&gt;聊工程化&lt;/li&gt;
&lt;li&gt;聊 Web 安全&lt;/li&gt;
&lt;li&gt;聊 Go 语言&lt;/li&gt;
&lt;li&gt;聊你对钉钉的看法和对业务，前景理解&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;四面-1&quot;&gt;&lt;a href=&quot;#四面-1&quot; class=&quot;headerlink&quot; title=&quot;四面&quot;&gt;&lt;/a&gt;四面&lt;/h4&gt;&lt;p&gt;这一面聊技术的内容不多，更多还是一些职业规划，技术规划，和业务方有分歧怎么处理这些软素质相关的问题。&lt;/p&gt;
&lt;p&gt;四面之后本来还要有一轮大佬面，但是时间没排上就先进行 hr 面了，hr 面了一个半小时，然后就挂了…&lt;/p&gt;
&lt;h1 id=&quot;体会&quot;&gt;&lt;a href=&quot;#体会&quot; class=&quot;headerlink&quot; title=&quot;体会&quot;&gt;&lt;/a&gt;体会&lt;/h1&gt;&lt;p&gt;本来春节期间趁着在家还着重刷了一波算法的，但还是菜，面试期间手撕算法的场合也不多。&lt;/p&gt;
&lt;p&gt;除了以上列出的技术考察点，还是聊项目更多，所以功在平时，好好做项目，多思考是必要积累。大多数面试里都是一轮纯基础面，类似于题库抽题的方式来考察各种基本点。第一轮通过之后都是聊项目为主，穿插着一些技术点面试也是很虚的“聊聊xx”，在我看来这种提问方式很考察对技术点的纵向理解，要自己扩展着一直说说说才行，这种题目也达成了一问一答的话就会减分，在面试官那里看起来是卡壳的。&lt;/p&gt;
&lt;p&gt;对于贴在简历里的项目而言，项目的方方面面自己都要心里有数，最基本的打包体积有多少，首屏时间有多少，除此之外，针对项目在业务上下游中的作用也要有所了解和思考。针对面试官对项目的提问，一些场景的方案设计也要尽量做到，从业务出发，主要为业务考虑，权衡多种方案，给出自己的答案。&lt;strong&gt;很多时候，思考过程比答案更重要，毕竟面试并不是考察机器记忆。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是要继续努力才行~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2020-interview.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;16年本科毕业，一直以来也没太多面试经历。&lt;/p&gt;
&lt;p&gt;今年三月初裸辞，赶上疫情，有蛮多时间进行面试，按时间顺序面了伴鱼/好未来/OPPO/贝壳/滴滴/Shopee/头条/快手/阿里，在此特地总结一下。&lt;/p&gt;
&lt;p&gt;前面的面试都记得很认真，到后面精神和体力值都指数级下降，面经就记录得越发简洁了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="interview" scheme="https://blog.colafornia.me/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>React Hooks 起手式</title>
    <link href="https://blog.colafornia.me/post/2020/react-hooks-starter/"/>
    <id>https://blog.colafornia.me/post/2020/react-hooks-starter/</id>
    <published>2020-01-06T14:10:00.000Z</published>
    <updated>2020-01-17T03:24:56.661Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/react-hooks-cover.jpeg&quot; alt=&quot;react hooks cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;React Hooks 在 React@16.8 版本中正式发布，之后在两个项目中尝鲜使用了一下，很大提升了开发效率和体验，尤其是在 WebRTC 直播项目里，简直是救我狗命的存在。在此来整理一下相关知识，用一个舒适的顺序剖析关于 React Hooks 的方方面面。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;They let you use state and other React features without writing a class.&lt;/p&gt;
&lt;p&gt;React hooks 可以让你在 Class 之外使用 state 以及 React 的其它特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React 的官方文档中明确说明了引入 React Hooks 是为了解决以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;难以在组件间复用逻辑&lt;/p&gt;
&lt;p&gt;之前是通过 render props 和 高阶组件（HOC）来解决的，但这大大提升了程序的复杂度，多个高阶组件的嵌套也会形成嵌套地狱（Wrapper Hell）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件越来越复杂，难以理解难以维护&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​       复杂的生命周期机制，每个生命周期方法里都是几种不相干的逻辑代码和副作用。事件监听的代码在 &lt;code&gt;componentDidMount&lt;/code&gt;里，解绑的清理代码在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 里，这让组件更难拆分了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Class 让人和计算机都难以理解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​      光 &lt;code&gt;this&lt;/code&gt; 指针这一项就已经有点难用了，除此之外，Class 对于代码压缩与热加载也并不友好，会有一些边界 Case。&lt;/p&gt;
&lt;p&gt;因此，我们可以理解为 React Hooks 的&lt;strong&gt;设计目标&lt;/strong&gt;就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;免去编写 Class 的复杂性，解决生命周期的复杂性&lt;/li&gt;
&lt;li&gt;解决逻辑复用难的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们来看看是怎么实现的。&lt;/p&gt;
&lt;h3 id=&quot;Implement&quot;&gt;&lt;a href=&quot;#Implement&quot; class=&quot;headerlink&quot; title=&quot;Implement&quot;&gt;&lt;/a&gt;Implement&lt;/h3&gt;&lt;p&gt;看到前面的动机，可能心里会有个念头“既然 Class 这么难用，当初为什么要这么设计非要使用 Class 来编写组件呢”。这当然有其历史必然性了。&lt;/p&gt;
&lt;p&gt;React 中有两种组件形式，Class 类组件与 Function 函数组件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class Component&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(props)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(props);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    componentDidMount() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.fetchData()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Function Component&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;App&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;links&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#123;links.map((&amp;#123;href, title&amp;#125;)=&amp;gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;href&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;title&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt; )&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类组件中会维护内部状态，函数组件则是无状态的。&lt;/p&gt;
&lt;p&gt;这就是关键之处，&lt;strong&gt;函数组件无法保存状态&lt;/strong&gt;，每次重新运行函数都会导致其作用域内所有函数被重置，也无法像类组件一样通过继承  &lt;code&gt;React.Component&lt;/code&gt; 原型上的方法 &lt;code&gt;setState&lt;/code&gt; 来更新自己的状态。所以，在过去，如果我们想让一个函数组件具有状态，就不得不将其转为类组件。&lt;/p&gt;
&lt;p&gt;那么，如果我们想抛弃 Class，转向函数组件的话，必须解决的事便是让函数组件也能保留、修改、持久化自己的状态。&lt;/p&gt;
&lt;p&gt;怎么能让函数状态持久化？&lt;/p&gt;
&lt;p&gt;答案是 &lt;strong&gt;闭包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/06/ly6NJ1.md.png&quot; alt=&quot;closure&quot;&gt;&lt;/p&gt;
&lt;p&gt;惊不惊喜，意不意外？就是初学 JavaScript 时阴魂不散的闭包，简直闭包天天见。&lt;/p&gt;
&lt;h4 id=&quot;Based-on-closures&quot;&gt;&lt;a href=&quot;#Based-on-closures&quot; class=&quot;headerlink&quot; title=&quot;Based on closures&quot;&gt;&lt;/a&gt;Based on closures&lt;/h4&gt;&lt;p&gt;所以，以 &lt;code&gt;useState&lt;/code&gt; 为例，我们可以简单实现（以下均为简单实现，非源码）为：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _state&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; useState = (initialValue) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _state = _state || initialValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; setState = (newValue) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _state = newValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [_state, setState]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;怎么支持组件内维护多个状态？最简单的方式当然是用数组：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _hooks = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _cursor = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;useState&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;initialValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _hooks[_cursor] = _hooks[_cursor] || initialValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; setStateHookCursor = _cursor&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; setState = (newVal) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _hooks[setStateHookCursor] = newVal&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [hooks[_cursor++], setState]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;维护一个数组变量，一个锚点 cursor 就可以指哪打哪，准确读取、修改状态值了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useEffect&lt;/code&gt; 也是类似的，只是状态数组里保存的是 deps，除此之外再增加一个浅比较 deps 是否有变化的逻辑即可：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;useEffect&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback, depArray&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; hasNoDeps = !depArray&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; deps = _hooks[_cursor]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; hasChangedDeps =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    !deps || !depArray.every((el, i) =&amp;gt; el === deps[i])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hasNoDeps || hasChangedDeps) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    callback()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    hooks[_cursor] = depArray&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  _cursor++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;React 的源码实现当然比上面复杂的多，事实上，React Hooks 是在 Fiber 架构基础上实现的。&lt;/p&gt;
&lt;h4 id=&quot;Based-on-Fiber&quot;&gt;&lt;a href=&quot;#Based-on-Fiber&quot; class=&quot;headerlink&quot; title=&quot;Based on Fiber&quot;&gt;&lt;/a&gt;Based on Fiber&lt;/h4&gt;&lt;p&gt;按照&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方的说法&lt;/a&gt;，&lt;code&gt;React Fiber&lt;/code&gt; 是&lt;strong&gt;对核心算法的一次重新实现&lt;/strong&gt;，也可以说它是一个新的 &lt;code&gt;Reconciler&lt;/code&gt;。所以，  &lt;code&gt;Reconciler&lt;/code&gt; 是什么呢？&lt;/p&gt;
&lt;p&gt;React 的源码可以分为三个主要部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;React Core&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这一部分只涵盖了与定义组件相关的顶层 API&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Renderers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;渲染器模块负责管理 React 树如何被具体底层平台所调用，Web 则为 DOM API，React Native 的话则是安卓 iOS 的视图 API。&lt;/p&gt;
&lt;p&gt;除此之外还有 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-test-renderer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Test Renderer&lt;/a&gt; 渲染器，可以把 React 组件转化为 JSON 树，供 Jest 这类测试框架做快照测试使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reconcilers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Reconciler 是一种 diff 算法用以确定在状态改变时需要更新那些 DOM 元素。它没有公开的 API，因此也没被独立打包，它只被 React DOM 和 React Native 这类渲染器使用&lt;/p&gt;
&lt;p&gt;在推出 v16 的 Fiber 架构后，新的 Reconciler 被称为 &lt;code&gt;Fiber Reconciler&lt;/code&gt;，v15 及之前的实现则被称为 &lt;code&gt;Stack Reconciler&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.atulr.com/static/cc397bd7316079f477f29f36fd058a80/832fe/common-reconciler.png&quot; alt=&quot;react codebase&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解到这里， &lt;code&gt;Fiber Reconciler&lt;/code&gt; 是为了解决 React v15 的DOM元素多，频繁刷新场景下的主线程阻塞问题，直观显示，则是“掉帧”问题。v15 是一次同步处理整个组件树，通过递归的方式进行渲染，使用 JavaScript 引擎自身的函数调用栈，它会一直执行到栈空位置，一旦工作量大就会阻塞整个主线程（就像前面说的用 HOC 方式形成 Wrapper Hell 的话不仅 debug 难，对性能也会产生严重影响）。然而我们的更新工作可能并不需要一次性同步完成，其中是可以按照优先级调整工作，把整个过程分片处理的，这就是 Fiber 想做的事。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;Fiber Reconciler&lt;/code&gt; 以&lt;strong&gt;链表&lt;/strong&gt;的形式遍历组件数，可以灵活的暂停、继续、放弃当前任务。通过 Scheduler 调度器来进行任务分配，每次只做一个小任务，通过 &lt;code&gt;requestIdleCallback&lt;/code&gt; 回到主线程看看有没有更高优先级的任务需要处理，如果有就暂停当前任务，去做优先级更高的，否则就继续执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/06/lycVOO.md.png&quot; alt=&quot;Fiber&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于 Fiber 的内容可以了解的还有更多，包括它是怎么划分优先级的，对现有代码的影响等等。但是还是先回到关于 Hooks 的实现。&lt;/p&gt;
&lt;p&gt;Fiber 的类型定义在&lt;a href=&quot;https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiber.js#L127&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码的 react-reconciler/src/ReactFiber.js 文件里&lt;/a&gt;，我们抽取一下需要了解的字段：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; type Fiber = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  tag: WorkTag,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  key: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; | string,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  type: any,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  memoizedState: any&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;memoizedState&lt;/code&gt; 就是用来储存当前渲染节点的最终状态值。&lt;/p&gt;
&lt;p&gt;我们再看一下 &lt;a href=&quot;https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiberHooks.js#L142&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hook 的类型定义&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; type Hook = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  memoizedState: any,        &lt;span class=&quot;comment&quot;&gt;// 上一次更新之后的最终状态值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  queue: UpdateQueue | &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 更新队列，存储多次更新操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  next: Hook | &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,         &lt;span class=&quot;comment&quot;&gt;// 指向链表的下一个 Hook&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type Update &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  action: any,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  next: Update,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;type UpdateQueue &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  last: Update,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  dispatch: any,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  lastRenderedState: any,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不难看到，在实际的实现中，React Hooks 并没有采用数组，而是通过单向链表的方式来存储多个 Hooks。&lt;/p&gt;
&lt;p&gt;除此之外，可以看到 Queue 有个 last 字段，我们可以调用 &lt;a href=&quot;https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiberHooks.js#L1224&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dispatchAction&lt;/a&gt;（即更新 state 的方法） 多次，也只有最后那次会生效，生效为 last 存储的最后一次 update 的 state 值。&lt;/p&gt;
&lt;p&gt;因此，在每个组件内，都会有个 Fiber 对象以这样的形式来存储：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [catName, setCatName] = useState(&lt;span class=&quot;string&quot;&gt;&#39;Tom&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [mouseName, setMouseName] = useState(&lt;span class=&quot;string&quot;&gt;&#39;Jerry&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;setCatName(&lt;span class=&quot;string&quot;&gt;&#39;Tommy&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// FiberNode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fiber = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    memoizedState: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        memoizedState: &lt;span class=&quot;string&quot;&gt;&#39;Tom&#39;&lt;/span&gt;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        queue: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            last: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                action: &lt;span class=&quot;string&quot;&gt;&#39;Tommy&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;,  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            dispatch: dispatch,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            lastRenderedState: &lt;span class=&quot;string&quot;&gt;&#39;Tommy&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        next: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            memoizedState: &lt;span class=&quot;string&quot;&gt;&#39;Jerry&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            queue: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            next: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用 Hook API 实际上就是新增一个 Hook 实例并将其追加到 Hooks 链表上，返回给组件的是这个 Hook 的 state 和对应的 setter，链表的结构决定了 re-render 时 React 并不会知道这个 setter 对应的是哪个 hooks，因此它会从链表的头开始一一执行（这是采用了链表结构的弊端，但是如果通过 HashMap 来存储的话，每次调用 Hook API 都需要显示地传入一个 Key 值来区分不同 Hook，更复杂了）。&lt;/p&gt;
&lt;p&gt;这个 Hooks 链表是在 mount 阶段时构造的，所以声明 Hook 时的&lt;strong&gt;顺序很重要&lt;/strong&gt;，这也是为什么我们只能在函数组件顶部作用域调用Hook API，不能在条件语句、循环、子函数里调用 Hooks。&lt;/p&gt;
&lt;h3 id=&quot;Notice-Capture-Value&quot;&gt;&lt;a href=&quot;#Notice-Capture-Value&quot; class=&quot;headerlink&quot; title=&quot;Notice: Capture Value&quot;&gt;&lt;/a&gt;Notice: Capture Value&lt;/h3&gt;&lt;p&gt;这是一个新手常见坑，首先来看一段代码（&lt;a href=&quot;https://codesandbox.io/s/k5pmk0omx7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线地址&lt;/a&gt;）：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [count, setCount] = useState(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; handleAlertClick = useCallback(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;You clicked on: &quot;&lt;/span&gt; + count);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;, &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [count]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;You clicked &amp;#123;count&amp;#125; times&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onClick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; setCount(count + 1)&amp;#125;&amp;gt;增加 count&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onClick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;handleAlertClick&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;显示 count&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;先点击 “显示 count” 按钮，然后快速点击 “增加 count” 两下，会发现 alert 弹窗上显示的是 0，然而 p 标签里已经是2了。这就是 React Hook 的 &lt;code&gt;Capture Value&lt;/code&gt; 快照特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/17/lziPWn.png&quot; alt=&quot;image-20200106180246276&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Each Render Has Its Own Props and State&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住，每次 Render 都有自己的 Props 和 State&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次 Render 的内容都会形成一个快照并保存下来，因此当状态变更而 re-render 时，就有了 N 个快照，每个都拥有自己独立的，固定不变的 Props 和 State。在每个快照之间（在这段代码里即每次点击之间），count 只是一个常量，不存在数据绑定，watcher 或者 proxy 之类的东西，它只是一个常量数字。因此点击“显示 count” 按钮时，当前快照内 count 值为 0，alert 弹窗为 0，后面无论点击多少次“增加 count” 按钮，都是新的快照，与它无关了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Capture Value&lt;/code&gt; 特性存在于除 &lt;code&gt;useRef&lt;/code&gt; 之外的所有 Hook API 中（因为&lt;strong&gt;非 useRef 相关的 Hook API，本质上都形成了闭包，闭包有自己独立的状态，这就是 Capture Value 的本质&lt;/strong&gt;）。所以如果想避免上述例子中取不到 state 最新值的情况，可以通过 &lt;code&gt;useRef&lt;/code&gt; 把所需的 state 值保存下来：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Example&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [count, setCount] = useState(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; countRef = useRef(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; handleAlertClick = useCallback(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;You clicked on: &quot;&lt;/span&gt; + countRef.current);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;, &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [count]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;You clicked &amp;#123;count&amp;#125; times&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onClick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        countRef.current = count + 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setCount(count + 1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&amp;#125;&amp;gt;增加 count&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onClick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;handleAlertClick&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;显示 count&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Hooks-API&quot;&gt;&lt;a href=&quot;#Hooks-API&quot; class=&quot;headerlink&quot; title=&quot;Hooks API&quot;&gt;&lt;/a&gt;Hooks API&lt;/h3&gt;&lt;p&gt;接下来简单介绍一下官方的几个有意思的 Hooks 的常规用法和注意事项。&lt;/p&gt;
&lt;h4 id=&quot;useRef&quot;&gt;&lt;a href=&quot;#useRef&quot; class=&quot;headerlink&quot; title=&quot;useRef&quot;&gt;&lt;/a&gt;useRef&lt;/h4&gt;&lt;p&gt;前面在 Capture Value 也介绍了，它是唯一返回 mutable 数据的 Hook，它不仅可以 DOM 引用，还可以存储任意 JavaScript 值。&lt;/p&gt;
&lt;p&gt;修改 useRef 的值必须改其 current 属性，否则不会触发 re-render&lt;/p&gt;
&lt;h4 id=&quot;useCallback&quot;&gt;&lt;a href=&quot;#useCallback&quot; class=&quot;headerlink&quot; title=&quot;useCallback&quot;&gt;&lt;/a&gt;useCallback&lt;/h4&gt;&lt;p&gt;useCallback 可以保证在 re-render 之间返回的始终是同一回调引用：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 只要 a 或 b 不变，这个值就不会变化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; memoizedCallback = useCallback(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  doSomething(a, b);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, [a, b]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是，用 useCallback 包裹的函数所用参数，也必须在 hook 的 deps 数组里。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Counter&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [count, setCount] = useState(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; handleIncrement = useCallback(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    setCount(count + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, [count])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#123;count&amp;#125;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;ComplexButton&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onClick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;handleIncrement&amp;#125;&lt;/span&gt;&amp;gt;&lt;/span&gt;increment&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;ComplexButton&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不使用 useCallback 来包住回调函数的话，那么每次点击按钮修改 count 值时触发 re-render 生成新的回调函数，传入 ComplexButton 的 props 发生变化，导致了 ComplexButton 重新渲染。&lt;/p&gt;
&lt;h4 id=&quot;useMemo&quot;&gt;&lt;a href=&quot;#useMemo&quot; class=&quot;headerlink&quot; title=&quot;useMemo&quot;&gt;&lt;/a&gt;useMemo&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; memoizedValue = useMemo(() =&amp;gt; computeExpensiveValue(a, b), [a, b]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;仅当依赖项发生改变时，才会重新计算  memoizedValue，常被用于缓存昂贵计算函数的返回值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;useCallback(fn, deps)&lt;/code&gt;== &lt;code&gt;useMemo(() =&amp;gt; fn, deps)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;React 提供了一个与类组件的 &lt;code&gt;PureComponent&lt;/code&gt; 相同功能的 API &lt;code&gt;React.memo&lt;/code&gt;，会在自身 re-render 时，对每一个 &lt;code&gt;props&lt;/code&gt; 项进行浅比较，如果引用没有变化，就不会触发重渲染。&lt;/p&gt;
&lt;h4 id=&quot;useReducer&quot;&gt;&lt;a href=&quot;#useReducer&quot; class=&quot;headerlink&quot; title=&quot;useReducer&quot;&gt;&lt;/a&gt;useReducer&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; [state, dispatch] = useReducer(reducer, initialArg, init);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;useState 用于相对扁平结构的状态，useReducer 则用于复杂结构的状态。而其返回的 dispatch 方法可以放心传递给子组件，而不会造成子组件的 re-render&lt;/p&gt;
&lt;p&gt;具体可参考 &lt;a href=&quot;https://codesandbox.io/s/xzr480k0np&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dan Abramov 的示例代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先写到这里，后面希望可以再学习整理一下 React Hooks 的逻辑复用实践~&lt;/p&gt;
&lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KJP1E-Y-xyo&amp;amp;t=930s&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Getting Closure on React Hooks by Shawn Wang | JSConf.Asia 2019 - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Making Sense of React Hooks - Dan Abramov - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React hooks: not magic, just arrays - Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.atulr.com/react-custom-renderer-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Beginners guide to Custom React Renderers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infoq.cn/article/fiWNgsIOLaCmt-hphLYC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Hook 构建过程：没有设计就是最好的设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chemdemo/chemdemo.github.io/issues/15&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Hooks完全上手指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/react-hooks-cover.jpeg&quot; alt=&quot;react hooks cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;React Hooks 在 React@16.8 版本中正式发布，之后在两个项目中尝鲜使用了一下，很大提升了开发效率和体验，尤其是在 WebRTC 直播项目里，简直是救我狗命的存在。在此来整理一下相关知识，用一个舒适的顺序剖析关于 React Hooks 的方方面面。&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="https://blog.colafornia.me/categories/react/"/>
    
    
  </entry>
  
  <entry>
    <title>2019 年度总结</title>
    <link href="https://blog.colafornia.me/post/2019/2019-review/"/>
    <id>https://blog.colafornia.me/post/2019/2019-review/</id>
    <published>2019-12-31T14:00:00.000Z</published>
    <updated>2019-12-31T16:29:14.669Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/chengdu-2019.jpeg&quot; alt=&quot;sunset roller coaster&quot;&gt;&lt;/p&gt;
&lt;p&gt;2019:  to see the world as it is, and &lt;em&gt;to love it&lt;/em&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;工作与学习&quot;&gt;&lt;a href=&quot;#工作与学习&quot; class=&quot;headerlink&quot; title=&quot;工作与学习&quot;&gt;&lt;/a&gt;工作与学习&lt;/h3&gt;&lt;p&gt;写&lt;a href=&quot;/post/2019/2018-review/&quot;&gt;去年的年终总结&lt;/a&gt;当天收到了百词斩的 offer，这让这一整年画风都变得完全不一样了。&lt;/p&gt;
&lt;p&gt;接触到了我自以为从不会踏足的“儿童教育”领域，体验了“966”的神奇作息，被“成都式外企”的英文用语轰炸了一年，也在圣诞被拉到了西双版纳和全公司一起“读书”。&lt;/p&gt;
&lt;p&gt;这一年总算是得偿所愿做了很多服务器相关的东西，用 &lt;code&gt;Golang&lt;/code&gt; 开发了内容量产系统（总算学习且投产了一门新的编程语言），也给基于 &lt;code&gt;Ruby on Rails&lt;/code&gt; 的老项目做了些删删改改，这大概是今年与 Coding 相关的最激动人心的事情了。&lt;/p&gt;
&lt;p&gt;在前端的投入并不算多，与其概括为平台期，“疲劳期”可能更为合适，做了三年多的前端开发之后，更想一窥 Web 软件开发的全貌，而不是沉迷于 TC39 的提案或是前端框架的源码了。与前端比较相关的内容也基本是关于工程化，&lt;code&gt;CI/CD&lt;/code&gt; 等等。到了年底翻了翻各个技术资讯平台上的内容还是集中在事件循环，deep clone , vue 原理的时候松了口气，问题不大不用太慌，当然关于 &lt;code&gt;WebAssembly&lt;/code&gt;，&lt;code&gt;Serverless&lt;/code&gt; ， &lt;code&gt;TypeScript&lt;/code&gt; 最佳实践这些东西还是要尽快打起鸡血学起来。&lt;/p&gt;
&lt;p&gt;关于工作最大的收获还是一个好 leader，带着我去做了这些很 Cool 的东西，让我对写代码这件事的态度从“小心翼翼别搞坏了”变成了“来吧都能学，我也都能搞得定，要么能 fancy 地搞定，最差也能挫挫地解决”。这大概是给我高投入高消耗了三年多的开发经历里注入一管新鲜血液，让我能走得更远。&lt;/p&gt;
&lt;p&gt;关于计算机基础学习有了一些进步，刷了 &lt;a href=&quot;https://github.com/Colafornia/Coursera&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coursera&lt;/a&gt; 的两门课，北大的计算机组成原理和普林斯顿的算法，野生程序员的野生含量低了点。&lt;/p&gt;
&lt;p&gt;今年的一大变化是显式地学了很多英语，平时跟着公司的薄荷英语作为每日的基本英语输入，年底裸考了一把均6的雅思感觉还是很6的（至于为啥变成裸考又是个 long long story 了）。学习过程中发现我的发音还是很成问题，元音的发音有些是混淆的，基本都是往小嘴型，往懒的方向发音，现在想纠正回来真的很费劲。&lt;/p&gt;
&lt;h3 id=&quot;生活与玩乐&quot;&gt;&lt;a href=&quot;#生活与玩乐&quot; class=&quot;headerlink&quot; title=&quot;生活与玩乐&quot;&gt;&lt;/a&gt;生活与玩乐&lt;/h3&gt;&lt;p&gt;「没有年假的 966 生活与玩乐就相当于没有吧」&lt;/p&gt;
&lt;h4 id=&quot;健身&quot;&gt;&lt;a href=&quot;#健身&quot; class=&quot;headerlink&quot; title=&quot;健身&quot;&gt;&lt;/a&gt;健身&lt;/h4&gt;&lt;p&gt;今年没有买私教课，选择自己练了，练的不是很较真，“三分练七分吃”里大概只得了一分练两分吃，今年的锻炼主要是为了保证运动量和心肺锻炼，避免在 966 里萎靡不振。但是年底 trans 到新的项目组之后，可以利用的健身时间越来越少了，这是新年亟待解决的第一个问题。&lt;/p&gt;
&lt;h4 id=&quot;观影与阅读&quot;&gt;&lt;a href=&quot;#观影与阅读&quot; class=&quot;headerlink&quot; title=&quot;观影与阅读&quot;&gt;&lt;/a&gt;观影与阅读&lt;/h4&gt;&lt;p&gt;今年电影和剧看得都很少，书有 36 本，达标了去年定的 35本+，基本上大多数都是非技术类。&lt;/p&gt;
&lt;h4 id=&quot;年度最佳清单&quot;&gt;&lt;a href=&quot;#年度最佳清单&quot; class=&quot;headerlink&quot; title=&quot;年度最佳清单&quot;&gt;&lt;/a&gt;年度最佳清单&lt;/h4&gt;&lt;p&gt;观影最佳：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.《昨日的美食》&lt;/p&gt;
&lt;p&gt;2.《盗梦特工队》&lt;/p&gt;
&lt;p&gt;3.《Live》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;阅读最佳：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.《献给阿尔吉侬的花束》&lt;/p&gt;
&lt;p&gt;2.《海风中失落的血色馈赠》&lt;/p&gt;
&lt;p&gt;3.《网 阿加西自传》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;好物最佳：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.戴森V7&lt;/p&gt;
&lt;p&gt;2.Asics 运动鞋&lt;/p&gt;
&lt;p&gt;3.Airpods Pro&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新的期许&quot;&gt;&lt;a href=&quot;#新的期许&quot; class=&quot;headerlink&quot; title=&quot;新的期许&quot;&gt;&lt;/a&gt;新的期许&lt;/h3&gt;&lt;p&gt;又到了新年 Flag 时间~&lt;/p&gt;
&lt;p&gt;工作学习方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提高英文输出能力，新年用英文写一篇技术博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Leetcode Hit 300&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;补足 &lt;a href=&quot;https://github.com/Colafornia/golang-exercise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Golang 的练习项目&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完成两门 CS 公开课（再学一门语言或者熟悉数据库吧）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生活方面（和去年定的&lt;strong&gt;一模一样&lt;/strong&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;阅读量 35 本+&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;至少去两个没去过的城市玩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;体重减掉 5kg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;培养一个新爱好(这条很虚，但又很必要)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/01/l8kcXq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/chengdu-2019.jpeg&quot; alt=&quot;sunset roller coaster&quot;&gt;&lt;/p&gt;
&lt;p&gt;2019:  to see the world as it is, and &lt;em&gt;to love it&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="summary" scheme="https://blog.colafornia.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>理解 Go 语言中的 Slice</title>
    <link href="https://blog.colafornia.me/post/2019/understand-golang-slice/"/>
    <id>https://blog.colafornia.me/post/2019/understand-golang-slice/</id>
    <published>2019-11-05T01:30:00.000Z</published>
    <updated>2019-11-05T03:31:42.858Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/go-slice.png&quot; alt=&quot;go-slice&quot;&gt;&lt;/p&gt;
&lt;p&gt;数组是面向过程的编程语言里最重要的概念之一。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、翻车现场&quot;&gt;&lt;a href=&quot;#一、翻车现场&quot; class=&quot;headerlink&quot; title=&quot;一、翻车现场&quot;&gt;&lt;/a&gt;一、翻车现场&lt;/h2&gt;&lt;p&gt;在短暂的 Go 语言学习使用中，已经连续两次踩进了下面这个坑&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vals := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vals = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(vals, i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(vals)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Playground: https://play.golang.org/p/7PgUqBdZ6Z&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果是 &lt;code&gt;[0 0 0 0 0 0 1 2 3 4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回顾一下翻车现场：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开始是通过 &lt;code&gt;var vals []int&lt;/code&gt; 来进行变量声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后续逻辑开发完成，自测完成，一切 ok，发布上线，一切 ok&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某天在项目里跑了一下 &lt;code&gt;golangci-lint&lt;/code&gt;，发现了一吨报错，其中有：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Consider preallocating &lt;span class=&quot;string&quot;&gt;`vals`&lt;/span&gt; (prealloc)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vals []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ^&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;遂修改为 &lt;code&gt;vals := make([]int, 5)&lt;/code&gt;，再改完那一吨报错，基本都是关于写法的修正，lint 不再报错，提交发布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线上，Duang💥💥💥（看用在哪里啦。。很有可能也不会💥，只会是一个隐秘的 Bug）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;挺刺激的。第一次遇到这个问题的时候其实已经有个印象不能这么声明 slice，再 append 了，但还是被打的不够疼，又有了第二次。&lt;/p&gt;
&lt;p&gt;所以还是来学习理解一下具体是怎么回事吧。&lt;/p&gt;
&lt;h2 id=&quot;二、Array-vs-Slice&quot;&gt;&lt;a href=&quot;#二、Array-vs-Slice&quot; class=&quot;headerlink&quot; title=&quot;二、Array vs Slice&quot;&gt;&lt;/a&gt;二、Array vs Slice&lt;/h2&gt;&lt;p&gt;Go 语言中有数组 array，也有切片 slice。二者有很多区别，但是本次想讨论的主要是，&lt;strong&gt;array 的大小是固定的且不会改变，其 length 就是其类型的一部分，而 slice 的大小是动态变化的&lt;/strong&gt;，因为 slice 是 array 的 &lt;strong&gt;wrapper&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;aArray := [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Jerry&quot;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, aArray) &lt;span class=&quot;comment&quot;&gt;// Print &quot;[2]string&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以说，声明一个数组：&lt;code&gt;var a [10]int&lt;/code&gt; a 的大小就已经固定，不会改变。调用 &lt;code&gt;len(a)&lt;/code&gt; 的结果永远为 10。如果想要再向数组里添加、删除任何元素，都必须要重新声明一个新的类型。&lt;/p&gt;
&lt;p&gt;这种固定大小的数组设计在某些场景下是非常有用的（官方文档的举例是矩阵变换），但是大多数情况下，工程中还是需要一个可变大小可增删的数组容器。而这就是设计 Slice 的原因。&lt;/p&gt;
&lt;p&gt;切片 Slice 是基于数组实现的，它描述了数组的一个连续片段，所以叫切片还是很生动形象的。切片其实就是动态数组，它的长度并不固定，可以追加元素并会在切片容量不足时进行扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.git-star.com/go-slices-usage-and-internals_slice-struct.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，&lt;code&gt;Slice&lt;/code&gt; 的结构本质上是：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; SliceHeader &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Ptr &lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Len  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Cap  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Ptr 作为一个指针指向数组的第一个元素，其实就是指向一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组其实就是一片连续的内存空间，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量标识。&lt;/p&gt;
&lt;p&gt;Length 是 slice 中所包含的元素个数，而&lt;code&gt;Capacity&lt;/code&gt;则记录了其底层数组的大小（从切片指针引用的元素开始，直到底层数组的最后一个元素）。因此，必然会有 &lt;code&gt;Capacity &amp;gt;= Length&lt;/code&gt; 。试图把切片扩展到超出容量就会和访问超出数组/切片范围的索引一样，导致 panic。&lt;/p&gt;
&lt;p&gt;因此如果我们声明 &lt;code&gt;slice := iBuffer[0:0]&lt;/code&gt;，其 header 则为：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;slice := SliceHeader&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Len:  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Cap:  &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Ptr: &amp;amp;iBuffer[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;引入 slice header 的这个概念非常有助于理解 slice 的特点和一些坑。&lt;/p&gt;
&lt;p&gt;再来看看几种声明 slice 的方式：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 字面量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;letters := []&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// make&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;([]T, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;cap&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;s&lt;/span&gt; := &lt;span class=&quot;title&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;([]&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;, 5)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &lt;span class=&quot;title&quot;&gt;re&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;slice&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;s&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;s&lt;/span&gt;[2:4]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三种 re-slice 方式并没有拷贝原 slice 中的数据，它只是创建了一个新的切片，并将其指针指向同一个底层数组。&lt;/p&gt;
&lt;p&gt;如果更改了 slice 中某些元素的值，实际上是在改变 slice 所指向的数组元素的值。因此，在下面这种通过 re-slice 生成了子切片，又通过索引修改元素值的行为，会导致所有指向这个底层数组的 slice 的值都发生改变。&lt;strong&gt;即 Slice 的结构会导致多个 slice 实际引用的是同一个数组，要谨慎修改 slice 中元素的值&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;foo = &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 被初始化为 [0 0 0 0 0]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bar  := foo[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bar[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(foo) &lt;span class=&quot;comment&quot;&gt;// [0 0 99 42 100]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(bar) &lt;span class=&quot;comment&quot;&gt;// [0 99 42]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;修改-Slice-中元素的值与-header&quot;&gt;&lt;a href=&quot;#修改-Slice-中元素的值与-header&quot; class=&quot;headerlink&quot; title=&quot;修改 Slice 中元素的值与 header&quot;&gt;&lt;/a&gt;修改 Slice 中元素的值与 header&lt;/h2&gt;&lt;p&gt;修改这两者的方法并不一样。&lt;/p&gt;
&lt;h3 id=&quot;Example1-将-slice-作为参数传入函数，修改-slice-中元素的值&quot;&gt;&lt;a href=&quot;#Example1-将-slice-作为参数传入函数，修改-slice-中元素的值&quot; class=&quot;headerlink&quot; title=&quot;Example1:  将 slice 作为参数传入函数，修改 slice 中元素的值&quot;&gt;&lt;/a&gt;Example1:  将 slice 作为参数传入函数，修改 slice 中元素的值&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AddOneToEachElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(slice [])&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; slice &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        slice[i]++&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    slice := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;before&quot;&lt;/span&gt;, slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    AddOneToEachElement(slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;after&quot;&lt;/span&gt;, slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// before [0 0 0 0 0]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// after [1 1 1 1 1]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改成功。虽然作为函数参数所传递的只是 slice 的值，但是其实在函数中我们所操作修改的是指向同一底层数组的 &lt;code&gt;newSlice&lt;/code&gt;，底层数组的元素被修改，因此当函数执行完毕，修改后的元素值可由原 slice 访问到。&lt;/p&gt;
&lt;h3 id=&quot;Example2-将-slice-作为参数传入函数，修改-slice-的长度&quot;&gt;&lt;a href=&quot;#Example2-将-slice-作为参数传入函数，修改-slice-的长度&quot; class=&quot;headerlink&quot; title=&quot;Example2:  将 slice 作为参数传入函数，修改 slice 的长度&quot;&gt;&lt;/a&gt;Example2:  将 slice 作为参数传入函数，修改 slice 的长度&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubtractOneFromLength&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(slice []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    slice = slice[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; slice&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    slice := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Before: len(slice) =&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newSlice := SubtractOneFromLength(slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;After:  len(slice) =&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;After:  len(newSlice) =&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(newSlice))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Before: len(slice) = 5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// After:  len(slice) = 5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// After:  len(newSlice) = 4&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;储存在 slice header 中的 length 属性并不会被函数修改，传入函数的只是其拷贝。 如果我们想通过一个函数来修改 slice  的 header 的话，必须通过把修改过的返回结果重新赋值给待修改的 slice。&lt;/p&gt;
&lt;h3 id=&quot;Example3-将-slice-的指针作为参数传入函数，修改其-header&quot;&gt;&lt;a href=&quot;#Example3-将-slice-的指针作为参数传入函数，修改其-header&quot; class=&quot;headerlink&quot; title=&quot;Example3:  将 slice 的指针作为参数传入函数，修改其 header&quot;&gt;&lt;/a&gt;Example3:  将 slice 的指针作为参数传入函数，修改其 header&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PtrSubtractOneFromLength&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(slicePtr *[]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	slice := *slicePtr&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	*slicePtr = slice[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	slice := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Before: len(slice) =&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	PtrSubtractOneFromLength(&amp;amp;slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;After:  len(slice) =&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Before: len(slice) = 5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// After:  len(slice) = 4&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;三、Append&quot;&gt;&lt;a href=&quot;#三、Append&quot; class=&quot;headerlink&quot; title=&quot;三、Append&quot;&gt;&lt;/a&gt;三、Append&lt;/h2&gt;&lt;p&gt;内置的 &lt;code&gt;append&lt;/code&gt;方法有这几个功能特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 slice 附加一个或多个元素&lt;/li&gt;
&lt;li&gt;分配足够大的 slice （如果 append 后的长度超出了现有的容量）&lt;/li&gt;
&lt;li&gt;总会成功，除非机器内存耗光&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这是官方实现的用来说明功能特性的版本，并不是源码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Append appends the elements to the slice.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Efficient version.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Append&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(slice []&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, elements ...&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    n := &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    total := &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(slice) + &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(elements)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; total &amp;gt; &lt;span class=&quot;built_in&quot;&gt;cap&lt;/span&gt;(slice) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Reallocate. Grow to 1.5 times the new size, so we can still grow.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 一次分配更多的内存通常都比多次分配少量内存的开销更小且速度更快&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        newSize := total*&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        newSlice := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, total, newSize)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;copy&lt;/span&gt;(newSlice, slice)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        slice = newSlice&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    slice = slice[:total]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;copy&lt;/span&gt;(slice[n:], elements)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; slice&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;四、回顾一下翻车现场&quot;&gt;&lt;a href=&quot;#四、回顾一下翻车现场&quot; class=&quot;headerlink&quot; title=&quot;四、回顾一下翻车现场&quot;&gt;&lt;/a&gt;四、回顾一下翻车现场&lt;/h2&gt;&lt;p&gt;回到我们一开始演示翻车现场的代码示例：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vals := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vals = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(vals, i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(vals)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在声明 &lt;code&gt;vals&lt;/code&gt; 的时候，把它的 &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;capacity&lt;/code&gt;都设置为5，它被初始化为空值 slice : &lt;code&gt;[0 0 0 0 0]&lt;/code&gt;，再进行 append 操作，它假设我们是想在初始的 5 个元素后添加新元素，因此得到的结果是 &lt;code&gt;[0 0 0 0 0 0 1 2 3 4]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那在 golang-lint 要求我们必须通过 &lt;code&gt;prealloc&lt;/code&gt; 的方式初始化 vals，或是我们为了避免每个循环中都 re-allocate 造成的过大开销，或是我们并不能确定执行&lt;code&gt;append&lt;/code&gt; 后的切片大小的情况下，要怎么避免这种翻车情况呢？&lt;/p&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;h3 id=&quot;1-直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）&quot;&gt;&lt;a href=&quot;#1-直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）&quot; class=&quot;headerlink&quot; title=&quot;1. 直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）&quot;&gt;&lt;/a&gt;1. 直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vals := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vals[i] = i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(vals)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方案并不难理解。&lt;/p&gt;
&lt;h3 id=&quot;2-设置长度为-0，指定切片的-Capacity&quot;&gt;&lt;a href=&quot;#2-设置长度为-0，指定切片的-Capacity&quot; class=&quot;headerlink&quot; title=&quot;2. 设置长度为 0，指定切片的 Capacity&quot;&gt;&lt;/a&gt;2. 设置长度为 &lt;code&gt;0&lt;/code&gt;，指定切片的 Capacity&lt;/h3&gt;&lt;p&gt;并不是所有场景下我们都可以精确一一对应到每个索引下该存储的元素是什么，比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vals := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  items := getItems(i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vals = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(vals, items...)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(vals)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每次将一个不定长度的 slice 铺平追加到切片，最终得到的切片的长度无法提前确定。&lt;/p&gt;
&lt;p&gt;那只能通过设置长度为 &lt;code&gt;0&lt;/code&gt;，指定切片的容量来解决了。即：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vals := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  items := getItems(i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vals = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(vals, items...)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fmt.Println(vals)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然我们初始化时指定的容量5很有可能比最终切片长度小，循环过程中还是会发生 re-allocate，但这样已经避免了前面的翻车现场，也减少了 re-allocate 次数，可以作为这种场景下的折中解决方案了。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.golang.org/slices&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Arrays, slices (and strings): The mechanics of ‘append’&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.golang.org/go-slices-usage-and-internals&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go Slices: usage and internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.calhoun.io/how-to-use-slice-capacity-and-length-in-go/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to use slice capacity and length in Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/go-slice.png&quot; alt=&quot;go-slice&quot;&gt;&lt;/p&gt;
&lt;p&gt;数组是面向过程的编程语言里最重要的概念之一。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://blog.colafornia.me/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Cypress 拯救业务项目的前端自动化测试</title>
    <link href="https://blog.colafornia.me/post/2019/e2e-test-cypress/"/>
    <id>https://blog.colafornia.me/post/2019/e2e-test-cypress/</id>
    <published>2019-10-24T02:00:00.000Z</published>
    <updated>2019-10-25T03:13:12.557Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/cypress.png&quot; alt=&quot;cypress-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于前端测试的一些理论与基于 &lt;code&gt;Cypress&lt;/code&gt; 的 E2E 测试具体实践。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;关于前端自动化测试的一些碎碎念&quot;&gt;&lt;a href=&quot;#关于前端自动化测试的一些碎碎念&quot; class=&quot;headerlink&quot; title=&quot;关于前端自动化测试的一些碎碎念&quot;&gt;&lt;/a&gt;关于前端自动化测试的一些碎碎念&lt;/h2&gt;&lt;p&gt;日常业务项目开发的痛点之一便是前端的&lt;code&gt;回归测试&lt;/code&gt;，免不了各种手动点点点，但凡改动了某个公用组件，函数，都要漫山遍野地把项目的主要页面都点进去看一遍有没有问题。项目用了 &lt;code&gt;GraphQL&lt;/code&gt; 的话，Schema 一个更新不及时，某个没注意到的页面就挂了，然后就等着开 issue 或者报线上 Bug 吧 😐&lt;/p&gt;
&lt;p&gt;通过人工手动点点点不仅是累，也并不靠谱，没法保证每一次都测到了需要回归测试的功能。想解决这一痛点，就不得不提&lt;code&gt;前端的自动化测试&lt;/code&gt;。通过命令行跑测试，集成 CI 自动测试岂不美滋滋。&lt;/p&gt;
&lt;p&gt;然而，国内各厂对于前端自动化测试尚未形成很好的实践，说起自动化测试，大家想到的也还是后端测试。几次技术大会（JSConf、GMTC 等等）里关于前端测试的话题也是寥寥无几，有的话也是国外前端工程师的分享，或是 QA 关于搭建测试平台的分享。&lt;/p&gt;
&lt;p&gt;在我的经验里，&lt;strong&gt;对于业务项目而言的前端测试&lt;/strong&gt;都很“尴尬”。如果是开发工具库，那可以通过单元测试来保证质量，如果是开发 UI 组件库，可以通过 &lt;a href=&quot;https://storybook.js.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Storybook&lt;/a&gt; 来进行视觉与快照测试。所以之前每每想到业务项目如何集成自动化测试都感觉无从下手（还有几次是被比业务代码还多的测试代码吓跑了）。&lt;/p&gt;
&lt;p&gt;但是业务项目里并没有太多工具函数需要单元测试（大部分通过 lodash 或其他第三方库来解决复杂逻辑处理），UI 组件也基本是直接采用了业界比较成熟的 ant-mobile, ant-design 等方案，需要在业务项目中开发的 UI 组件并不多，大多数是在第三方的 UI 组件基础上结合业务逻辑进行二次封装（事实上 ant-design 也把自己的组件单独放到 &lt;a href=&quot;https://github.com/react-component&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/react-component&lt;/a&gt; 里维护了）。&lt;/p&gt;
&lt;p&gt;业务项目里需要自动化测试的场景主要是想覆盖用户的主要使用路径，例如登录注册，加购到购物车，查看操作订单，修改个人信息等等，都是与 UI 界面的渲染逻辑强相关的，需要测试这些页面的表单提交，自动跳转，数据渲染是否有异常。&lt;/p&gt;
&lt;p&gt;所以在此可以梳理一下我们的需求是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;可以模拟用户的点击输入操作，事件驱动来验证页面渲染是否符合预期&lt;/li&gt;
&lt;li&gt;可以使用命令行跑测试，可以集成到 CI&lt;/li&gt;
&lt;li&gt;轻量高效，环境易搭建，测试代码易编写（毕竟是作为对敏捷开发，持续集成的环节补充，并不是 QA 环节的测试，不应舍本逐末）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;想到这里不难发现，前端业务项目里最需要的是 E2E 测试，但是在如题图的测试金字塔所示，E2E 测试在金字塔顶端，执行 E2E 测试成本高又速度慢。因此 &lt;a href=&quot;https://github.com/cypress-io/cypress&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cypress&lt;/a&gt; 应运而生，Cypress 提供了完备的解决方案，从测试金字塔顶端的 E2E 到集成测试再到单元测试都实现。&lt;/p&gt;
&lt;h2 id=&quot;Cypress&quot;&gt;&lt;a href=&quot;#Cypress&quot; class=&quot;headerlink&quot; title=&quot;Cypress&quot;&gt;&lt;/a&gt;Cypress&lt;/h2&gt;&lt;p&gt;Cypress 是在 Mocha API 的基础上开发的一套开箱即用的 E2E 测试框架，并不依赖前端框架，也无需其他测试工具库，配置简单，并且提供了强大的 GUI 图形工具，可以自动截图录屏，实现时空旅行并在测试流程中 Debug 等等。&lt;/p&gt;
&lt;p&gt;总结一下，Cypress 的优点有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;配置简单，可快速集成到现有项目中&lt;/li&gt;
&lt;li&gt;支持所有等级的测试（即前面所提到的 e2e 测试，集成测试，单元测试等）&lt;/li&gt;
&lt;li&gt;可以给每一步测试都生成快照，易于 Debug&lt;/li&gt;
&lt;li&gt;可以获取、操作 Web 页面里的所有 DOM 节点&lt;/li&gt;
&lt;li&gt;自动重试功能，Cypress 会在当前节点重试几次再断定测试失败&lt;/li&gt;
&lt;li&gt;易于集成到 CI 系统中&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;与其它类似测试工具如 Selenium、Puppeteer、Nightwatch 相比，Cypress 的测试代码语法更简单，并且在保证了框架的轻量高效的前提下，对前端工程师更友好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007X8olVly1g89haxufrqj317k0u0dwx.jpg&quot; alt=&quot;cypress-gui&quot;&gt;&lt;/p&gt;
&lt;video autoplay loop src=&quot;https://www.cypress.io/static/running-tests-a75997cdc1013fc4b1705c1be3a094c7.webm&quot;&gt;&lt;/video&gt;

&lt;p&gt;简单介绍一下使用方法（具体可以参照&lt;a href=&quot;https://docs.cypress.io/guides/overview/why-cypress.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网引导&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yarn add cypress --dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;添加到项目的 npm 脚本中：&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;scripts&quot;&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;cypress:open&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;cypress open&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根目录里配置 &lt;code&gt;cypress.json&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;baseUrl&quot;: &quot;http://localhost:8080&quot;, // 本地启动的 webpack-dev-server 地址&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;viewportHeight&quot;: 800, // 测试环境的页面视口高度&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &quot;viewportWidth&quot;: 1280 // 测试环境的页面视口宽度&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm run cypress:open&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就已经在本地打开了测试 GUI，可以进行测试了。&lt;/p&gt;
&lt;p&gt;用官方文档的一个例子说明一下测试代码怎么写：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;describe(&lt;span class=&quot;string&quot;&gt;&#39;My First Test&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  it(&lt;span class=&quot;string&quot;&gt;&#39;Gets, types and asserts&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.visit(&lt;span class=&quot;string&quot;&gt;&#39;https://example.cypress.io&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.contains(&lt;span class=&quot;string&quot;&gt;&#39;type&#39;&lt;/span&gt;).click()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Should be on a new URL which includes &#39;/commands/actions&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.url().should(&lt;span class=&quot;string&quot;&gt;&#39;include&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/commands/actions&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Get an input, type into it and verify that the value has been updated&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.get(&lt;span class=&quot;string&quot;&gt;&#39;.action-email&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      .type(&lt;span class=&quot;string&quot;&gt;&#39;fake@email.com&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      .should(&lt;span class=&quot;string&quot;&gt;&#39;have.value&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;fake@email.com&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;video autoplay loop src=&quot;https://docs.cypress.io/img/snippets/first-test-assertions-30fps.1fbd2a2d.mp4&quot;&gt;&lt;/video&gt;

&lt;p&gt;这其实已经测试了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开目标页面，这里是示例的 &lt;a href=&quot;https://example.cypress.io，&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://example.cypress.io，&lt;/a&gt; 实际上在项目里应是本地启动的 server 页面如 &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;找到页面的 dom 里文字内容为 ‘type’ 的按钮，点击（如果页面里并没有渲染这个按钮即测试没跑通）&lt;/li&gt;
&lt;li&gt;按钮点击后，页面应跳转到了路由中包含 ‘/commands/actions’ 的页面&lt;/li&gt;
&lt;li&gt;在此页面的 dom 里可以找到 class 类名为 ‘.action-email’ 的 input 框，在里面输入 ‘fake@email.com’ 后，输入框的 value 值应该为 ‘fake@email.com’&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试代码语义化比较好，代码量不多，也不需要写很多 async 逻辑。&lt;/p&gt;
&lt;p&gt;到这里为止体验了一下安装配置，本地测试，感觉还可以，功能丰富，上手比较简单，集成到项目里也不麻烦。&lt;/p&gt;
&lt;h2 id=&quot;测试覆盖率与持续集成（Gitlab-为例）&quot;&gt;&lt;a href=&quot;#测试覆盖率与持续集成（Gitlab-为例）&quot; class=&quot;headerlink&quot; title=&quot;测试覆盖率与持续集成（Gitlab 为例）&quot;&gt;&lt;/a&gt;测试覆盖率与持续集成（Gitlab 为例）&lt;/h2&gt;&lt;p&gt;凡是没有集成到 CI 里的测试都只是玩具，并不能算数。所以我们来看看 Cypress 这块的表现吧。&lt;/p&gt;
&lt;p&gt;我们希望 Cypress 可以通过配置，在开发的不同阶段执行不同的测试命令。比如在发起 PR 到 feature 分支时可以在当前分支执行集成测试，到 master 主分支时还需计算测试覆盖率并将数据上报到 Sonar 等质检平台（还可以设置测试覆盖率不满足xx%的话则测试失败等等）。&lt;/p&gt;
&lt;p&gt;因此我们先看看测试覆盖率要怎么计算。Cypress 的测试覆盖率计算貌似是后来才添加上的功能，配置稍有点复杂。&lt;/p&gt;
&lt;p&gt;依然还是具体说明可以&lt;a href=&quot;https://docs.cypress.io/guides/tooling/code-coverage.html#E2E-code-coverage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参照文档&lt;/a&gt;，博客中只是简单介绍一下：&lt;/p&gt;
&lt;p&gt;首先安装依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install -D @cypress/code-coverage nyc istanbul-lib-coverage&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再配置一下 Cypress 中的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// cypress/support/index.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;@cypress/code-coverage/support&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// cypress/plugins/index.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = (on, config) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  on(&lt;span class=&quot;string&quot;&gt;&#39;task&#39;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;@cypress/code-coverage/task&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;文档只介绍到这里，如果项目用了 TypeScript 的话这就还远远不够，翻了一下官方的 github 示例才发现还需要几个步骤：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm i -D babel-plugin-istanbul&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一下 &lt;code&gt;.babelrc&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;istanbul&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再修改一下 &lt;code&gt;cypress/plugins/index.js&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// cypress/plugins/index.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = (on, config) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  on(&lt;span class=&quot;string&quot;&gt;&#39;task&#39;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;@cypress/code-coverage/task&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  on(&lt;span class=&quot;string&quot;&gt;&#39;file:preprocessor&#39;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;@cypress/code-coverage/use-babelrc&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&quot;cy:run&quot;: &quot;cypress run &amp;amp;&amp;amp; npm run test:report&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&quot;instrument&quot;: &quot;nyc instrument --compact=false client instrumented&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&quot;test:report&quot;: &quot;npm run instrument &amp;amp;&amp;amp; npx nyc report --reporter=text-summary&quot;,&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过 &lt;code&gt;cypress run&lt;/code&gt; 可以直接在命令行跑测试，不启动 GUI，在 CI 里使用的话就该用这个命令。&lt;/p&gt;
&lt;p&gt;看看结果，真是快快乐乐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007X8olVly1g89hawy7ymj30gn034glt.jpg&quot; alt=&quot;coverage-result&quot;&gt;&lt;/p&gt;
&lt;p&gt;Cypress 的 E2E 测试的覆盖率也可以和单元测试，或是通过其它框架 Jest 等的测试覆盖率进行合并，具体方法可以去官网查找。&lt;/p&gt;
&lt;p&gt;下面我们来以 Gitlab CI runner 为例来看一下 Cypress 怎么集成到 CI：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// .gitlab-ci.yml&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;variables:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  npm_config_cache:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$CI_PROJECT_DIR/.npm&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  CYPRESS_CACHE_FOLDER:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$CI_PROJECT_DIR/cache/Cypress&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;stages:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; test&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; sonar&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;cache:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  paths:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; .npm&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; node_modules/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; cache/Cypress&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;build:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  stage:&lt;/span&gt; sonar&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  tags:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; docker&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  script:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; yarn&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; sh ci/sonar.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; yarn build&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  artifacts:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    expire_in:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; day&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    paths:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;      -&lt;/span&gt; codeclimate.json&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;      -&lt;/span&gt; build&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;cypress-e2e-local:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  image:&lt;/span&gt; cypress/base:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  tags:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; docker&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  stage:&lt;/span&gt; test&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  script:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; unset NODE_OPTIONS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; yarn&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; $(npm bin)/cypress cache path&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# show all installed versions of Cypress binary&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; $(npm bin)/cypress install&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; $(npm bin)/cypress cache list&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; $(npm bin)/cypress verify&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; npm run test&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  artifacts:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    expire_in:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; week&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    when:&lt;/span&gt; always&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    paths:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; coverage/lcov.info&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; cypress/screenshots&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;    -&lt;/span&gt; cypress/videos&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里我们设置了两个 CI 阶段，test 与 build(与 Sonar 扫描，数据上报等)，在 test 阶段中使用了 Cypress 的官方镜像 &lt;code&gt;cypress/base:10&lt;/code&gt;。（其它环境变量设置和依赖如 Sonar 扫描，yarn 等都在我们自己的 Docker 镜像中）&lt;/p&gt;
&lt;p&gt;其中 CI 所执行的命令 &lt;code&gt;npm run test&lt;/code&gt; 是：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&quot;test&quot;: &quot;start-server-and-test start http://localhost:5000 cy:run&quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里为了简化命令，使用了 npm 包 &lt;a href=&quot;https://github.com/bahmutov/start-server-and-test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;start-server-and-test&lt;/a&gt; 来实现待本地 Server 启动之后再执行测试这一逻辑。&lt;/p&gt;
&lt;p&gt;我们也在 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 中设置了 &lt;code&gt;artifacts&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;artifacts:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  expire_in:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; week&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  when:&lt;/span&gt; always&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  paths:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; coverage/lcov.info&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; cypress/screenshots&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;  -&lt;/span&gt; cypress/videos&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是 Gitlab 的 &lt;a href=&quot;https://docs.gitlab.com/ee/user/project/pipelines/job_artifacts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;job artifacts&lt;/a&gt; 功能，可以设置在某一步骤完成之后将特定文件夹的内容上传到服务器，在有效时间内，我们可以在网页端查看或下载这些文件内容。这样如果在 CI 测试失败的话我们就可以在 artifacts 中查看其测试失败视频和快照，避免盲猜式 Debug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007X8olVly1g89hawui46j307o03ldfu.jpg&quot; alt=&quot;artifacts&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 CI 设置和测试用例管理中可以深挖的点还有很多。比如将测试用例分为冒烟测试，全量测试，或者 Client 端测试，Node 层测试等等。&lt;/p&gt;
&lt;p&gt;Cypress 可应用的测试场景也更多，比如通过设置 Cookie 实现不同权限用户的测试，引入 Chance.js 实现随机点击 Tab 进行不同选项卡的测试，Mock 接口返回值等等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://glebbahmutov.com/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://glebbahmutov.com/blog/&lt;/a&gt; 是 Cypress 的主要维护者的博客，其中也记录了很多骚操作（比如检查网页对比度是否满足条件等等），如有兴趣，可以继续进行挖掘。&lt;/p&gt;
&lt;h2 id=&quot;一个坑点&quot;&gt;&lt;a href=&quot;#一个坑点&quot; class=&quot;headerlink&quot; title=&quot;一个坑点&quot;&gt;&lt;/a&gt;一个坑点&lt;/h2&gt;&lt;p&gt;在我的实践中发现的一个坑点是 &lt;a href=&quot;https://github.com/cypress-io/cypress/issues/95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cypress 缺少对于 &lt;code&gt;fetch&lt;/code&gt; 请求的支持&lt;/a&gt;，它无法捕捉或者 mock 请求，只能通过一个有点脏的方法来 hack 解决。&lt;/p&gt;
&lt;p&gt;在项目中引入&lt;a href=&quot;https://github.com/whatwg/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;whatwg-fetch&lt;/a&gt;，再修改 &lt;code&gt;cypress/support/command.js&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// cypress/support/command.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Cypress.Commands.add(&lt;span class=&quot;string&quot;&gt;&#39;visitWithDelWinFetch&#39;&lt;/span&gt;, (path, opts = &amp;#123;&amp;#125;) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.visit(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        path,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.assign(opts, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            onBeforeLoad(win) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; win.fetch;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就可以测试我们项目的登录重定向判断了：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;describe(&lt;span class=&quot;string&quot;&gt;&#39;Node server&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  it(&lt;span class=&quot;string&quot;&gt;&#39;no cookie get 401&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.server()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.clearCookies()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.route(&lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;**/graphql&#39;&lt;/span&gt;).as(&lt;span class=&quot;string&quot;&gt;&#39;login&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.visitWithDelWinFetch(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.wait(&lt;span class=&quot;string&quot;&gt;&#39;@login&#39;&lt;/span&gt;).then((xhr) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      expect(xhr.status).to.eq(&lt;span class=&quot;number&quot;&gt;401&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  it(&lt;span class=&quot;string&quot;&gt;&#39;with cookie get 200&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.server()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.route(&lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;**/graphql&#39;&lt;/span&gt;).as(&lt;span class=&quot;string&quot;&gt;&#39;loginWithCookie&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.visitWithCookie(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.wait(&lt;span class=&quot;string&quot;&gt;&#39;@loginWithCookie&#39;&lt;/span&gt;).then((xhr) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      expect(xhr.status).to.eq(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// login successfully, so display the content&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.get(&lt;span class=&quot;string&quot;&gt;&#39;.ant-layout-sider&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cy.get(&lt;span class=&quot;string&quot;&gt;&#39;.ant-layout-content&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;aha~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007X8olVly1g89hawob9rj31180560ta.jpg&quot; alt=&quot;sonar&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/cypress.png&quot; alt=&quot;cypress-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于前端测试的一些理论与基于 &lt;code&gt;Cypress&lt;/code&gt; 的 E2E 测试具体实践。&lt;/p&gt;
    
    </summary>
    
      <category term="test" scheme="https://blog.colafornia.me/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>2019.3 Webpack 升级改造小记</title>
    <link href="https://blog.colafornia.me/post/2019/2019-webpack-optimization/"/>
    <id>https://blog.colafornia.me/post/2019/2019-webpack-optimization/</id>
    <published>2019-03-31T06:00:00.000Z</published>
    <updated>2019-10-24T02:43:40.140Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2019-3-webpack.png&quot; alt=&quot;webpack-cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间：2019.3&lt;/p&gt;
&lt;p&gt;Webpack 稳定版本为4, 正在 5 的 roadmap 中&lt;/p&gt;
&lt;p&gt;记录一下当前时间对前端项目构建打包优化的策略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;当前项目问题&quot;&gt;&lt;a href=&quot;#当前项目问题&quot; class=&quot;headerlink&quot; title=&quot;当前项目问题&quot;&gt;&lt;/a&gt;当前项目问题&lt;/h2&gt;&lt;p&gt;我们的前端项目基本都是使用的是 &lt;a href=&quot;https://github.com/facebook/create-react-app&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;create-react-app&lt;/a&gt; 的配置，冗余项太多，升级难。&lt;/p&gt;
&lt;p&gt;在这个前提下，有个“极限项目”每次代码改动之后的 hot reload 都需要 30s，实在坐不住了，就动手做了打包升级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dq29.png&quot; alt=&quot;before&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次是从代码依赖相对简单，后续测试回滚负担小的后台管理系统下手的。&lt;/p&gt;
&lt;p&gt;总结下当前的痛点为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目启动慢&lt;/li&gt;
&lt;li&gt;Hot reload 慢&lt;/li&gt;
&lt;li&gt;Build 慢（上线前在后端项目里 build 时尤其明显）&lt;/li&gt;
&lt;li&gt;没分包，文件体积太大&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;解决手段&quot;&gt;&lt;a href=&quot;#解决手段&quot; class=&quot;headerlink&quot; title=&quot;解决手段&quot;&gt;&lt;/a&gt;解决手段&lt;/h2&gt;&lt;p&gt;首先把 Webpack 版本从 3 升到 4，起码先享受上工具本身升级后带来的优越性&lt;/p&gt;
&lt;h3 id=&quot;1-分离配置文件（与性能无关，与开发维护体验有关）&quot;&gt;&lt;a href=&quot;#1-分离配置文件（与性能无关，与开发维护体验有关）&quot; class=&quot;headerlink&quot; title=&quot;1.分离配置文件（与性能无关，与开发维护体验有关）&quot;&gt;&lt;/a&gt;1.分离配置文件（与性能无关，与开发维护体验有关）&lt;/h3&gt;&lt;p&gt;分成 base、dev、prod 三个 config 文件&lt;/p&gt;
&lt;p&gt;把通用配置放到 base 中，dev 与 prod 中只放与这两种模式强相关的配置&lt;/p&gt;
&lt;h3 id=&quot;2-HappyPack&quot;&gt;&lt;a href=&quot;#2-HappyPack&quot; class=&quot;headerlink&quot; title=&quot;2.HappyPack&quot;&gt;&lt;/a&gt;2.HappyPack&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1db8J.png&quot; alt=&quot;HappyPack&quot;&gt;&lt;/p&gt;
&lt;p&gt;治疗各种编译慢&lt;/p&gt;
&lt;p&gt;本地启动 server 编译时间： 30s =&amp;gt; 10s&lt;/p&gt;
&lt;h3 id=&quot;3-splitChunks-分包&quot;&gt;&lt;a href=&quot;#3-splitChunks-分包&quot; class=&quot;headerlink&quot; title=&quot;3.splitChunks 分包&quot;&gt;&lt;/a&gt;3.splitChunks 分包&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dXK1.png&quot; alt=&quot;splitChunks&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一功能在之前版本中是通过 &lt;a href=&quot;https://webpack.js.org/plugins/commons-chunk-plugin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CommonsChunkPlugin&lt;/a&gt; 来进行的。&lt;/p&gt;
&lt;p&gt;初步分成三个包，减小 main 包体积。&lt;/p&gt;
&lt;p&gt;根据业务特点，其实可以做懒加载，但是注意不能分太多，增加 http 请求数得不偿失。后台管理项目体积目前不大，各模块也没什么业务上的明显区分，就没啥做懒加载的必要。&lt;/p&gt;
&lt;p&gt;结果：包体积：6M =&amp;gt; 3M&lt;/p&gt;
&lt;h3 id=&quot;4-将第三方巨型包打入-externals&quot;&gt;&lt;a href=&quot;#4-将第三方巨型包打入-externals&quot; class=&quot;headerlink&quot; title=&quot;4.将第三方巨型包打入 externals&quot;&gt;&lt;/a&gt;4.将第三方巨型包打入 externals&lt;/h3&gt;&lt;p&gt;经过以上分包后，用 &lt;a href=&quot;https://github.com/webpack-contrib/webpack-bundle-analyzer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BundleAnalyzerPlugin&lt;/a&gt; 看了下结果&lt;/p&gt;
&lt;p&gt;发现有个非常显眼的巨型包 &lt;code&gt;echarts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把它的 min.js 扔到公司 cdn 上，在 html 中直接引入：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;externals: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  echarts: &lt;span class=&quot;string&quot;&gt;&#39;echarts&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果也很明显，当时没截图，就不贴对比图了&lt;/p&gt;
&lt;h3 id=&quot;5-gzip&quot;&gt;&lt;a href=&quot;#5-gzip&quot; class=&quot;headerlink&quot; title=&quot;5.gzip&quot;&gt;&lt;/a&gt;5.gzip&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dLvR.png&quot; alt=&quot;after&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过引入 CompressionWebpackPlugin 插件，打出来 .js.gz 资源，在服务器已支持 gzip 的情况下，所加载资源体积（直接到了 1.3M）和时间提升非常明显&lt;/p&gt;
&lt;h3 id=&quot;6-常规操作&quot;&gt;&lt;a href=&quot;#6-常规操作&quot; class=&quot;headerlink&quot; title=&quot;6.常规操作&quot;&gt;&lt;/a&gt;6.常规操作&lt;/h3&gt;&lt;p&gt;还有很多升到 webpack@4 之后的常规操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MiniCssExtractPlugin&lt;/p&gt;
&lt;p&gt;TerserPlugin&lt;/p&gt;
&lt;p&gt;OptimizeCSSAssetsPlugin&lt;/p&gt;
&lt;p&gt;等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随便搜搜，或者按图索骥去最新版的 create-react-app 源码里看看用了啥就行&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2019-3-webpack.png&quot; alt=&quot;webpack-cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间：2019.3&lt;/p&gt;
&lt;p&gt;Webpack 稳定版本为4, 正在 5 的 roadmap 中&lt;/p&gt;
&lt;p&gt;记录一下当前时间对前端项目构建打包优化的策略&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://blog.colafornia.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>2018 年度总结</title>
    <link href="https://blog.colafornia.me/post/2019/2018-review/"/>
    <id>https://blog.colafornia.me/post/2019/2018-review/</id>
    <published>2019-01-02T04:00:00.000Z</published>
    <updated>2019-10-24T02:44:52.310Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/chengdu-2018.jpeg&quot; alt=&quot;chengdu in 2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;2018: have some fun&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;工作与学习&quot;&gt;&lt;a href=&quot;#工作与学习&quot; class=&quot;headerlink&quot; title=&quot;工作与学习&quot;&gt;&lt;/a&gt;工作与学习&lt;/h3&gt;&lt;p&gt;说来有点打脸，去年的年终总结写完不久，我就申请了内部转岗到成都研发中心，比预计至少早了两三年离京。&lt;/p&gt;
&lt;p&gt;新部门属于公司内为数不多使用 &lt;code&gt;React + Node 中间层&lt;/code&gt;技术栈的团队，对我而言也是很不错的机会，连滚带爬地学习了一波，勉强跟上趟了。下半年开始有机会独自 backup 一个小业务项目，也就对公司当前的微服务架构，构建部署流程，Node 服务的线上运维，问题排查更为熟练了，这是在公司业务中的主要收获。&lt;/p&gt;
&lt;p&gt;从 17 年年底，我开始写一个 side project &lt;a href=&quot;https://github.com/Colafornia/little-robot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「little-robot」&lt;/a&gt;，一开始只是一个为了熟悉 Node 服务端开发部署而写的小脚本，夏天终于有时间给它做了一次升级，搭建了 &lt;code&gt;Koa Server&lt;/code&gt;，封装成 api，基于 &lt;code&gt;Docker&lt;/code&gt; 实现了构建部署与持续集成。最后还厚着脸皮在掘金上推广了一波，目前用户量稳定在 100+，Github Star 60+，对于我而言是个不小的鼓舞。&lt;/p&gt;
&lt;p&gt;在上一个年终总结里立的一个 Flag 是 “&lt;strong&gt;Leetcode 每周一题&lt;/strong&gt;”，万万没想到最后还是完成了(在 18 年的最后两个月里突击完成😂)。&lt;a href=&quot;http://blog.colafornia.me/leetcode-solutions/&quot;&gt;「leetcode-solutions」&lt;/a&gt; 完成了 54 个题目，一边复习数据结构和算法知识一边刷题，题目最多覆盖到动态规划。最大的收获应该是找到了做算法题的快乐(传说中的用算法娱乐身心)，希望把算法学习能够作为一个长期习惯保持下去。&lt;/p&gt;
&lt;p&gt;今年的一个重点学习项目是 &lt;strong&gt;iOS 开发&lt;/strong&gt;，花了蛮多时间学习 &lt;code&gt;Objective-C&lt;/code&gt; 语法，已经可以照着文档画一些简单的交互页面。目前粗浅的感觉 iOS 开发还是很规整，Xcode 功能齐全，在 IDE 里看文档非常舒服。主要是战线拉的太长，这些准备工作都做完之后，有点失去耐心转去做算法题了，还是要有个 deadline 短期集中精力来做更好些。新的一年要把这一块的学习完成，完成一个成品 iOS App。&lt;/p&gt;
&lt;p&gt;博客有 &lt;strong&gt;11 篇&lt;/strong&gt;，翻译方面也还是做了一些，翻译了很多长文，积分足够兑换了一个 GDD 的音响。十一假期完成了&lt;a href=&quot;https://blog.colafornia.me/post/2018/translation-blink-render/&quot;&gt;Blink 演讲视频的翻译&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dZh4.png&quot; width=&quot;450&quot;&gt;&lt;/p&gt;
&lt;p&gt;完全没有进展的内容是 CS 公开课学习，又当了一年的野生程序员，计算机基础方面除了算法几乎没什么进步。&lt;/p&gt;
&lt;h3 id=&quot;生活与玩乐&quot;&gt;&lt;a href=&quot;#生活与玩乐&quot; class=&quot;headerlink&quot; title=&quot;生活与玩乐&quot;&gt;&lt;/a&gt;生活与玩乐&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://imgchr.com/i/V1ducR&quot; alt=&quot;Phuket&quot;&gt;&lt;/p&gt;
&lt;p&gt;下定决心回成都之后，对自己的一个期许是“更好的体验生活”，所以今年的生活娱乐还是很丰富多彩的。&lt;/p&gt;
&lt;h4 id=&quot;旅行&quot;&gt;&lt;a href=&quot;#旅行&quot; class=&quot;headerlink&quot; title=&quot;旅行&quot;&gt;&lt;/a&gt;旅行&lt;/h4&gt;&lt;p&gt;今年四月带我妈去了普吉岛+曼谷玩，上面这张照片便是去斯米兰岛潜水时拍的。普吉岛非常好玩，景色和水质都很不错，消费水平也不高，两个人吃一顿海鲜烧烤最多也才 100RMB 左右，再去夜市买点水果小吃简直美滋滋。每天去便利店买一大袋零食，酸奶，加起来最多不超过 30RMB。去斯米兰潜水的一天也很爽，当时那个季节水面很稳，没有晕船，我在当地租了一个 GoPro5，在水下录的很嗨皮。&lt;/p&gt;
&lt;p&gt;但曼谷的观感就很一般，堵车程度是帝都两倍，购物中心也没有什么实惠or限定的东西可买。好在只在曼谷停留了两天，本着来都来了的态度还是去大皇宫逛了逛，也有了用 Grab 叫车，和司机用蹩脚的英文乱侃的体验。&lt;/p&gt;
&lt;p&gt;总而言之还是一趟很完满的旅行，第一次由我带着妈妈出国玩，她体验了这一波 Airbnb，Grab，全程只管拍照就行，也玩的很开心。决定以后每年都带妈妈出一趟远门✌️。&lt;/p&gt;
&lt;p&gt;除此之外还去了乐山吃了三天，以及甘孜阿坝爬山，成都以及四川周边好玩的地方还是很多，应该趁机多去周边玩玩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dm9J.md.jpg&quot; width=&quot;450&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;健身&quot;&gt;&lt;a href=&quot;#健身&quot; class=&quot;headerlink&quot; title=&quot;健身&quot;&gt;&lt;/a&gt;健身&lt;/h4&gt;&lt;p&gt;回成都之后便考察了一下软件园的健身房，选定一家买了私教课，由教练带着练了三个月，之后便是自己练了。&lt;/p&gt;
&lt;p&gt;成果还是比较满意的，体态纠正了不少，终于能在70%的时间里都站直了，心肺功能也有一定改善，感觉还是全靠健身才保证了来成都后每天胡吃海喝也没胖……&lt;/p&gt;
&lt;p&gt;只是到了冬天之后没再坚持锻炼，有点可惜，健身期间的精神头真的很不一样。&lt;/p&gt;
&lt;h4 id=&quot;Live&quot;&gt;&lt;a href=&quot;#Live&quot; class=&quot;headerlink&quot; title=&quot;Live&quot;&gt;&lt;/a&gt;Live&lt;/h4&gt;&lt;p&gt;总结回来，这一年也听了几场 Live:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The xx -I See You Tour@北京展览馆&lt;/li&gt;
&lt;li&gt;Hello Nico「慢慢，而远」@成都小酒馆&lt;/li&gt;
&lt;li&gt;沼泽乐队「争鸣二十年」@成都小酒馆&lt;/li&gt;
&lt;li&gt;惘闻乐队 「看不见的城市」@成都小酒馆&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章的题图便是沼泽乐队的现场照片。成都这边还是有很多听现场 Live 的机会，票也并不贵，年中工作不忙的时候与朋友去听了几场，散场后去吃冰粉、串串，也是非常美滋滋。&lt;/p&gt;
&lt;h4 id=&quot;观影与阅读&quot;&gt;&lt;a href=&quot;#观影与阅读&quot; class=&quot;headerlink&quot; title=&quot;观影与阅读&quot;&gt;&lt;/a&gt;观影与阅读&lt;/h4&gt;&lt;p&gt;观影量与往年持平，阅片内容也没太大变化，还是商业片为主，独立电影看了一小部分。&lt;/p&gt;
&lt;p&gt;比较欣慰的是今年看了不少书，有 &lt;strong&gt;32 本&lt;/strong&gt;，大概是去年阅读量的两倍。&lt;/p&gt;
&lt;p&gt;其中还是技术书居多，把早些时间买的迟迟没有看完的实体书都 K 掉了，因为焦虑程度比在北京好了不少，也总算有心情看些非技术类的书。&lt;/p&gt;
&lt;h4 id=&quot;年度最佳清单&quot;&gt;&lt;a href=&quot;#年度最佳清单&quot; class=&quot;headerlink&quot; title=&quot;年度最佳清单&quot;&gt;&lt;/a&gt;年度最佳清单&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;观影最佳：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;《西部世界 第二季》&lt;/li&gt;
&lt;li&gt;《横道世之介》&lt;/li&gt;
&lt;li&gt;《Call Me by Your Name》&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;阅读最佳：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;技术类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;《JavaScript 语言精粹》&lt;/li&gt;
&lt;li&gt;《Objective-C 编程（第2版）》&lt;/li&gt;
&lt;li&gt;《深入React技术栈》&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;非技术类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;《十一种孤独》&lt;/li&gt;
&lt;li&gt;《费马大定理》&lt;/li&gt;
&lt;li&gt;《为人文教育辩护》&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;好物最佳：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;除湿机&lt;/li&gt;
&lt;li&gt;Kindle Oasis2&lt;/li&gt;
&lt;li&gt;发热猫窝(有了这个窝之后，家猫几乎没在别的地方睡过觉，使用率100%)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新的期许&quot;&gt;&lt;a href=&quot;#新的期许&quot; class=&quot;headerlink&quot; title=&quot;新的期许&quot;&gt;&lt;/a&gt;新的期许&lt;/h3&gt;&lt;p&gt;又到了新年 Flag 时间~&lt;/p&gt;
&lt;p&gt;工作学习方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拓端，完成一个 iOS 成品 App&lt;/li&gt;
&lt;li&gt;Leetcode 不能停，2019年进度完成到 100 题(目标定得挺低的)&lt;/li&gt;
&lt;li&gt;补足 CS 基础，通过 HIT 的基础课学习&lt;/li&gt;
&lt;li&gt;开源两个完整的 Side Project&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生活方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;阅读量 35 本+&lt;/li&gt;
&lt;li&gt;至少去两个没去过的城市玩&lt;/li&gt;
&lt;li&gt;体重减掉 5kg&lt;/li&gt;
&lt;li&gt;培养一个新爱好(这条很虚，但又很必要)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1dn39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/chengdu-2018.jpeg&quot; alt=&quot;chengdu in 2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;2018: have some fun&lt;/p&gt;
    
    </summary>
    
      <category term="summary" scheme="https://blog.colafornia.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>8102年末，前端路由基本思路</title>
    <link href="https://blog.colafornia.me/post/2018/implement-of-frontend-route/"/>
    <id>https://blog.colafornia.me/post/2018/implement-of-frontend-route/</id>
    <published>2018-11-12T12:00:00.000Z</published>
    <updated>2019-10-24T02:22:04.202Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/router/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近看了一些相关资料，特地来整理一下，当前前端主流路由 &lt;code&gt;react-router&lt;/code&gt;、&lt;code&gt;vue-router&lt;/code&gt; 的实现思路，内容不多也并不复杂，作为知识体系的补全。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;两种模式&quot;&gt;&lt;a href=&quot;#两种模式&quot; class=&quot;headerlink&quot; title=&quot;两种模式&quot;&gt;&lt;/a&gt;两种模式&lt;/h2&gt;&lt;p&gt;此处默认你已经至少使用过主流框架 Router 中的一种，那就肯定知道路由配置时肯定会有个配置项是关于，使用 &lt;code&gt;hash&lt;/code&gt; 模式还是 &lt;code&gt;history&lt;/code&gt; 模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;vue-router 通过给实例传入 &lt;code&gt;mode&lt;/code&gt; 字段来设置&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/router/02.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;react-router 则通过直接使用不同的路由组件进行区分&lt;/div&gt;

&lt;p&gt;这两种模式便是目前我们在浏览器环境中为单页应用实现“&lt;strong&gt;无需重载页面即可更新视图&lt;/strong&gt;”的原理。&lt;/p&gt;
&lt;p&gt;接下来我们分别进行分析。&lt;/p&gt;
&lt;h3 id=&quot;hash-模式&quot;&gt;&lt;a href=&quot;#hash-模式&quot; class=&quot;headerlink&quot; title=&quot;hash 模式&quot;&gt;&lt;/a&gt;hash 模式&lt;/h3&gt;&lt;p&gt;url 中使用了 hash 符号 &lt;code&gt;#&lt;/code&gt; 后的内容便属于 &lt;code&gt;fragment&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/03.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有别于 url 中的 &lt;code&gt;?&lt;/code&gt; 符号，&lt;code&gt;fragment&lt;/code&gt; 设计之初便是为了&lt;code&gt;锚点&lt;/code&gt;这一特性，通过 &lt;code&gt;fragment&lt;/code&gt; 指定网页中的位置，浏览器会匹配到 id 或 name 为 &lt;code&gt;fragment&lt;/code&gt; 值的 a 标签，将其滚动到可视区域的顶部。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;fragment&lt;/code&gt; 还具备以下三个特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改#后的 &lt;code&gt;fragment&lt;/code&gt; 值不会导致页面重新加载，但是会改变浏览器的历史记录&lt;/li&gt;
&lt;li&gt;作为 url 发起 HTTP 请求时，&lt;code&gt;fragment&lt;/code&gt; 部分不会被包含在请求头中，也就不会被发送到服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fragment&lt;/code&gt; 一般不会被搜索引擎收录（虽然 Google 也出了相应对策作为补救，但整体上这种模式对 SEO 依然算不上不友好）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那 hash 模式是如何进行路由的呢？&lt;/p&gt;
&lt;p&gt;通过监听 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchange&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;onhashchange&lt;/a&gt; 事件即可捕获 hash 值的改变然后执行后续的更新视图逻辑（具体实现后面再解释）。&lt;/p&gt;
&lt;h3 id=&quot;history-模式（又名-browser-模式、HTML5-模式）&quot;&gt;&lt;a href=&quot;#history-模式（又名-browser-模式、HTML5-模式）&quot; class=&quot;headerlink&quot; title=&quot;history 模式（又名 browser 模式、HTML5 模式）&quot;&gt;&lt;/a&gt;history 模式（又名 browser 模式、HTML5 模式）&lt;/h3&gt;&lt;p&gt;这一模式的实现基于 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web API 中的 History&lt;/a&gt;，浏览器工具栏的前进与后退实际上也是在操作 &lt;code&gt;History&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;History.pushState()&lt;/code&gt; 与 &lt;code&gt;History.replaceState()&lt;/code&gt; 让我们可以实现路由：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.history.pushState(stateObject, title, URL);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.history.replaceState(stateObject, title, URL);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两者用法类似，&lt;strong&gt;URL 必须为与当前页面属于同域&lt;/strong&gt;。这两个方法执行之后都会使得浏览器地址栏更新，但不跳转，同时 &lt;code&gt;History.state&lt;/code&gt; 对象也将更新为传入的 URL 值，这就为前端路由的实现提供可能。&lt;/p&gt;
&lt;p&gt;每当 &lt;code&gt;History&lt;/code&gt; 对象发生变化，都会触发 &lt;code&gt;popstate&lt;/code&gt; 事件，同理，我们可以通过监听这一事件，在回调中执行路由匹配逻辑。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vue-router&lt;/code&gt; 的源码更为易读，几个版本下来 API 变化也不是很大，此处以 &lt;code&gt;vue-router&lt;/code&gt; 源码作为示例。&lt;/p&gt;
&lt;p&gt;先看&lt;a href=&quot;https://github.com/vuejs/vue-router/tree/dev/src&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;目录结构&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/04.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;components 文件夹中便是涉及到视图更新的 &lt;code&gt;Link&lt;/code&gt; 与 &lt;code&gt;RouterView&lt;/code&gt; 组件，history 文件中涉及到我们刚刚提到的浏览器中两种路由模式。&lt;/p&gt;
&lt;p&gt;先看入口文件&lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/src/index.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/vuejs/vue-router/blob/dev/src/index.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在构造器中进行了 &lt;code&gt;mode&lt;/code&gt; 读取，可以得知 vue-router 默认使用 &lt;code&gt;hash 模式&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/05.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 switch 函数中分别调用各自模式对路由的 history 对象进行加工。随后调用 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/install.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;install.js&lt;/a&gt; 将 vue-router 混入 Vue 实例中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/06.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过全局的 Mixin 对象，在 Vue 实例的 &lt;code&gt;beforeCreate&lt;/code&gt; 钩子函数中将其混入，并将两个组件进行挂载。&lt;/p&gt;
&lt;p&gt;那两个针对不同模式下 histroy 的包装方法呢？&lt;/p&gt;
&lt;p&gt;以 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/history/hash.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hash.js&lt;/a&gt;为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/router/07.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;先是设置了事件监听，然后声明了 go、push、replace 等方法。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;supportsPushState&lt;/code&gt; 是工具方法，通过 &lt;code&gt;window.navigator.userAgent&lt;/code&gt; 读取设备信息判断移动端设备是否支持。&lt;/p&gt;
&lt;p&gt;从 go、push、replace 等方法的实现可以看出，基本都是通过在history 基础上改写的 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/util/push-state.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pushState&lt;/a&gt; 方法实现的。&lt;/p&gt;
&lt;p&gt;hash.js 还有一些针对 hash 模式特有的方法如 &lt;code&gt;ensureSlash()&lt;/code&gt;，其余实现思路基本与 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/701d02b810da200b9ee7bac757d62b628327c6dd/src/history/html5.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;html5.js&lt;/a&gt; 相同。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;&lt;a href=&quot;#最后&quot; class=&quot;headerlink&quot; title=&quot;最后&quot;&gt;&lt;/a&gt;最后&lt;/h2&gt;&lt;p&gt;所以在不借助框架的情况下如何实现一个极简版的前端路由也不是什么难题了，&lt;a href=&quot;https://github.com/Colafornia/Wheels/blob/master/Router/index.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wheels/Router&lt;/a&gt; 轻松写两种~&lt;/p&gt;
&lt;p&gt;关于实际工程中使用的路由其实还有很多边界情况需要处理，&lt;code&gt;react-router&lt;/code&gt; 与 &lt;code&gt;vue-router&lt;/code&gt; 结合各自框架实例与上下文，实现了非常简洁高效的路由机制，推荐大家阅读源码好好挖掘一下。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/router/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近看了一些相关资料，特地来整理一下，当前前端主流路由 &lt;code&gt;react-router&lt;/code&gt;、&lt;code&gt;vue-router&lt;/code&gt; 的实现思路，内容不多也并不复杂，作为知识体系的补全。&lt;/p&gt;
    
    </summary>
    
      <category term="route javascript" scheme="https://blog.colafornia.me/categories/route-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Blink 渲染： 重建引擎</title>
    <link href="https://blog.colafornia.me/post/2018/translation-blink-render/"/>
    <id>https://blog.colafornia.me/post/2018/translation-blink-render/</id>
    <published>2018-10-07T11:30:00.000Z</published>
    <updated>2019-10-24T02:59:33.016Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3uJG8.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文系掘金委托翻译整理的 BlinkOn9 会议演讲内容&lt;br&gt;演讲资料 &lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频&lt;/a&gt;/ &lt;a href=&quot;https://docs.google.com/presentation/d/1Iko1oIYb-VHwOOFU3rBPUcOO_9lAd3NutYluATgzV_0/edit#slide=id.g36f1b50c08_0_3702&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;BlinkOn9&lt;/code&gt; 会议中，Google Blink 团队开发者 Philip Rogers 与 Stefan Zager 进行了&lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Blink Rendering - Rebuilding the Engine Mid-Flight》分享&lt;/a&gt;，旨在介绍 Blink 渲染的基本原理与开发团队近期对滚动性能、绘制合成与排版的改进。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;第一部分：渲染是什么？&quot;&gt;&lt;a href=&quot;#第一部分：渲染是什么？&quot; class=&quot;headerlink&quot; title=&quot;第一部分：渲染是什么？&quot;&gt;&lt;/a&gt;第一部分：渲染是什么？&lt;/h2&gt;&lt;p&gt;简单来说，渲染是浏览器的某种基础功能，它将你的 HTML 和 CSS 解析成 DOM 树，并将其转换成屏幕上的像素点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3uRsJ.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中显示了 &lt;code&gt;document&lt;/code&gt; 生命周期的主要阶段，中间四个黑色框是渲染流水线（&lt;code&gt;render pipeline&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;我一直认为研究 Chrome 的追踪器有助于理解 document 生命周期。因此，下图是一个渲染进程的 Chrome 追踪器面板，图中的高亮区域是渲染主线程，底部的一小部分属于合成器线程（&lt;code&gt;compositor thread&lt;/code&gt;）。在渲染的开始，我们可能会处理资源加载，运行 JavaScript，修改 DOM 树等等，其间会有一段空闲阶段，用于处理一般任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3u4d1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，就会发生 &lt;code&gt;VSync&lt;/code&gt;（垂直同期，Vertical Synchronization）。vsync 是浏览器刚刚将一个满满的像素窗口推到显示器上，并且开始生成下一个像素窗口了。因此对于渲染进程来说，这意味着全员都已做好准备生成新的像素点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3u5Ix.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;vsync 触发了 &lt;code&gt;BeginMainFrame&lt;/code&gt;，这是一个重要方法，它&lt;strong&gt;驱动了渲染流水线&lt;/strong&gt;。&lt;code&gt;BeginMainFrame&lt;/code&gt; 首先会处理输入事件，如滚动、触屏、手势、鼠标等，然后会运行 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 回调。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3uLsH.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来便是开始执行渲染流水线了，如下图，共有四个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;style: 将 DOM 树转化为 layout 树，遍历 layout 树为每一个节点标注其样式信息，然后将带有样式信息的 layout 树传递到下一阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;layout: 我们将再次遍历 layout 树，为节点标注其尺寸、位置信息，至此我们已两次对 layout 树进行标注，然后将它传递给合成阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;composition setup: 在合成设置阶段我们会确定需要绘制多少个合成层（&lt;code&gt;compositing layers&lt;/code&gt;），以及它们的尺寸、位置、层叠顺序等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;paint: 绘制阶段会获取 layout 树的标注以及在合成设置阶段所记录信息，然后创建一个由原始绘图命令组成的“显示列表”，它会指示合成器如何进行像素绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3ujeA.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在绘制阶段的结尾，会由主线程切换到合成线程（即下图追踪器中的绿色区域），将光栅化工作切分成几个“瓦片”，分配给几个工作线程来进行。待光栅化完成，我们将进入 Chrome 合成器。这一过程会循环往复地执行下去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3K9W8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上便是关于渲染的简单介绍，值得注意的一点是，主线程非常繁忙，所有动作都发生在主线程，脚本在主线程运行，还负责了渲染和许多其它功能，因此&lt;strong&gt;主线程是非常拥挤的&lt;/strong&gt;。经过多年的优化工作，我们发现一个非常有效的优化方式，就是把主线程的工作切分，交给其它线程处理。&lt;/p&gt;
&lt;h2 id=&quot;第二部分：渲染的重要性与时下的难题&quot;&gt;&lt;a href=&quot;#第二部分：渲染的重要性与时下的难题&quot; class=&quot;headerlink&quot; title=&quot;第二部分：渲染的重要性与时下的难题&quot;&gt;&lt;/a&gt;第二部分：渲染的重要性与时下的难题&lt;/h2&gt;&lt;p&gt;对于 Web 平台来说，渲染是非常重要的。&lt;/p&gt;
&lt;p&gt;一是因为，动态网页的本质是接受用户或脚本生成的输入，并将其转化为视觉结果。&lt;strong&gt;渲染是这个过程的核心&lt;/strong&gt;，因此无论你的页面做的有多么酷炫，如果渲染出了问题，用户就不会有任何好的体验。&lt;/p&gt;
&lt;p&gt;其二，&lt;strong&gt;渲染是网页性能的主要决定因素&lt;/strong&gt;(感知的和实际的)，渲染是无法中断的，如果 JavaScript 运行太久页面就会变得笨重，这当然会引起用户注意。&lt;/p&gt;
&lt;p&gt;其三，现代网页是动态的——会不断地修改内容，加载内容，进行动画。为了跟上步伐，保证交互流畅，&lt;strong&gt;渲染代码必须是一等公民&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面开始介绍我们在渲染代码中遇到的挑战，以及为了解决这些问题我们正在着手进行的改进。&lt;/p&gt;
&lt;h3 id=&quot;1-滚动&quot;&gt;&lt;a href=&quot;#1-滚动&quot; class=&quot;headerlink&quot; title=&quot;1. 滚动&quot;&gt;&lt;/a&gt;1. 滚动&lt;/h3&gt;&lt;p&gt;正如前文所说，渲染是网页性能的主要决定因素，而&lt;strong&gt;滚动体验则是其重中之重&lt;/strong&gt;。用户对于滚动体验是非常敏感的，滚动的体验决定了其对页面整体性能的感知，如果滚动体验很糟糕，页面再酷炫也拯救不了。Blink 中涉及到滚动的代码巧妙地隐藏在各处，跨越了渲染器中的主线程与合成线程，甚至包括浏览器进程。&lt;/p&gt;
&lt;p&gt;回首历史，在 1998 年 &lt;code&gt;KHTML&lt;/code&gt; 的原始版本中首次赋予了 &lt;code&gt;document&lt;/code&gt; 滚动能力。其后，2003 年 &lt;code&gt;WebKit&lt;/code&gt; 中 div 也可以进行滚动了，然而这两种滚动都需要重新触发渲染流水线来进行。起初，这两种滚动的代码是分开编写的，这也没什么大不了的。&lt;/p&gt;
&lt;p&gt;然而几年之后，随着对滚动添加了很多功能，做了很多优化，这些关于滚动的代码直接变成了 Blink 中最复杂也最难懂的部分。我们依然维护着这两套滚动代码，所有的功能都要写两遍。不仅如此，由于滚动属于核心代码，实现其它功能也难免要去修改它，复杂度直线上升，越来越难以维护了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3KPSS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于目前滚动代码的现状，以及任何功能改动都要写两遍，我们所有开发者的工作都变得很困难，因此，在 2014 年 Steve Kobus 与 Elliott 想到了一个绝妙的主意：通过根层滚动（&lt;code&gt;Root Layer Scrolling&lt;/code&gt;）来解决这个问题。&lt;/p&gt;
&lt;p&gt;他们决定取消 &lt;code&gt;document&lt;/code&gt; 文档级滚动，只使用 &lt;code&gt;overflow&lt;/code&gt; 实现所有的滚动功能，这一决定主要是为了降低代码的复杂度，改善代码质量。除此之外还有别的好处，比如，由于两套代码已经分别维护了很长时间，他们的行为表现也并不一致。实际上，文档级滚动行为有明显差异，这是因为文档级滚动与 div 滚动会有一些完全不相关的 Bug，一种滚动有 Bug，另一张滚动可能没有，真是一团糟。&lt;/p&gt;
&lt;p&gt;实现根层滚动也是一个漫长艰辛的过程，历经 4 年，终于完成，在 M66 版本交付。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3KiQg.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;想要大规模改动修改渲染代码的布局部分，第一件事是要通过大约四万五千个布局测试，上图中测试失败次数是由 1500 开始的，事实上，我们刚开始进行修改时，大约有 6000 个测试都失败了。这些测试都需要分门别类，挨个解决，因此在这个过程中我们又顺便解决了很多历史遗留 Bug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3M58K.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我们的性能基准测试图中可以发现，在我们刚开展工作时，性能有了一次明显退化，大概退化了 40% 到 50%，随着深入研究这些性能 Bug，我们发现这些是深递归到 CPU 路径的代码，因此我们必须做 CPU 相关优化与 Chrome chromium 部分的代码修改。这是一个非常艰难的过程，要各种不同的代码修复才能让我们真正回到基线性能。&lt;/p&gt;
&lt;p&gt;所以我也不得不重申，这块代码真的很难处理，如果我们犯了任何错误，用户都会立即发现，这些错误也会影响所有页面。&lt;/p&gt;
&lt;p&gt;接下来我们来了解一下关于绘制与合成我们所做的改进。&lt;/p&gt;
&lt;h3 id=&quot;2-绘制与合成&quot;&gt;&lt;a href=&quot;#2-绘制与合成&quot; class=&quot;headerlink&quot; title=&quot;2. 绘制与合成&quot;&gt;&lt;/a&gt;2. 绘制与合成&lt;/h3&gt;&lt;p&gt;同滚动代码一样，绘制与合成部分的代码也相当古老，大概已经有 16 年了，在当前的代码架构中开发新功能实属不易。现在有机会对这一部分代码进行性能优化，降低内存占用，使得代码易于扩展，便于开发新功能。因此我们开展了一个综合工程项目：绘制代码瘦身。&lt;/p&gt;
&lt;p&gt;有必要先从技术方面概述绘制是什么，为什么它如此酷炫，以及我们在整体项目中所处的位置。因此，我们先从前文所提到的滚动是如何工作的开始吧。&lt;/p&gt;
&lt;p&gt;在过去，如果我们想进行 div 滚动，我们需要重绘出每一帧。这意味着如果用户一直拖动滚轮，我们就需要生成所有的像素点，用户需要等待我们运行整个渲染流水线后才可以继续移动。&lt;/p&gt;
&lt;p&gt;这里有一个惊人的创新叫做合成线程滚动（&lt;code&gt;composited threaded scrolling&lt;/code&gt;），其中有两个部分，一个是合成，这很像从电子游戏中获得的灵感，其思想是将整个可滚动区域绘制到一个图像图形缓冲区中，然后并不是每一帧重绘移动区域，而是将一个子纹理复制到不同的纹理中。第二个创新是将滚动操作脱离出主线程，还记得前文提到过的吧，主线程的资源是多么宝贵，此处的基本思想是我们可以在 JavaScript 运行的同时进行滚动。这两件事结合在一起，是一项非常惊人的创新，这种合成线程渲染的思想可以推广到任何需要对纹理进行修改的地方。&lt;/p&gt;
&lt;p&gt;比如说，transform，opacity，filter，clip 等等这些都可以通过合成线程思想来实现。当你在软件上运行，用 CPU 绘制像素时，速度很快，但是如果在 GPU 上运行，它的速度更会快成一道闪电。&lt;/p&gt;
&lt;p&gt;但是这里有一个叫“老巢爆炸（&lt;code&gt;lair explosion&lt;/code&gt;）”的问题。如下图，如果我们将绿盒子使用合成线程进行旋转，它会贯穿蓝盒子。问题是我们需要确认蓝盒子会被绘制在绿盒子之上，因此蓝盒子也会被合成。这种情况会占用相当多的内存。你作为一名前端工程师，在页面上设置了透明度，有可能你就突然发现内存爆炸了，因为页面上其它部分也都被合成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3MLVA.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面来介绍一下当下合成器架构体系来阐述合成器是如何工作的，绘制代码瘦身又有什么样的成效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3QVP0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们有一个简单的 DOM 树结构，有 emoji 笑脸表情的 div 是可以滚动的。它的生命周期与前文所述的并无二致，因此在排版环节我们将标注 layout 树的尺寸与位置信息，然后便是合成设置环节了，我们重点讲一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Qe2T.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;a、b、d 都不可滚动，所以它们仨可以一起绘制到同一个图形缓冲区中（&lt;code&gt;graphics buffer&lt;/code&gt;）。而 emoji 笑脸表情是可以滚动的，我们不想为它的滚动重绘每一帧，因此把它单独放到一个图形缓冲区中。现在我们有了两个图形缓冲区，是时候进行绘制了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3QMqJ.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在绘制过程中，我们实际上是遍历 layout 树，记录绘图命令。然后是进行光栅化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3QlZ9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时我们将执行绘制步骤中所记录的绘图命令，生成真正的像素点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Q1aR.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终我们将在页面上它们安放到一起，上下滚动 emoji 表情时也不会触发重绘步骤了。&lt;/p&gt;
&lt;p&gt;在目前的架构体系下，有两个问题，一是&lt;strong&gt;合成仅限于特定子树&lt;/strong&gt;。layout 树有一个属性，决定我们能否进行合成。并非所有子树都有这个属性，因此我们不能随意将页面上的 div 转换成图形缓冲区，这导致了一个基本性合成 Bug，在 2014 年首次发现。&lt;/p&gt;
&lt;p&gt;当时我们试图让 iframe 在任意地方合成，以提高滚动性能，结果发现页面上的内容瞬间都消失了，原因是如果制作了一个合成的 iframe，你还需要确保任何绘制在它上方的内容也是合成的。这是一个在 2014 年发现的毁灭性错误，因为你已经建立了这些特殊的逻辑来不创建过多的图形缓冲区处理诸如此类的事情，结果在游戏的后期发现了一种基本的缺陷，这种缺陷束缚了你的手，这并不是是把你的手绑在一个边缘案例中，这一个可能遇到的情况（Gmail 在进行滚动优化时就遇到了这个问题，优化无法生效），这阻止了我们继续在当前架构中构建。&lt;/p&gt;
&lt;p&gt;我们当前合成体系结构的第二个问题是&lt;strong&gt;合成设置是在绘制之前完成的&lt;/strong&gt;。我们在系统早期就创建了图像缓冲区，你需要在绘制步骤中重新计算，所以我们有重复的逻辑，很难描述这个逻辑有多复杂，但是我可以说大约一半的绘制代码是用于这种大小和效果，比如 clip。&lt;/p&gt;
&lt;p&gt;除了在绘制之前进行这种合成设置之外，还有一个问题，因为它在主线程上，这意味着任何可能改变绘制对象大小的效果都需要回到主线程。例如，如果你有两个可以合成的盒子，其中一个是可以滚动的，那么在很多情况下你必须假设最坏的情况。你必须假设合成器可以在页面上的任何地方进行，所以你必须为页面上的许多东西创建图像缓冲区，这是我们之前讨论过的老巢爆炸问题，导致了真正的性能问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Q3I1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;绘制代码瘦身项目改变了我们整个架构中的这两个问题。它改变了我们如何选择合成事物的粒度，这样你就可以合成，将任何效果转换成图像缓冲区，第二是我们将合成设置移动到绘制后。这不仅可以解决基础性合成 Bug，也避免了逻辑重复。&lt;/p&gt;
&lt;p&gt;因此，新的合成架构可以在任何边界进行合成，我们已经移动了合成设置应用程序，以释放主线程的压力。这使我们能够对重叠的事物做出精确的合成决定，可以做一些改变主线程外绘制对象大小的事情。&lt;/p&gt;
&lt;p&gt;在这个项目的里程碑中，我们已经完成了关于绘制缓存的功能，目前处于 M67，刚刚发布了绘制代码瘦身的 V1.75 版本。在今年（2018）年底，我们将发布 V2 版本，将合成设置移动到绘制后进行。&lt;/p&gt;
&lt;h3 id=&quot;3-布局排版&quot;&gt;&lt;a href=&quot;#3-布局排版&quot; class=&quot;headerlink&quot; title=&quot;3. 布局排版&quot;&gt;&lt;/a&gt;3. 布局排版&lt;/h3&gt;&lt;p&gt;布局有两个主要问题，第一个是 web 平台问题，我们称之为&lt;strong&gt;组合问题&lt;/strong&gt;(&lt;code&gt;The Combinatorial Problem&lt;/code&gt;)。我们有大量的 web 标准，并且还在不断添加更多新的标准，同时旧的标准也依然存在，每次我们定义新的 CSS 标准时，它都会创建一组带有与所有现有 CSS 标准的新交互。它们结合的方式有一点奇怪，随之而来有很多的边界 case，让我们以 &lt;code&gt;flexbox&lt;/code&gt; 为例看一看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3QJG6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很简单的三个 flex item 盒子，我们添加几个属性看看布局会发生什么变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Qase.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;direction: rtl&lt;/code&gt; 会使得布局方向变为从右往左。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Yufs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此基础上，添加一个 &lt;code&gt;flex-direction: row-reverse&lt;/code&gt;，布局方向又恢复为从左往右了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Yl60.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;把 &lt;code&gt;direction&lt;/code&gt; 属性去掉，从右往左排布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3YG0U.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt; 设置为 &lt;code&gt;columb-reverse&lt;/code&gt;，布局改为按列排布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3YJ7F.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;writing-mode&lt;/code&gt; 同时 &lt;code&gt;flex-direction&lt;/code&gt; 改为行排布，使得文字方向也发生了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Y06x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt; 改为反向，依然复合预期。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3YrnK.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt; 改为列，也是一样。举例到这里就足够了，以上之所以表现复合预期，是因为我花了三周的时间解决各种 Bug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3YcAe.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在其它内核的浏览器中可就不一定了，如上图，第一个图是以上 flexbox 示例在 chromium 中的表现，第一排第二个浏览器表现也几乎相同，然而第三个第四个可就相去甚远。&lt;/p&gt;
&lt;p&gt;我无意 diss 其它浏览器，换个功能示例，可能 chromium 就是表现最差的那一个。我是想强调这个兼容性问题确实存在，复杂的 CSS 特性也在持续堆积。&lt;/p&gt;
&lt;p&gt;第二个问题是 &lt;strong&gt;Blink 中布局相关的代码是非常远古的，里面充斥着无封装，不可重入，非线程安全的面条式巨石代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先解释一下巨石代码，这里有一个 layout 树，节点是 layout 对象，假设我们在树下面的一个元素上改变 CSS。元素现在变脏了，需要转发出去。接下来我们要做的是标记整个祖先链，当我们想执行 layout 阶段时，我们总是从树顶开始，一直往下走，现在我们进行了一系列优化，但是优化后的也没有跳过很多步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Y2hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们仍然要进行完整的树遍历，这也是耗费资源的，每次我们执行 layout 都会进行遍历。底部节点可能位于一个尺寸固定的盒子里，它甚至可以使用 &lt;code&gt;CSS containment&lt;/code&gt;，这是一个新特性，有点类似于浏览器的契约，意味着这个子树不会影响它自身以外的任何东西，子树以外的任何东西也不会影响它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3Yjcq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果布局这棵子树时我们已经有了所有我们所需要的信息，无需在这个子树之外寻找任何额外的信息来确定大小和位置就好了。然而事实上，我们一直在运行布局代码来获取其他信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3tpHU.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;处于图中这个节点中，如果出于某种原因我们可以跳到树的另一部分吗？不可以，这是一个毁灭性操作。&lt;/p&gt;
&lt;p&gt;至于线程安全，还记得最开始我们了解的渲染流水线吧？我们遍历 layout 树，还对它进行标注，然后传递给绘制阶段。当我们完成所有任务准备生成下一帧内容时，会从上次使用的 layout 树开始，根据已改变的内容来更新它。这里是没有什么是线程安全的，可能有多个线程修改它。&lt;/p&gt;
&lt;p&gt;对于以上两个问题，相应有两个解决方案。针对&lt;strong&gt;组合问题&lt;/strong&gt;，解决方案是 CSS 定制布局即 &lt;a href=&quot;https://developers.google.com/web/updates/2016/05/houdini&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Houdini&lt;/a&gt;，这意味着可以在元素上设置特定的 CSS 属性，然后定义一个 JavaScript 函数，该函数负责布局该元素及子树。在常规布局过程中，我们会暂停然后去调用 JavaScript 函数，传给它一组布局元素所需要的信息，函数将消费它。这里不会讲太多 &lt;code&gt;Houdini&lt;/code&gt; 的细节，大家有兴趣可以自行研究。&lt;/p&gt;
&lt;p&gt;针对第二个问题的解决方案是 &lt;code&gt;Layout NG&lt;/code&gt;，这实际上是对如何完成布局的全盘反思。&lt;code&gt;Layout NG&lt;/code&gt; 有两个特性，一是它使用约束驱动的布局，输入一个子树来进行布局，我们传递给它所有它所需要的在子树中进行布局的信息，而且它根本不看子树的外面。实现这一点也并不容易，通过在中强制封装，我们让底层布局代码更容易实现刚才提到的 CSS 定制布局。第二个特性是，输入（layout 树）与输出（fragment 树）的树都是&lt;strong&gt;不可变对象&lt;/strong&gt;，我们每次都创建一个新的布局树，一旦我们创建了它，该树就不可变了，我们并不是在这个输入树上进行注释，而是复制它，并用新的替换子树来改变子树，我们将拥有布局树的全新副本。&lt;/p&gt;
&lt;p&gt;这两个特性的实现将使得布局方面的各种强力优化成为可能。这一项目尚属早期，第一阶段预计在今年年底、明年年初发布。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V3uJG8.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文系掘金委托翻译整理的 BlinkOn9 会议演讲内容&lt;br&gt;演讲资料 &lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot;&gt;视频&lt;/a&gt;/ &lt;a href=&quot;https://docs.google.com/presentation/d/1Iko1oIYb-VHwOOFU3rBPUcOO_9lAd3NutYluATgzV_0/edit#slide=id.g36f1b50c08_0_3702&quot;&gt;PPT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;BlinkOn9&lt;/code&gt; 会议中，Google Blink 团队开发者 Philip Rogers 与 Stefan Zager 进行了&lt;a href=&quot;https://www.youtube.com/watch?v=ExNYN_phaxI&quot;&gt;《Blink Rendering - Rebuilding the Engine Mid-Flight》分享&lt;/a&gt;，旨在介绍 Blink 渲染的基本原理与开发团队近期对滚动性能、绘制合成与排版的改进。&lt;/p&gt;
    
    </summary>
    
      <category term="render chrome" scheme="https://blog.colafornia.me/categories/render-chrome/"/>
    
    
  </entry>
  
  <entry>
    <title>生命在于折腾，写一个前端资讯推送服务</title>
    <link href="https://blog.colafornia.me/post/2018/the-beginning-of-little-robot/"/>
    <id>https://blog.colafornia.me/post/2018/the-beginning-of-little-robot/</id>
    <published>2018-09-11T04:39:00.000Z</published>
    <updated>2019-10-24T03:04:03.719Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wi2d.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年年底开始写的一个小项目，断断续续做了些优化，在此简单的记录一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;源头&quot;&gt;&lt;a href=&quot;#源头&quot; class=&quot;headerlink&quot; title=&quot;源头&quot;&gt;&lt;/a&gt;源头&lt;/h2&gt;&lt;p&gt;起源是之前一直没什么机会接触到 Node 项目，工作中接触到的也仅限于用 Node 写脚本，做一些小工具，与服务器上跑的 Node 服务相差甚远。所以想写一个在服务器上跑的 Node 小项目练手。&lt;/p&gt;
&lt;p&gt;一直喜欢用 RSS 订阅资讯这种方式，简单高效，与其每天不定时地接收推送，打开各网站 App 来接收资讯，不如自己拿到主动权集中在同一时间段统一阅读。这样避免了每天不定时接受信息的焦虑堆积，但是又常常想不起来打开😅，过了一周打开 Reeder，发现累积的未读资讯又爆炸了，人真是很难满足。&lt;/p&gt;
&lt;p&gt;于是决定自己搞个资讯推送服务吧，满足自己的核心诉求，&lt;strong&gt;每个工作日早上 10 点微信推送 RSS 前端资讯的更新&lt;/strong&gt;，这样就可以在每天抵达工位的时候舒舒服服浏览一下新鲜事，挑一些有用的存起来慢慢研读。&lt;/p&gt;
&lt;p&gt;项目仓库： &lt;a href=&quot;https://github.com/Colafornia/little-robot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Colafornia/little-robot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推送大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wi2d.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在推送源主要是各厂的知乎专栏，大佬们的个人博客，掘金前端热门文章，都是我自己的个人口味。&lt;/p&gt;
&lt;p&gt;下面来讲一下开发（与自己给自己加需求）历程。&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;最开始感觉这个需求是很简单的，具体操作可以分解为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写一个配置文件，把我想抓取的 RSS 源地址写在里面&lt;/li&gt;
&lt;li&gt;找一个能解析 RSS 的 npm 包，遍历配置文件里的源，解析之后处理数据&lt;/li&gt;
&lt;li&gt;仅筛出在过去 24 小时内更新的文章，把数据处理一下，汇总成一段字符串，用微信推送&lt;/li&gt;
&lt;li&gt;以上写出的脚本通过定时任务跑起来，done！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后选择了 &lt;a href=&quot;https://github.com/bobby-brennan/rss-parser&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;rss-parser&lt;/a&gt; 作为解析工具包，&lt;a href=&quot;https://pushbear.ftqq.com/admin/#/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PushBear&lt;/a&gt; 作为推送服务，&lt;a href=&quot;https://github.com/node-schedule/node-schedule&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-schedule&lt;/a&gt; 任务调度工具写出来了一版。&lt;/p&gt;
&lt;p&gt;然后就发现自己知识的匮乏了，没有考虑到脚本部署到服务器上时，进程守护的问题，于是研习了一波 &lt;a href=&quot;https://github.com/Unitech/pm2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pm2&lt;/a&gt;，完美完成任务。&lt;/p&gt;
&lt;h2 id=&quot;过渡&quot;&gt;&lt;a href=&quot;#过渡&quot; class=&quot;headerlink&quot; title=&quot;过渡&quot;&gt;&lt;/a&gt;过渡&lt;/h2&gt;&lt;p&gt;项目写到这里其实是可以凑和用了，但是看起来很 low 很难受。主要问题有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当时 RSS 源大概有四五十个，一次性遍历解析所有的源经常会有超时或者出错的&lt;/li&gt;
&lt;li&gt;RSS 源写在配置文件里，每次想添加、修改源都需要改代码，很 low&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pushbear.ftqq.com/admin/#/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PushBear&lt;/a&gt; 这个推送服务只能存储三天内的推送，三天前，一周前的推送内容都看不了，这也很难受&lt;/li&gt;
&lt;li&gt;掘金的 RSS 源内容不多，也不是按照热门程度排序的（也可能是我姿势不对😅），不太符合要求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一点稍微有点复杂，可能现在解决的方案依然很原始。出现第一个问题一是需要控制请求的并发数量，二是 RSS 源本身有一定的不稳定性。目前的解决方案是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把抓取任务和推送任务分开，预留出可以循环抓取三次的时间，后面两次只抓取之前失败的源&lt;/li&gt;
&lt;li&gt;用 &lt;a href=&quot;https://github.com/caolan/async&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;async&lt;/a&gt; 的 &lt;code&gt;mapLimit&lt;/code&gt; 和 &lt;code&gt;timeout&lt;/code&gt; 方法设置最大并发数量和超时时间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大致代码如下（有一些细节处理没贴上来）：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 抓取定时器 ID&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fetchInterval = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 抓取次数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; fetchTimes = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPushSchedule&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    schedule.scheduleJob(&lt;span class=&quot;string&quot;&gt;&#39;00 30 09 * * *&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 抓取任务&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.info(&lt;span class=&quot;string&quot;&gt;&#39;rss schedule fetching fire at &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        activateFetchTask();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    schedule.scheduleJob(&lt;span class=&quot;string&quot;&gt;&#39;00 00 10 * * *&#39;&lt;/span&gt;, () =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 发送任务&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.info(&lt;span class=&quot;string&quot;&gt;&#39;rss schedule delivery fire at &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; message = makeUpMessage();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.info(message);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sendToWeChat(message);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;activateFetchTask&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  fetchInterval = setInterval(fetchRSSUpdate, &lt;span class=&quot;number&quot;&gt;120000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  fetchRSSUpdate();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fetchRSSUpdate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fetchTimes++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (toFetchList.length &amp;amp;&amp;amp; fetchTimes &amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若抓取次数少于三次，且仍存在未成功抓取的源&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.info(&lt;span class=&quot;string&quot;&gt;`第&lt;span class=&quot;subst&quot;&gt;$&amp;#123;fetchTimes&amp;#125;&lt;/span&gt;次抓取，有 &lt;span class=&quot;subst&quot;&gt;$&amp;#123;toFetchList.length&amp;#125;&lt;/span&gt; 篇`&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最大并发数为15，超时时间设置为 8000ms&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mapLimit(toFetchList, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, (source, callback) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            timeout(parseRSS(source, callback), &lt;span class=&quot;number&quot;&gt;8000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    log.info(&lt;span class=&quot;string&quot;&gt;&#39;fetching is done&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    clearInterval(fetchInterval);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fetchDataCb();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样基本解决了 90% 以上的抓取问题，保证了脚本的稳定性。&lt;/p&gt;
&lt;p&gt;针对 RSS 源写在配置文件里，每次想添加、修改源都需要改代码的问题，解决方法很简单，把源配置写到 MongoDB 里也就好了，有一些 GUI 软件可以直接在图形界面来添加、修改数据。&lt;/p&gt;
&lt;p&gt;为了解决推送服务只能存储三天内的推送，决定新增一个每周五的周抓取任务，抓取一周内的新文章，把内容作为 issue 发到仓库。也还算是一个解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wVqP.jpg&quot; width=&quot;480&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对掘金的 RSS 源问题，最后决定直接调用掘金的接口来取数据，这就可以随心所欲按自己的需求来了，每天只抓取❤️点赞数在 70 以上的文章。&lt;/p&gt;
&lt;p&gt;顺便给抓取的文章时间范围加了一个偏移值，避免筛掉质量好但是由于刚刚发布点赞较少的文章。感觉自己棒棒哒~&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;filterArticlesByDateAndCollection&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; threshold = &lt;span class=&quot;number&quot;&gt;70&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// articles 是已按❤️数由高到低排序的文章列表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; results = articles.filter((article) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 偏移值五小时，避免筛掉质量好但是由于刚刚发布点赞较少的文章&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; moment(article.createdAt).isAfter(moment(startTime).subtract(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;hours&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; moment(article.createdAt).isBefore(moment(endTime).subtract(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;hours&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; article.collectionCount &amp;gt; threshold;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 掘金文章最多收录 8 篇，避免信息爆炸&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; results.slice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个期间也充分感受到了日志的重要性，在数据库里新增了一个表用来存每天的推送内容。&lt;/p&gt;
&lt;p&gt;另外在 &lt;a href=&quot;https://pushbear.ftqq.com/admin/#/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PushBear&lt;/a&gt; 上新添加了一个 Channel 来给自己推送日志，每天在抓取任务完成后，先给我发送一下抓取到的内容，如果发现有任何问题，我可以自己登服务器紧急修复一下（这么想来还是很 low 😅）。&lt;/p&gt;
&lt;h2 id=&quot;升级&quot;&gt;&lt;a href=&quot;#升级&quot; class=&quot;headerlink&quot; title=&quot;升级&quot;&gt;&lt;/a&gt;升级&lt;/h2&gt;&lt;p&gt;做完以上改动之后，脚本稳定地跑了快半年，这期间我也一直在忙着搬砖，没什么精力再来改造它。&lt;/p&gt;
&lt;p&gt;一直没做推广，但某天突然发现已经有了三十多个用户在订阅这个服务，于是良心发现，本着对用户负责（也是自己有了新的想练习的技术👻）,就又做了一次改造。&lt;/p&gt;
&lt;p&gt;此时项目的问题有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有文章去重，如果文章在知乎专栏发了，掘金也发了，作者个人博客也发了的话，就相当于会重复出现几次&lt;/li&gt;
&lt;li&gt;推送的时间间隔不精确，都是当前时间的过去 24 小时来筛的&lt;/li&gt;
&lt;li&gt;脚本直连数据库进行存取操作也不太好，感觉这个形式做成 server，对外暴露 api 更合理（等哪天想写个 RSS 阅读器也就用上了）&lt;/li&gt;
&lt;li&gt;每次代码有更新，依赖有更新，都 ssh 上服务器然后 &lt;code&gt;npm install&lt;/code&gt; 感觉也不太专业，有提升空间（其实就是想用 &lt;code&gt;docker&lt;/code&gt; 了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1，2 问题很好解决，每次抓取之前先查一下日志，上次推送的具体时间。每抓到新文章时，再与最近 7 天日志里的文章比对一下，重复的不放到抓取结果中，也就解决了。&lt;/p&gt;
&lt;p&gt;对于问题 3，于是决定搭建 Koa Server，先把从 MongoDB 读取推送源，存取推送日志变成 api。&lt;/p&gt;
&lt;p&gt;目录结构如下，添加 &lt;code&gt;Model&lt;/code&gt; 与 &lt;code&gt;Controller&lt;/code&gt;。把 RSS 抓取脚本与掘金爬虫放到 task 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wQ2j.jpg&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;没什么难点，就可以调用 api 来获取 RSS 源了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1w8rq.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时想到了一个重要问题，&lt;strong&gt;身份验证&lt;/strong&gt;。肯定不能把所有 api 都随意暴露出去，让外界可以任意调用，这也就相当于把数据库都暴露出去了。&lt;/p&gt;
&lt;p&gt;最终决定用 &lt;code&gt;JSON Web Token（缩写 JWT）&lt;/code&gt; 作为认证方案，主要原因是 JWT 适合一次性、短时间的命令认证，目前我的服务仅限于服务器端的 api 调用，每天的使用时间也不长，无需签发有效期很长的令牌。&lt;/p&gt;
&lt;p&gt;Koa 有一个 &lt;a href=&quot;https://github.com/koajs/jwt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jwt&lt;/a&gt; 的中间件&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// index.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;app.use(jwtKoa(&amp;#123; secret: config.secretKey &amp;#125;).unless(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    path: [&lt;span class=&quot;regexp&quot;&gt;/^\/api\/source/&lt;/span&gt;, &lt;span class=&quot;regexp&quot;&gt;/^\/api\/login/&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;加上中间件后，除了 &lt;code&gt;/api/source&lt;/code&gt; 与 &lt;code&gt;/api/login&lt;/code&gt; 接口就都需要经过 jwt 认证才能访问了。&lt;/p&gt;
&lt;p&gt;因此写了一个 &lt;code&gt;/api/login&lt;/code&gt; 接口，用于签发令牌，拿到令牌之后，把令牌设置到请求头里就可以通过认证了：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// api/base.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 用于封装 axios&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// http request 拦截器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; axios &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;axios&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; config = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;../config&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Instance = axios.create(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    baseURL: &lt;span class=&quot;string&quot;&gt;`http://localhost:&lt;span class=&quot;subst&quot;&gt;$&amp;#123;config.port&amp;#125;&lt;/span&gt;/api`&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout: &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    headers: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        post: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;application/json&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Instance.interceptors.request.use(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (config) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// jwt 验证&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; token = config.token;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (token) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            config.headers[&lt;span class=&quot;string&quot;&gt;&#39;Authorization&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;`Bearer &lt;span class=&quot;subst&quot;&gt;$&amp;#123;token&amp;#125;&lt;/span&gt;`&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; config;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    error =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果请求头里没有正确的 token，则会返回 &lt;code&gt;Authentication Error&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至于问题 4，现在服务比较简单，也只在一个机器上部署，手动登机器 npm install 问题还不大，如果机器很多，依赖项也复杂的话，很容易出问题，具体参见&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39209596&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;科普文：为什么不能在服务器上 npm install ？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;于是决定基于 &lt;code&gt;Docker&lt;/code&gt; 做构建部署。&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; daocloud.io/node:&lt;span class=&quot;number&quot;&gt;8.4&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;onbuild&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt; package*.json ./&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; cnpm install&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; echo &quot;Asia/Shanghai&quot; &amp;gt; /etc/timezone&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt; dpkg-reconfigure -f noninteractive tzdata&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt; . .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;EXPOSE&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3001&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CMD [ &lt;span class=&quot;string&quot;&gt;&quot;npm&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;start&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;$value1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;$value2&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;$value3&quot;&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用的比较简单，主要就是负责安装依赖，启动服务。需要注意的主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;国内拉去外网的镜像很慢，像 Node 官方的镜像我都拉了好久都没拉下来，这样的话推荐使用国内的镜像，比如我用的 DaoCloud，还有阿里云镜像等等&lt;/li&gt;
&lt;li&gt;由于推送服务是对时间敏感的，基础镜像的时区并不是国内时区，要手动设置一下&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后去 &lt;a href=&quot;https://dashboard.daocloud.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DaoCloud&lt;/a&gt; 等提供公有云服务的网站授权访问 Github 仓库，连接自己的主机，就可以实现持续集成，自动构建部署我们的镜像了。具体步骤可参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37961402&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于 Docker 打造前端持续集成开发环境&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wwRJ.jpg&quot; alt=&quot;daocloud&quot;&gt;&lt;/p&gt;
&lt;p&gt;本次优化大概就到这里了。接下来要做的可能是提供一个推送历史查看页面，优先级不是很高，有时间再做吧（顺便练习一下 Nginx）。&lt;/p&gt;
&lt;p&gt;现在的实现方案可能还是有很不合理的地方，欢迎提出建议。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wi2d.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年年底开始写的一个小项目，断断续续做了些优化，在此简单的记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="open-source" scheme="https://blog.colafornia.me/categories/open-source/"/>
    
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://blog.colafornia.me/post/2018/character-encoding/"/>
    <id>https://blog.colafornia.me/post/2018/character-encoding/</id>
    <published>2018-09-03T06:20:00.000Z</published>
    <updated>2019-10-24T02:22:04.196Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://i.dailymail.co.uk/i/pix/2016/10/27/21/39C8A74600000578-3879480-The_touch_bar_can_display_emotions_in_messaging_apps_playback_co-a-5_1477598860842.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为编程知识基础中的基础，有必要消化整理输出一次。&lt;/p&gt;
&lt;p&gt;本文主要介绍了字符编码的几个重要基础概念，从 &lt;code&gt;ASCII&lt;/code&gt; 到 &lt;code&gt;Unicode&lt;/code&gt; 再到 &lt;code&gt;Emoji&lt;/code&gt; 与 &lt;code&gt;JavaScript&lt;/code&gt; 字符处理的一些坑。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h3&gt;&lt;p&gt;由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字。计算机中，&lt;code&gt;字节（byte）&lt;/code&gt; 是一个 &lt;code&gt;8bit&lt;/code&gt; 的储存单元，一个字节能表示的最大的整数就是 255（二进制的11111111 = 十进制255），如果要表示更大的整数，就必须用更多的字节。&lt;/p&gt;
&lt;h4 id=&quot;字符集&quot;&gt;&lt;a href=&quot;#字符集&quot; class=&quot;headerlink&quot; title=&quot;字符集&quot;&gt;&lt;/a&gt;字符集&lt;/h4&gt;&lt;p&gt;字符是文字与符号的总称，它是一个信息单位。字符集就是字符的集合。&lt;code&gt;ASCII码&lt;/code&gt;（American Standard Code for Information Interchange）就是一个字符集，这个集合中只有数字，英文字母和一些符号共 127 个字符。如果我们想处理中文、日文文本，仅通过 &lt;code&gt;ASCII码&lt;/code&gt; 就做不到了。在历史中由于眼光的局限性，出现了一些仅能处理部分字符的字符集，无法通用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/03/5b8d2209e4247.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;字符编码&quot;&gt;&lt;a href=&quot;#字符编码&quot; class=&quot;headerlink&quot; title=&quot;字符编码&quot;&gt;&lt;/a&gt;字符编码&lt;/h4&gt;&lt;p&gt;字符编码规定了字符集和实际存储的二进制数值之间的转换关系。一般来说，每个字符集都有其对应的字符编码方式（有的字符集有一个对应字符编码，有的则有多个）。像 &lt;code&gt;ASCII&lt;/code&gt; 与 &lt;code&gt;GB18030&lt;/code&gt; 都仅有一种编码实现，因此既可以作为字符集的名字，也可以用来指代它们的字符编码。&lt;/p&gt;
&lt;p&gt;通过以上概念的介绍不难窥探在字符编码的历史中存在以下痛点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符集不够通用，总有覆盖不到的字符&lt;/li&gt;
&lt;li&gt;新的字符集难以向下兼容老的&lt;/li&gt;
&lt;li&gt;覆盖更多字符的字符集，难以避免需要更多字节，如果我们的文本仅通过 &lt;code&gt;ASCII&lt;/code&gt; 就能处理的话，使用占用字节更多的字符集在储存和传输都不划算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题都由 &lt;code&gt;Unicode&lt;/code&gt; 及其字符编码一起打包解决了。&lt;/p&gt;
&lt;h3 id=&quot;Unicode&quot;&gt;&lt;a href=&quot;#Unicode&quot; class=&quot;headerlink&quot; title=&quot;Unicode&quot;&gt;&lt;/a&gt;Unicode&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unicode&lt;/a&gt; 是一个&lt;strong&gt;字符集&lt;/strong&gt;，旨于涵盖所有国家语言中可能出现的符号与文字，是目前绝大多数程序使用的字符编码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt;的诞生也不是一蹴而就，也有历史过程。&lt;/p&gt;
&lt;h4 id=&quot;历史进程&quot;&gt;&lt;a href=&quot;#历史进程&quot; class=&quot;headerlink&quot; title=&quot;历史进程&quot;&gt;&lt;/a&gt;历史进程&lt;/h4&gt;&lt;p&gt;（这段不是用来凑数的，这几个英文简写后面还会一直出现，知道了历史更方便记忆分辨）&lt;/p&gt;
&lt;p&gt;ISO 与 IEC 分别推出了 &lt;code&gt;Unicode&lt;/code&gt; 与 &lt;code&gt;UCS&lt;/code&gt;（Universal Multiple-Octet Coded Character Set） 。后来（只过了一年），两者进行整合，到了 Unicode2.0 时代，Unicode 的编码和 UCS 的编码都完全一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;USC&lt;/code&gt; 这个名字也并未从此消失在历史中。&lt;code&gt;UCS&lt;/code&gt; 标准有自己的格式，如&lt;code&gt;UCS-2&lt;/code&gt;，&lt;code&gt;UCS-4&lt;/code&gt;等等 而 Unicode 也有自己的不同编码实现，如&lt;code&gt;UTF-8&lt;/code&gt;，&lt;code&gt;UTF-16&lt;/code&gt;，&lt;code&gt;UTF-32&lt;/code&gt;等等。&lt;/p&gt;
&lt;h4 id=&quot;关于-Unicode-自己&quot;&gt;&lt;a href=&quot;#关于-Unicode-自己&quot; class=&quot;headerlink&quot; title=&quot;关于 Unicode 自己&quot;&gt;&lt;/a&gt;关于 Unicode 自己&lt;/h4&gt;&lt;p&gt;&lt;code&gt;码点 code point&lt;/code&gt; 是指在 Unicode 字符集中字符的值，根据 Unicode 标准，是前缀为 &lt;code&gt;U+&lt;/code&gt; 的十六进制数字。&lt;/p&gt;
&lt;p&gt;Unicode 字符分为 17 组平面（plane），每个平面拥有 2^16 (65,536) 个码点。每一个码点都可以用 16 进制 xy0000 到 xyFFFF 来表示，这里的 xy 是表示一个 16 进制的值，从 00 到 10。目前我们常用字符大多都在 BMP 基本平面中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/08/29/PXQfOA.png&quot; alt=&quot;plane&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;字节序与-BOM&quot;&gt;&lt;a href=&quot;#字节序与-BOM&quot; class=&quot;headerlink&quot; title=&quot;字节序与 BOM&quot;&gt;&lt;/a&gt;字节序与 BOM&lt;/h4&gt;&lt;p&gt;在了解 Unicode 的字符编码之前，还需要了解一个关于 &lt;code&gt;字节序&lt;/code&gt; 的知识。&lt;/p&gt;
&lt;p&gt;计算机硬件有两种储存数据的方式：&lt;code&gt;大端&lt;/code&gt;字节序（big endian）和&lt;code&gt;小端&lt;/code&gt;字节序（little endian）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大端字节序：高位字节在前，低位字节在后&lt;/li&gt;
&lt;li&gt;小端字节序：低位字节在前，高位字节在后&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;code&gt;0x1234567&lt;/code&gt; 的大端字节序和小端字节序的写法如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ruanyifeng.com/blogimg/asset/2016/bg2016112201.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;字节序的存在主要是因为计算机电路先处理低位字节，因为计算都是从低位开始的。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。&lt;/p&gt;
&lt;p&gt;Unicode 规范中推荐的标记字节顺序的方法是 &lt;code&gt;BOM&lt;/code&gt;（Byte Order Mark）。有一个叫做”零宽度非换行空格（ZERO WIDTH NO-BREAK SPACE）”的字符，它的编码是 &lt;code&gt;FEFF&lt;/code&gt;。而 &lt;code&gt;FFFE&lt;/code&gt; 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。Unicode 规范中定义每个文件的最前面加入这个零宽度非换行空格字符，如果一个文本文件的头两个字节是 &lt;code&gt;FE FF&lt;/code&gt;，就表示该文件采用大端方式；如果头两个字节是&lt;code&gt;FF FE&lt;/code&gt;，就表示该文件采用小端方式。&lt;/p&gt;
&lt;p&gt;需要清楚的是，&lt;strong&gt;不是所有的东西都有字节序&lt;/strong&gt;，而且字符序是以单字节为单位的顺序问题。&lt;/p&gt;
&lt;p&gt;前面提到 &lt;code&gt;Unicode&lt;/code&gt; 有多种字符编码实现方式，我们主要介绍 &lt;code&gt;UTF-8&lt;/code&gt; 与 &lt;code&gt;UCS-2&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;UTF-8&quot;&gt;&lt;a href=&quot;#UTF-8&quot; class=&quot;headerlink&quot; title=&quot;UTF-8&quot;&gt;&lt;/a&gt;UTF-8&lt;/h4&gt;&lt;p&gt;&lt;code&gt;UTF-8&lt;/code&gt; 作为最常见的 Unicode 实现方式，解决了前面提到的字符编码几大痛点。&lt;/p&gt;
&lt;p&gt; &lt;code&gt;UTF-8&lt;/code&gt; 编码是&lt;strong&gt;变长编码&lt;/strong&gt;，用 1 到 6 个字节编码，完全兼容 &lt;code&gt;ASCII&lt;/code&gt; 码，对于 ASCII 涵盖的那些字符，单字节实现，其余大多数为三字节实现。对于以英文为主的文本非常友好，最节省存储空间。缺点主要在于&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UTF-8&lt;/code&gt; 编码通过多个字节组合的方式来显示，这是计算机处理&lt;code&gt;UTF-8&lt;/code&gt; 的机制，它是无字节序之分的。&lt;/p&gt;
&lt;p&gt;UTF 家族还有 &lt;code&gt;UTF-16（双字节）&lt;/code&gt; 与 &lt;code&gt;UTF-32（四字节）&lt;/code&gt; 实现，两者都有字节序问题，前者更适合汉字编码但不支持单字节的 &lt;code&gt;ASCII&lt;/code&gt;，后者由于浪费储存空间很不常见，HTML5 中明确规定禁止使用 UTF-32 编码。&lt;/p&gt;
&lt;h4 id=&quot;UCS-2&quot;&gt;&lt;a href=&quot;#UCS-2&quot; class=&quot;headerlink&quot; title=&quot;UCS-2&quot;&gt;&lt;/a&gt;UCS-2&lt;/h4&gt;&lt;p&gt;JavaScript 设计之初，还没有出现 &lt;code&gt;UTF-16&lt;/code&gt;，因此采用的是 &lt;code&gt;USC-2&lt;/code&gt; 编码。前面提到 &lt;strong&gt;Unicode 的编码和 UCS 的编码都完全一致&lt;/strong&gt;。&lt;code&gt;UCS-2&lt;/code&gt; 是一种定长的编码方式，用两位字节来表示一位码位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UTF-16&lt;/code&gt; 可看成是 &lt;code&gt;UCS-2&lt;/code&gt; 的父集。在没有&lt;code&gt;辅助平面字符（surrogate code points）&lt;/code&gt;前，&lt;code&gt;UTF-16&lt;/code&gt; 与 &lt;code&gt;UCS-2&lt;/code&gt; 所指的是同一的意思。但当引入辅助平面字符后，就称为 &lt;code&gt;UTF-16&lt;/code&gt; 了。现在若有软件声称自己支持 &lt;code&gt;UCS-2&lt;/code&gt; 编码，那其实是暗指它不能支持在 &lt;code&gt;UTF-16&lt;/code&gt; 中超过 2 字节的字集。对于小于 &lt;code&gt;0x10000&lt;/code&gt; 的 &lt;code&gt;UCS&lt;/code&gt; 码，&lt;code&gt;UTF-16&lt;/code&gt; 编码就等于 &lt;code&gt;UCS&lt;/code&gt; 码。&lt;/p&gt;
&lt;p&gt;因此在 ES6 之前，JavaScript 对于超出 USC-2 的字符无法正确处理，会导致字符长度、正则匹配判断错误，使用字符串的 &lt;code&gt;charCodeAt()&lt;/code&gt; 与 &lt;code&gt;fromCharCode()&lt;/code&gt; 也无法正确识别字符与码点。&lt;/p&gt;
&lt;p&gt;ES6 新增了 &lt;code&gt;codePointAt()&lt;/code&gt; 与 &lt;code&gt;fromCodePoint()&lt;/code&gt; 方法以正确处理 32 位的 &lt;code&gt;UTF-16&lt;/code&gt; 字符之外的字符。&lt;/p&gt;
&lt;h3 id=&quot;Emoji&quot;&gt;&lt;a href=&quot;#Emoji&quot; class=&quot;headerlink&quot; title=&quot;Emoji&quot;&gt;&lt;/a&gt;Emoji&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;😂&#39;&lt;/span&gt;.length &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;1️⃣&#39;&lt;/span&gt;.length &lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;👨‍👨‍👦&#39;&lt;/span&gt;.length &lt;span class=&quot;comment&quot;&gt;// 8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;👨‍👩‍👧‍👦&#39;&lt;/span&gt;.length &lt;span class=&quot;comment&quot;&gt;// 11&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看起来就很刺激。&lt;/p&gt;
&lt;p&gt;随着 &lt;code&gt;Emoji&lt;/code&gt; 表情的流行，在开发中就不得不了解、考虑 &lt;code&gt;Emoji&lt;/code&gt; 字符了。否则最简单的 textarea 文本字数限制需求都难以正常完成。&lt;/p&gt;
&lt;p&gt;随着政治正确的发展，Emoji 现在是非常多元化了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/03/5b8d23bc27a4c.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/03/5b8d23bc4ed9b.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;肤色，职业，性别，取向，家庭组成都十分多元，基本覆盖了所有情况。&lt;/p&gt;
&lt;p&gt;其实在原先的基础 Emoji 字符上拓展出这些多元化字符并不难，通过码点组合就能实现。&lt;/p&gt;
&lt;p&gt;肤色修饰符： 🏻 🏼 🏽 🏾 🏿&lt;/p&gt;
&lt;p&gt;通过这几个肤色修饰符拼接到原有表情上，就可以实现肤色多元化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/03/5b8d21b17273c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;零宽字符 ZWJ(U+200D)&lt;/code&gt; 可以实现 family emoji，U+200D 相当于是一个连接符，连接家庭成员 emoji：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// family (man, woman, boy)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &#39;\u&amp;#123;1F468&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F469&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F466&amp;#125;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 👨‍ + &#39;\u&amp;#123;200D&amp;#125;&#39; + 👩‍ + &#39;\u&amp;#123;200D&amp;#125;&#39; + 👦&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// length: 8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; ‍👨‍👩‍👦&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// family (woman, woman, girl)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &#39;\u&amp;#123;1F469&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F469&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F467&amp;#125;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 👩‍ + &#39;\u&amp;#123;200D&amp;#125;&#39; + 👩‍ &#39;\u&amp;#123;200D&amp;#125;&#39; + 👧&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// length: 8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; ‍👩‍👩‍👧&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// family (woman, woman, girl, girl)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &#39;\u&amp;#123;1F469&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F469&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F467&amp;#125;&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;\u&amp;#123;1F467&amp;#125;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &#39;👩‍&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;👩‍&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39; + &#39;👧‍&#39; + &#39;\u&amp;#123;200D&amp;#125;&#39;+ 👧&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// length: 11&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; ‍👩‍👩‍👧‍👧&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因此，遇到文本有可能含有 Emoji 的情况中，需将 Emoji 字符正则匹配出来，单独进行计算。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;字符编码相关知识还有很多，本文仅介绍最近工作中所涉及的部分。更完善更准确的内容建议参考英文维基。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.thoughtco.com/what-is-unicode-2034272&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What Is Unicode?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;cenalulu.github.io/linux/character-encoding/&quot;&gt;十分钟搞清字符集和字符编码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41203455&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从 Unicode 到 emoji&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2016/11/byte-order.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;理解字节序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.dailymail.co.uk/i/pix/2016/10/27/21/39C8A74600000578-3879480-The_touch_bar_can_display_emotions_in_messaging_apps_playback_co-a-5_1477598860842.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为编程知识基础中的基础，有必要消化整理输出一次。&lt;/p&gt;
&lt;p&gt;本文主要介绍了字符编码的几个重要基础概念，从 &lt;code&gt;ASCII&lt;/code&gt; 到 &lt;code&gt;Unicode&lt;/code&gt; 再到 &lt;code&gt;Emoji&lt;/code&gt; 与 &lt;code&gt;JavaScript&lt;/code&gt; 字符处理的一些坑。&lt;/p&gt;
    
    </summary>
    
      <category term="cs" scheme="https://blog.colafornia.me/categories/cs/"/>
    
    
  </entry>
  
  <entry>
    <title>又双叒叕学习了一遍正则表达式</title>
    <link href="https://blog.colafornia.me/post/2018/learning-regex-again/"/>
    <id>https://blog.colafornia.me/post/2018/learning-regex-again/</id>
    <published>2018-07-11T12:00:00.000Z</published>
    <updated>2019-10-24T02:59:57.055Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/regex.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;正则表达式基本上每用到一次就得从头自学一次，用完了写出来了也就忘光了。&lt;/p&gt;
&lt;p&gt;前两天在 Twitter 上看到了题图，感觉又是个大坑，趁着手头还有 &lt;a href=&quot;https://caraws.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Caraws&lt;/a&gt; 给的书就又双叒叕学习了一遍正则表达式。&lt;/p&gt;
&lt;p&gt;本文试图先用最易懂的方式理顺正则表达式的知识点（就不贴一摞一摞的文档截图了，至于正则的使用场景和用处也不啰嗦了），主要介绍正则本身和在 JavaScript 中使用正则的坑。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;形如题图中的 &lt;code&gt;/abc/&lt;/code&gt; 就是一个最简单的正则表达式（regular expression），一般被称之为模式（pattern）。&lt;/p&gt;
&lt;p&gt;更具体一点的定义，正则表达式是用“正则表达式语言”来创建的，用于匹配和处理文本的字符串，它是内置于其它语言中的“迷你语言”。在不同语言中的正则表达式实现中，&lt;strong&gt;语法和功能可能会有一定差异&lt;/strong&gt;（后面我们会详细讲一下）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://regex101.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://regex101.com/&lt;/a&gt; 是一个在线练习网站，我们可以在界面上勾选不同的编程语言，也可以看到正则表达式的性能（匹配完成所需时间）以及具体的匹配步骤。&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;总结了一下，我觉得把正则中的语法符号分为四类比较容易记忆：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符与字符集&lt;/li&gt;
&lt;li&gt;预定义字符类&lt;/li&gt;
&lt;li&gt;重复次数&lt;/li&gt;
&lt;li&gt;功能字符（最后这种是我概括出来的名字）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;字符与字符集&quot;&gt;&lt;a href=&quot;#字符与字符集&quot; class=&quot;headerlink&quot; title=&quot;字符与字符集&quot;&gt;&lt;/a&gt;字符与字符集&lt;/h3&gt;&lt;p&gt;首先要分清&lt;code&gt;字符&lt;/code&gt;与&lt;code&gt;字符集&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/abc/&lt;/code&gt; 中的 a 匹配的是单个字符，这个模式就匹配的是三个字符，当文本是 ‘abcd’ 时会&lt;strong&gt;一次性匹配到字符串 ‘abc’&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而用 &lt;code&gt;[]&lt;/code&gt; &lt;strong&gt;字符集操作符&lt;/strong&gt;包裹起来的 &lt;code&gt;/[abc]/&lt;/code&gt; 就是一个字符集，&lt;code&gt;[abc]&lt;/code&gt; 匹配的是一个字符，表明匹配为 a 或 b 或 c 的一个字符。因此，当文本是 ‘abcd’ 时执行匹配，&lt;strong&gt;每次只能匹配到单个字符&lt;/strong&gt;，第一次匹配到 ‘a’，第二次匹配到’b’……&lt;/p&gt;
&lt;p&gt;区分这两个概念并不难，一般（我自己是）等到了各种表达式嵌套的时候就开始懵逼了。&lt;/p&gt;
&lt;p&gt;只能在字符集中使用的操作符有两个，&lt;code&gt;取非操作符^&lt;/code&gt; 与 &lt;code&gt;字符区间-&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在字符集中我们可以使用&lt;code&gt;取非操作符^&lt;/code&gt;，&lt;code&gt;/[^abc]/&lt;/code&gt;即为匹配 a，b，c 以外的任意字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/[a-c]/&lt;/code&gt; 与 &lt;code&gt;/[abc]/&lt;/code&gt; 相同，通过字符区间我们可以编写 &lt;code&gt;/[A-Za-z0-9]/&lt;/code&gt; 这种简洁易读的正则表达式了。&lt;/p&gt;
&lt;h3 id=&quot;预定义字符类&quot;&gt;&lt;a href=&quot;#预定义字符类&quot; class=&quot;headerlink&quot; title=&quot;预定义字符类&quot;&gt;&lt;/a&gt;预定义字符类&lt;/h3&gt;&lt;p&gt;正则表达式预定义了一些常用的术语来代表一类字符。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;\d&lt;/code&gt; 为任意数字，&lt;code&gt;\D&lt;/code&gt; 为任意非数字，更多预定义字符可以参看 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;重复次数&quot;&gt;&lt;a href=&quot;#重复次数&quot; class=&quot;headerlink&quot; title=&quot;重复次数&quot;&gt;&lt;/a&gt;重复次数&lt;/h3&gt;&lt;p&gt;以下符号跟在字符或者字符集的后面，代表重复次数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;：重复一次或多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;：重复零次或多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;：重复零次或一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{m, n}&lt;/code&gt;：可表示区间，或是至少 m 次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，除了 &lt;code&gt;?&lt;/code&gt; 之外的三种都是贪婪型字符，可能会发生&lt;strong&gt;过度匹配&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str=&lt;span class=&quot;string&quot;&gt;&#39;aacbacbc&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg=&lt;span class=&quot;regexp&quot;&gt;/a.*b/&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(str.match(reg)); &lt;span class=&quot;comment&quot;&gt;// [&quot;aacbacb&quot;, index:0...]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时执行一次匹配，由于 &lt;code&gt;*&lt;/code&gt; 作为贪婪型字符会尽可能匹配更多内容，因此匹配到的是 aacbacb，而不是 aacb。在贪婪型字符后面加上 &lt;code&gt;?&lt;/code&gt; 即变为非贪婪字符。&lt;/p&gt;
&lt;h3 id=&quot;功能字符&quot;&gt;&lt;a href=&quot;#功能字符&quot; class=&quot;headerlink&quot; title=&quot;功能字符&quot;&gt;&lt;/a&gt;功能字符&lt;/h3&gt;&lt;p&gt;举几个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正则尾部的  &lt;code&gt;/i&lt;/code&gt; 表示忽略大小写，&lt;code&gt;/g&lt;/code&gt; 表示匹配所有实例，&lt;code&gt;/m&lt;/code&gt; 多行匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;竖线符号 &lt;code&gt;|&lt;/code&gt; 表明“或”，&lt;code&gt;a|b&lt;/code&gt; 即匹配 a 或 b&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小括号 &lt;code&gt;()&lt;/code&gt; 可以用来分割子表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;^字符串$&lt;/code&gt; 代表字符串的前后边界&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进阶&quot;&gt;&lt;a href=&quot;#进阶&quot; class=&quot;headerlink&quot; title=&quot;进阶&quot;&gt;&lt;/a&gt;进阶&lt;/h2&gt;&lt;p&gt;以上介绍的都是基础语法与字符匹配规则，正则还有两种较为高级的使用语法。&lt;/p&gt;
&lt;h3 id=&quot;回溯引用-backreference&quot;&gt;&lt;a href=&quot;#回溯引用-backreference&quot; class=&quot;headerlink&quot; title=&quot;回溯引用 backreference&quot;&gt;&lt;/a&gt;回溯引用 backreference&lt;/h3&gt;&lt;p&gt;&lt;code&gt;回溯引用&lt;/code&gt;是指模式的后半部分引用在前半部分中定义的子表达式。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(x)&lt;/code&gt; 子表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt; 标识回溯引用，&lt;code&gt;\n&lt;/code&gt; 即代表第 n 个子表达式所匹配到的内容（在 replace 操作中使用 &lt;code&gt;$&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举一个典型例子，匹配 HTML 中的标题标签，HTML 可能如下：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;111&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;h4&lt;/span&gt;&amp;gt;&lt;/span&gt;lalala&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过 &lt;code&gt;/&amp;lt;[Hh][1-5]&amp;gt;.*?&amp;lt;\/[Hh][1-5]&amp;gt;/&lt;/code&gt; 我们会将 &lt;code&gt;&amp;lt;h4&amp;gt;lalala\&amp;lt;/h3&amp;gt;&lt;/code&gt; 这种非法标签也匹配到。回溯引用就适用于这种场景，它可以实现&lt;strong&gt;前后一致匹配&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/&amp;lt;([hH][1-5])&amp;gt;.*?&amp;lt;\/\1&amp;gt;/&lt;/code&gt; 中的 &lt;code&gt;\1&lt;/code&gt; 只匹配第一个子表达式 &lt;code&gt;([hH][1-5])&lt;/code&gt; 所匹配到的内容，从而避免匹配到对应不上的标签组合。&lt;/p&gt;
&lt;h3 id=&quot;前后查找-lookaround&quot;&gt;&lt;a href=&quot;#前后查找-lookaround&quot; class=&quot;headerlink&quot; title=&quot;前后查找 lookaround&quot;&gt;&lt;/a&gt;前后查找 lookaround&lt;/h3&gt;&lt;p&gt;还是引用上面的标题标签匹配例子，如果我们想只匹配到 &lt;code&gt;&amp;lt;h1&amp;gt;111&amp;lt;/h1&amp;gt;&lt;/code&gt; 中的标题内容要怎么写正则呢？&lt;/p&gt;
&lt;p&gt;这里涉及到两个新语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?=&lt;/code&gt;：向前查找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&amp;lt;=&lt;/code&gt;：向后查找&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以向前、向后查找开头的子表达式&lt;/strong&gt;就是前后查找。&lt;/p&gt;
&lt;p&gt;因此，正则可以为：&lt;code&gt;/(?&amp;lt;=&amp;lt;[Hh][1-5]&amp;gt;).*(?=&amp;lt;\/[Hh][1-5]&amp;gt;)/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结合回溯引用与前后查找，还可以实现条件式的正则表达式，威力爆炸，只是这种形式的正则太难读了，有兴趣可以 Google 学习一下，这里不讲了。&lt;/p&gt;
&lt;h2 id=&quot;高级&quot;&gt;&lt;a href=&quot;#高级&quot; class=&quot;headerlink&quot; title=&quot;高级&quot;&gt;&lt;/a&gt;高级&lt;/h2&gt;&lt;p&gt;以上是正则表达式的知识点，现在讲讲坑。首先说说 JavaScript 中的正则。&lt;/p&gt;
&lt;h3 id=&quot;字面量-VS-RegExp&quot;&gt;&lt;a href=&quot;#字面量-VS-RegExp&quot; class=&quot;headerlink&quot; title=&quot;字面量 VS RegExp()&quot;&gt;&lt;/a&gt;字面量 VS RegExp()&lt;/h3&gt;&lt;p&gt;在 JavaScript 中创建正则表达式有两种方式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 正则字面量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern1 = &lt;span class=&quot;regexp&quot;&gt;/\d+/&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 构造 RegExp 实例，以字符串形式传入正则&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\\d+&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两种方式创建出的正则没有任何差别。从创建方式上看，&lt;strong&gt;正则字面量可读性更优&lt;/strong&gt;，因为正则中经常使用 &lt;code&gt;\&lt;/code&gt; 反斜杠在字符串中是一个转义字符，想以字符串中表示反斜杠的话，需要使用 &lt;code&gt;\\&lt;/code&gt; 两个反斜杠。&lt;/p&gt;
&lt;p&gt;但是，需要注意，&lt;strong&gt;每个正则表达式都有一个独立的对象表示，每次创建正则表达式，都会为其创建一个新的正则表达式对象，这和其它类型（字符串、数组）不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;strong&gt;让正则表达式只编译一次并将其保存在一个变量中以供后续使用&lt;/strong&gt;来实现优化。&lt;/p&gt;
&lt;p&gt;因此，第一段代码将创建三个正则表达式对象，并进行了三次编译，虽然表达式是相同的。而第二段代码则性能更高。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;regexp&quot;&gt;/abc/&lt;/span&gt;.test(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;regexp&quot;&gt;/abc/&lt;/span&gt;.test(&lt;span class=&quot;string&quot;&gt;&#39;ab&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;regexp&quot;&gt;/abc/&lt;/span&gt;.test(&lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern = &lt;span class=&quot;regexp&quot;&gt;/abc/&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(pattern.test(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(pattern.test(&lt;span class=&quot;string&quot;&gt;&#39;ab&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(pattern.test(&lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这其中有&lt;strong&gt;性能隐患&lt;/strong&gt;。先记住这一点，我们继续往下看。&lt;/p&gt;
&lt;h3 id=&quot;冷知识-lastIndex&quot;&gt;&lt;a href=&quot;#冷知识-lastIndex&quot; class=&quot;headerlink&quot; title=&quot;冷知识 lastIndex&quot;&gt;&lt;/a&gt;冷知识 lastIndex&lt;/h3&gt;&lt;p&gt;这里我们来解释下题图中的情况是怎么回事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/regex.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;这其实是全局匹配的坑，也就是正则后的 &lt;code&gt;/g&lt;/code&gt; 符号。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern = &lt;span class=&quot;regexp&quot;&gt;/abc/g&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(pattern.global) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用 &lt;code&gt;/g&lt;/code&gt; 标识的正则作为全局匹配，也就拥有了 global 属性并导致了题图中呈现的异常行为。&lt;/p&gt;
&lt;p&gt;全局正则表达式的另一个属性 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lastIndex&lt;/a&gt; 用于存放上一次匹配文本之后的第一个字符的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RegExp.prototype.exec()&lt;/code&gt; 和 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; 方法都以 &lt;code&gt;lastIndex&lt;/code&gt; 属性中所存储的位置作为下次正则匹配检索的起点。连续调用这两个方法就可以遍历字符串中的所有匹配文本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastIndex&lt;/code&gt; 属性可读写，当 &lt;code&gt;RegExp.prototype.exec()&lt;/code&gt; 或 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; 再也找不到可以匹配的文本时，会自动把 lastIndex 属性重置为 0。因此&lt;strong&gt;使用这两个方法来检索文本，是可以无限执行下去的&lt;/strong&gt;。我们也就明白了题图中为何每次执行 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; 返回的结果都不一样。&lt;/p&gt;
&lt;p&gt;不仅如此，看看下面这段代码，能看出来有什么问题吗？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;regexp&quot;&gt;/a/g&lt;/span&gt;.test(&lt;span class=&quot;string&quot;&gt;&#39;ababc&#39;&lt;/span&gt;)) count++;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不要轻易拷贝到控制台中尝试，会把浏览器卡死的。&lt;/p&gt;
&lt;p&gt;由于每个循环中 &lt;code&gt;/a/g.test(&amp;#39;ababc&amp;#39;)&lt;/code&gt; 都创建了新的正则表达式对象，每次匹配都是重新开始，这一操作会无限执行下去，形成死循环。&lt;/p&gt;
&lt;p&gt;正确的写法是：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; regex = &lt;span class=&quot;regexp&quot;&gt;/a/g&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (regex.test(&lt;span class=&quot;string&quot;&gt;&#39;ababc&#39;&lt;/span&gt;)) count++;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，每次循环中操作的都是同一个正则表达式对象，随着每次匹配后 &lt;code&gt;lastIndex&lt;/code&gt; 的增加，等到将整个字符串匹配完成后，就跳出循环了。&lt;/p&gt;
&lt;p&gt;给以上知识点画个&lt;strong&gt;重点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将正则表达式保存到变量中，只在逻辑中使用这个变量，不仅性能更高，还安全。&lt;/li&gt;
&lt;li&gt;谨慎使用全局匹配，&lt;code&gt;RegExp.prototype.exec()&lt;/code&gt; 或 &lt;code&gt;RegExp.prototype.test()&lt;/code&gt;这两个方法的执行结果可能每次都不同。&lt;/li&gt;
&lt;li&gt;做到了以上两点后，还要谨慎在循环中使用正则匹配。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;回溯陷阱-Catastrophic-Backtracking&quot;&gt;&lt;a href=&quot;#回溯陷阱-Catastrophic-Backtracking&quot; class=&quot;headerlink&quot; title=&quot;回溯陷阱 Catastrophic Backtracking&quot;&gt;&lt;/a&gt;回溯陷阱 Catastrophic Backtracking&lt;/h3&gt;&lt;p&gt;回溯陷阱是正则表达式本身的一个坑了，会导致非常严重的性能问题，事故现场可以参看&lt;a href=&quot;https://juejin.im/post/5b287ea6f265da596d04a324&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《一个正则表达式引发的血案，让线上 CPU100% 异常！》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单介绍一下回溯陷阱的问题源头，正则引擎分为 &lt;code&gt;NFA（确定型有穷自动机）&lt;/code&gt; 和 &lt;code&gt;DFA（不确定型有穷自动机）&lt;/code&gt;，&lt;code&gt;DFA&lt;/code&gt; 是从匹配文本入手，同一个字符不会匹配两次（可以理解为手里捏着文本，挨个字符拿去匹配正则），时间复杂度是线性的，它的功能有限，不支持回溯。大多数编程语言选用的都是 &lt;code&gt;NFA&lt;/code&gt;，相当于手里拿着正则表达式，去匹配文本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/(a(bdc|cbd|bcd)/&lt;/code&gt; 中已经有三种匹配路径，在 &lt;code&gt;NFA&lt;/code&gt; 中，以文本 ‘abcd’ 为例，将花费 7 步才能匹配成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/01/V1wCPe.jpg&quot; alt=&quot;regex101&quot;&gt;&lt;br&gt;（图中还包括了字符边界的匹配步骤，因此多了三步）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;正则中的第一个字符 a 匹配到 ‘abcd’ 中的第一个字母 ‘a’，匹配成功。&lt;/li&gt;
&lt;li&gt;此时遇到了匹配路径的分叉口，bdc 或 cbd 或 bcd，先使用 bdc 来匹配。&lt;/li&gt;
&lt;li&gt;bdc 中的第一个字符 b 匹配到了 ‘abcd’ 中的第二个字母 ‘b’，匹配成功。&lt;/li&gt;
&lt;li&gt;bdc 中的第二个字符 d 与 ‘abcd’ 中的第三个字母 ‘c’ 不匹配，这条路径匹配失败，此时将发生回溯（backtrack），把 ‘b’ 还回去。选择第二条路径 cbd 进行匹配。&lt;/li&gt;
&lt;li&gt;cbd 的第一个字符 ‘c’ 就与 ‘b’ 匹配失败。开始第三条路径 bcd 的匹配。&lt;/li&gt;
&lt;li&gt;bcd 的第一个字符 ‘b’ 与文本 ‘b’ 匹配成功。&lt;/li&gt;
&lt;li&gt;bcd 的第一个字符 ‘c’ 与文本 ‘c’ 匹配成功。&lt;/li&gt;
&lt;li&gt;bcd 的第一个字符 ‘d’ 与文本 ‘d’ 匹配成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此匹配完成。&lt;/p&gt;
&lt;p&gt;可想而知，如果正则中再多一些匹配路径或者匹配本文再长一点，匹配步骤将多到难以控制。&lt;/p&gt;
&lt;p&gt;比如用 &lt;code&gt;/(a*)*bc/&lt;/code&gt; 来匹配 ‘aaaaaaaaaaaabc’ 都会导致性能问题，匹配文本中每增加一个 ‘a’，都会导致执行时间翻倍。&lt;/p&gt;
&lt;p&gt;禁止这种回溯陷阱的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;占有优先量词（Possessive Quantifiers）&lt;/li&gt;
&lt;li&gt;原子分组（Atomic Grouping）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可惜 &lt;strong&gt;JavaScript 不支持这两种语法&lt;/strong&gt;，有兴趣可以 Google 自行了解下。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中我们没有方法可以直接禁止回溯陷阱，我们只能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免量词嵌套 &lt;code&gt;(a*)* =&amp;gt; a*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;减少匹配路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，我们也可以把正则匹配放到 Service Worker 中进行，从而避免影响页面性能。&lt;/p&gt;
&lt;p&gt;查资料的时候发现，回溯陷阱不仅会导致性能问题，也有安全问题，有兴趣可以看看先知白帽大会上的&lt;a href=&quot;https://xianzhi.aliyun.com/forum/attachment/big_size/WAF%E6%98%AF%E6%97%B6%E5%80%99%E8%B7%9F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%B4%E5%86%8D%E8%A7%81.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《WAF是时候跟正则表达式说再见》&lt;/a&gt;分享。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26285406/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《正则表达式必知必会》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26638316/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《JavaScript 忍者秘籍》第七章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/regex.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;正则表达式基本上每用到一次就得从头自学一次，用完了写出来了也就忘光了。&lt;/p&gt;
&lt;p&gt;前两天在 Twitter 上看到了题图，感觉又是个大坑，趁着手头还有 &lt;a href=&quot;https://caraws.github.io/&quot;&gt;Caraws&lt;/a&gt; 给的书就又双叒叕学习了一遍正则表达式。&lt;/p&gt;
&lt;p&gt;本文试图先用最易懂的方式理顺正则表达式的知识点（就不贴一摞一摞的文档截图了，至于正则的使用场景和用处也不啰嗦了），主要介绍正则本身和在 JavaScript 中使用正则的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="regex javascript" scheme="https://blog.colafornia.me/categories/regex-javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器 GPU 动画优化与 Render Pipeline</title>
    <link href="https://blog.colafornia.me/post/2018/gpu-animation-render-pipeline/"/>
    <id>https://blog.colafornia.me/post/2018/gpu-animation-render-pipeline/</id>
    <published>2018-05-28T10:17:00.000Z</published>
    <updated>2019-10-24T02:22:04.200Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/render-pipeline-cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;上周在组里做了一个小的技术分享，本文是对这次分享内容的一个文字化梳理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/scarlett/e328aa2a7280812a89eced601d302f3418041.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个 Web 页面由代码最终转化为屏幕上的像素点，大致遵循图中的步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JS/CSS &amp;gt; 样式 &amp;gt; 布局 &amp;gt; 绘制 &amp;gt; 合成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;① 指由 JavaScript 和 CSS 编写的动画代码&lt;/p&gt;
&lt;p&gt;② 浏览器根据 CSS 选择器匹配计算（计算权重等）每个元素的最终样式&lt;/p&gt;
&lt;p&gt;③ 浏览器计算元素所占的空间大小及其在屏幕上的位置（由于元素会互相影响，计算布局这一步骤会经常发生）&lt;/p&gt;
&lt;p&gt;④ 在多个层上填充像素进行绘制，绘制每个元素的可视部分&lt;/p&gt;
&lt;p&gt;⑤ 合成，将上一步中绘制出的多个层，正确合成到页面上&lt;/p&gt;
&lt;p&gt;在之前的知识中，我们都知道，要正确使用、访问 CSS 属性，尽量少触发浏览器的 &lt;code&gt;重排重绘&lt;/code&gt;，从而提升动画性能。&lt;/p&gt;
&lt;p&gt;重排重绘指的是上述的③④步骤，本文主要探讨的是步骤⑤中的&lt;strong&gt;合成&lt;/strong&gt;相关的概念与优化手段。&lt;/p&gt;
&lt;h3 id=&quot;二、渲染基础概念&quot;&gt;&lt;a href=&quot;#二、渲染基础概念&quot; class=&quot;headerlink&quot; title=&quot;二、渲染基础概念&quot;&gt;&lt;/a&gt;二、渲染基础概念&lt;/h3&gt;&lt;p&gt;在研究浏览器的 Composite 步骤前，有几个渲染相关的概念必须了解。&lt;/p&gt;
&lt;p&gt;本文主要基于 Chrome 的内核 &lt;code&gt;Blink&lt;/code&gt; 的渲染概念描述。&lt;/p&gt;
&lt;h4 id=&quot;1-Blink&quot;&gt;&lt;a href=&quot;#1-Blink&quot; class=&quot;headerlink&quot; title=&quot;1.Blink&quot;&gt;&lt;/a&gt;1.Blink&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/scarlett/dc2500cbb537de8934117c2579ecad3227964.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此之前我一直以为 Chrome 的内核依然是 &lt;code&gt;Webkit&lt;/code&gt;，真是村通网。&lt;/p&gt;
&lt;p&gt;实际上 &lt;code&gt;Webkit&lt;/code&gt; 内核是苹果团队的开源作品，Chrome 在 2013 年之前一直基于其作为浏览器内核。直至 &lt;code&gt;Webkit2&lt;/code&gt; 与 &lt;code&gt;Chromium&lt;/code&gt; 的沙箱设计存在冲突，两方团队才决定分道扬镳。&lt;/p&gt;
&lt;p&gt;Google 团队从 Webkit 中 fork 出一份代码，将在 &lt;code&gt;WebKit&lt;/code&gt; 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 &lt;code&gt;WebKit&lt;/code&gt; 的影响，创造一个完全独立的 &lt;code&gt;Blink&lt;/code&gt;（据说删掉了 Webkit 中 880W 行代码）。&lt;/p&gt;
&lt;p&gt;由于此缘故，Blink 与 Webkit 对于渲染过程中的一些流程，术语并不完全相同，本文以 Blink 为准。&lt;/p&gt;
&lt;h4 id=&quot;2-RenderObject-与-RenderLayer&quot;&gt;&lt;a href=&quot;#2-RenderObject-与-RenderLayer&quot; class=&quot;headerlink&quot; title=&quot;2.RenderObject 与 RenderLayer&quot;&gt;&lt;/a&gt;2.RenderObject 与 RenderLayer&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/scarlett/aabc7b208641fdf392dfe9b855a109b576936.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器解析 HTML 文件生成 &lt;code&gt;DOM 树&lt;/code&gt;，然而 &lt;code&gt;DOM 树&lt;/code&gt;是不可以直接被用于排版的，内核还会再生成 &lt;code&gt;RenderObject 树&lt;/code&gt;。每一个可见的 DOM 节点都会生成相应的 RenderObject 节点。&lt;/p&gt;
&lt;p&gt;排版引擎经过 DOM 树与 CSS 定义对 Render 树进行排版，Render 树作为排版引擎的输出，渲染引擎的输入。&lt;/p&gt;
&lt;p&gt;拥有相同坐标空间的 RenderObject 属于同一渲染层（RenderLayer），RenderLayer 最初被用来实现&lt;code&gt;层叠上下文（stacking context）&lt;/code&gt;，以保证页面元素以正确顺序合成。&lt;/p&gt;
&lt;p&gt;生成 RenderLayer 与具备层叠上下文的条件是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/scarlett/85b3d7376bc7c693e872ca668bef980b232822.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-GraphicsLayer&quot;&gt;&lt;a href=&quot;#3-GraphicsLayer&quot; class=&quot;headerlink&quot; title=&quot;3.GraphicsLayer&quot;&gt;&lt;/a&gt;3.GraphicsLayer&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/scarlett/d48ec20953d86e41c8fb62bb6267690d38392.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;某些特殊的 &lt;code&gt;RenderLayer&lt;/code&gt; 渲染层会被认为是&lt;code&gt;合成层（Compositing Layers）&lt;/code&gt;，合成层拥有单独的 GraphicsLayer。这其实是浏览器为了提升动画性能做出的设计。&lt;/p&gt;
&lt;p&gt;为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层，合成层拥有单独的 &lt;code&gt;GraphicsLayer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个 &lt;code&gt;GraphicsLayer&lt;/code&gt; 即可，从而达到提升动画性能的目的。&lt;/p&gt;
&lt;p&gt;生成 GraphicsLayer 的条件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/scarlett/5855a920418f70e0e50f1b0438601e42168085.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、Render-Pipeline-渲染流水线&quot;&gt;&lt;a href=&quot;#三、Render-Pipeline-渲染流水线&quot; class=&quot;headerlink&quot; title=&quot;三、Render Pipeline 渲染流水线&quot;&gt;&lt;/a&gt;三、Render Pipeline 渲染流水线&lt;/h3&gt;&lt;p&gt;在了解了以上渲染概念后，我们可以来看看一个极简版的渲染流水线示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/scarlett/ff9a521cfb9093806a408fa2ba2a51c26992.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Blink 内核运行在主线程上，负责 JavaScript 的解析执行，HTML/CSS 解析，DOM 操作，排版，图层树的构建和更新等任务。&lt;/p&gt;
&lt;p&gt;Layer Compositor（图层合成器）运行在 Compositor 线程上，接收 Blink 的输入，负责图层树的管理。&lt;/p&gt;
&lt;p&gt;Display Compositor 接收 Layer Compositor 的输入，负责输出最终的 OpenGL 绘制指令，将网页内容通过 GL 绘制到显示屏上。&lt;/p&gt;
&lt;p&gt;将渲染流水线的内容按照线程做一下区分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p0.meituan.net/scarlett/f7537a196f23b0f1f6b7ed9d893fedea39673.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由此，Web 动画可以分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合成器动画：大多数基于 CSS 的动画，&lt;code&gt;transforms&lt;/code&gt; 和 &lt;code&gt;opacity&lt;/code&gt; 等都可以在合成线程中处理。&lt;/li&gt;
&lt;li&gt;非合成器动画：引起了绘制、布局的动画，&lt;code&gt;Timer&lt;/code&gt; 或者 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 等由 JavaScript 驱动的动画。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果浏览器在主线程上运行一些耗时的任务，合成器动画可以继续运行而不会中断&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;四、Web-动画优化建议&quot;&gt;&lt;a href=&quot;#四、Web-动画优化建议&quot; class=&quot;headerlink&quot; title=&quot;四、Web 动画优化建议&quot;&gt;&lt;/a&gt;四、Web 动画优化建议&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现代浏览器在完成以上四种属性的动画时，消耗成本较低。根本原因是这四种属性生成了自己的图形层（GraphicsLayer），开启了 &lt;code&gt;GPU 硬件加速&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;开启 GPU 硬件加速的方法主要有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;will-change&lt;/li&gt;
&lt;li&gt;transform: translateZ(0)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二种我们应该都不陌生，第一种是 CSS3 的属性，它会通知浏览器你打算更改元素的属性。浏览器会在你进行更改之前做最合适的优化。&lt;/p&gt;
&lt;p&gt;然而通过生成图形层（GraphicsLayer）的方式来进行性能优化却有个深坑 —— &lt;code&gt;隐式合成&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1.meituan.net/scarlett/4651555d9265a7d0280b038d501d31ac60552.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，a, b两个元素都具有 absolute 和 z-index 属性，其中 a 元素的 z-index 大于 b，因此 a 位于 b 图层之上。&lt;/p&gt;
&lt;p&gt;如果我们将 a 元素使用 left 属性，做一个移动动画，那么 a元素就有了一个合成层，动画得到了性能提升。&lt;/p&gt;
&lt;p&gt;那么，如果 a 静止不动，我们让 b 元素做动画呢？b 元素将拥有一个独立合成层；然后它们将被 GPU 合成。但是因为 a 元素要在 b 元素的上面（因为 a 元素的 z-index 比 b 元素高），那么浏览器会做什么？&lt;strong&gt;浏览器会将 a 元素也单独做一个合成层！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我们现在有三个合成层 a 元素所在的复合层、b 元素所在的合成层、其他内容及背景层。&lt;/p&gt;
&lt;p&gt;没有自己合成层的元素要出现在有合成层元素的上方，它就会拥有自己的复合层；这种情况被称为&lt;strong&gt;隐式合成&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GraphicsLayer 虽好，但不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的 GraphicsLayer ，并计算他们下一帧的重绘区域，所以过量的 GraphicsLayer 计算也会给渲染造成性能影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我们的最终结论是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽量保持让需要进行 CSS 动画的元素的 z-index 保持在页面最上&lt;/li&gt;
&lt;li&gt;有节制地优化，不要过早优化（不要滥用 will-change 等 GPU 加速手段）&lt;/li&gt;
&lt;li&gt;根据 Chrome Devtool 查看 GraphicsLayer 每层占用的内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;五、参考内容&quot;&gt;&lt;a href=&quot;#五、参考内容&quot; class=&quot;headerlink&quot; title=&quot;五、参考内容&quot;&gt;&lt;/a&gt;五、参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS GPU Animation: Doing It Right&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://taobaofed.org/blog/2016/04/25/performance-composite/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;无线性能优化：Composite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30534023&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;浏览器渲染流水线解析与网页动画性能优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/render-pipeline-cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;上周在组里做了一个小的技术分享，本文是对这次分享内容的一个文字化梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="render animation" scheme="https://blog.colafornia.me/categories/render-animation/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰者模式 =&gt; AOP =&gt; ES7 decorator =&gt; React 高阶组件</title>
    <link href="https://blog.colafornia.me/post/2018/from-decorator-to-hoc/"/>
    <id>https://blog.colafornia.me/post/2018/from-decorator-to-hoc/</id>
    <published>2018-05-19T08:56:00.000Z</published>
    <updated>2019-10-24T02:22:04.199Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*o6Q0MpSmQni2Q_sB5y9jig.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;五月是学习的好时节啊，翻翻书继续学习一下设计模式吧。&lt;/p&gt;
&lt;p&gt;该到&lt;code&gt;装饰者模式&lt;/code&gt;了。来，学习一下。&lt;/p&gt;
&lt;p&gt;书里的 &lt;code&gt;AOP&lt;/code&gt; 是啥？学习一下。&lt;/p&gt;
&lt;p&gt;新时代了再看看 ES7 规范的 &lt;code&gt;decorator&lt;/code&gt; 吧，学习一下。。&lt;/p&gt;
&lt;p&gt;啊还有 &lt;code&gt;React 高阶组件&lt;/code&gt;的事儿呢，都学到这了，不差这一会儿。。。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、装饰者模式是什么&quot;&gt;&lt;a href=&quot;#一、装饰者模式是什么&quot; class=&quot;headerlink&quot; title=&quot;一、装饰者模式是什么&quot;&gt;&lt;/a&gt;一、装饰者模式是什么&lt;/h3&gt;&lt;p&gt;先看一下最为精确的英文维基定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于传统的 OOP 语言来说，给对象(object)添加功能通常使用继承的方式，这不仅导致了超类与子类间的强耦合，也违反了&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单一职责原则&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。&lt;/p&gt;
&lt;h3 id=&quot;二、装饰者模式的典型应用：AOP&quot;&gt;&lt;a href=&quot;#二、装饰者模式的典型应用：AOP&quot; class=&quot;headerlink&quot; title=&quot;二、装饰者模式的典型应用：AOP&quot;&gt;&lt;/a&gt;二、装饰者模式的典型应用：AOP&lt;/h3&gt;&lt;p&gt;AOP 全称为 &lt;code&gt;Aspect-oriented programming&lt;/code&gt;，即&lt;code&gt;面向切面编程&lt;/code&gt;。主要适用于需要有横切逻辑的场景，比如数据上报，错误处理，鉴权，请求拦截等。&lt;/p&gt;
&lt;p&gt;理解这个概念之后，实际操作就并不复杂。可以通过在原型上设置 &lt;code&gt;Function.prototype.before&lt;/code&gt; 方法和 &lt;code&gt;Function.prototype.after&lt;/code&gt; 方法，实现 &lt;code&gt;AOP 装饰函数&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype.before = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;beforefn&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; __self = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    beforefn.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __self.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;.prototype.after = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;afterfn&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; __self = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = __self.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    afterfn.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两个装饰函数都接收函数作为参数，只是所接收参数的执行顺序不同。&lt;/p&gt;
&lt;p&gt;同理，我们也可以给 service 编写装饰函数，作为接口拦截器。如 &lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;axios&lt;/a&gt; 中的 &lt;code&gt;Interceptors&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 给请求添加拦截器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;axios.interceptors.request.use(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;config&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在发起请求前 do something&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; config;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 处理错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 给返回添加拦截器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;axios.interceptors.response.use(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 处理返回数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 处理错误&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，我们就可以在拦截器中统一处理错误与数据，不再需要在每一个 Promise 中都写一遍了，也便于统一项目中的处理方式。&lt;/p&gt;
&lt;p&gt;关于 AOP 简单介绍到这里。&lt;/p&gt;
&lt;h3 id=&quot;三、ES7-Decorator&quot;&gt;&lt;a href=&quot;#三、ES7-Decorator&quot; class=&quot;headerlink&quot; title=&quot;三、ES7 Decorator&quot;&gt;&lt;/a&gt;三、ES7 Decorator&lt;/h3&gt;&lt;p&gt;ES7 的 decorator 装饰器借鉴于 Python 的思想，由 Yehuda Katz 提出，这里有&lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;提案的细节设计与语法糖在 ES6/ES5 中的转换&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;定义非常简短：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Decorators make it possible to annotate and modify classes and properties at design time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;”装饰器可以让我们在设计时对类和类的属性进行注解和修改“&lt;/p&gt;
&lt;p&gt;有点抽象，我们先全盘了解这些讯息再来研究到底是怎么回事。&lt;/p&gt;
&lt;p&gt;想理解 &lt;code&gt;decorator&lt;/code&gt; 的用法，离不开 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Object.defineProperty&lt;/a&gt;，ES7 也正是利用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 实现装饰器特性。&lt;/p&gt;
&lt;h4 id=&quot;1-前置知识：Object-defineProperty&quot;&gt;&lt;a href=&quot;#1-前置知识：Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;1. 前置知识：Object.defineProperty&quot;&gt;&lt;/a&gt;1. 前置知识：Object.defineProperty&lt;/h4&gt;&lt;p&gt;如果了解过 Vue 双向绑定的实现原理，对 &lt;code&gt;Object.defineProperty&lt;/code&gt; 就一定不陌生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Object.defineProperty(obj, prop, descriptor)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以在对象上定义新属性，或修改已有属性，并将对象返回&lt;/p&gt;
&lt;p&gt;参数 &lt;code&gt;obj&lt;/code&gt;：要在其上添加或修改属性的对象&lt;/p&gt;
&lt;p&gt;参数 &lt;code&gt;prop&lt;/code&gt;：属性名&lt;/p&gt;
&lt;p&gt;参数 &lt;code&gt;descriptor&lt;/code&gt;：属性描述符，可以设置属性的数据属性与访问器属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 &lt;code&gt;descriptor&lt;/code&gt; 可设置的属性有：&lt;/p&gt;
&lt;p&gt;通用描述符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enumerable：Boolean，属性可否枚举&lt;/li&gt;
&lt;li&gt;configurable：Boolean，若为 false，任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据描述符 data descriptor：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;value：属性值&lt;/li&gt;
&lt;li&gt;writable：Boolean，是否可写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问器描述符 accessor descriptor：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get： 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。&lt;/li&gt;
&lt;li&gt;set：一旦目标属性被赋值，就会调回此方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（Vue 就是在 get 和 set 函数中进行了拦截，判断数据是否变化，发送通知到订阅器中，详情可参考&lt;a href=&quot;https://blog.colafornia.me/2017/03/14/observer-pattern-in-vue/&quot;&gt;《观察者模式以及在 Vue 源码中的实践》&lt;/a&gt;）&lt;/p&gt;
&lt;h4 id=&quot;2-ES7-Decorator-的用法&quot;&gt;&lt;a href=&quot;#2-ES7-Decorator-的用法&quot; class=&quot;headerlink&quot; title=&quot;2. ES7 Decorator 的用法&quot;&gt;&lt;/a&gt;2. ES7 Decorator 的用法&lt;/h4&gt;&lt;p&gt;ES7 Decorator 的使用场景不少，我们先看最简单典型的一个示例：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readonly&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  descriptor.writable = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; descriptor&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cat&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @readonly&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    say() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;喵&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; tom = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cat();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tom.say = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;汪&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tom.say()    &lt;span class=&quot;comment&quot;&gt;// 喵&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;readonly 就是一个 decorator 装饰器，它通过设置修饰符的 &lt;code&gt;writable&lt;/code&gt; 属性，使得被装饰的 &lt;code&gt;say()&lt;/code&gt; 只读。&lt;/p&gt;
&lt;p&gt;装饰器本身是一个函数，接受三个参数，target，name 和 descriptor。&lt;/p&gt;
&lt;p&gt;写一个 log 装饰器来看看这仨参数都是啥：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(target);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(target.hasOwnProperty(&lt;span class=&quot;string&quot;&gt;&#39;constructor&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(target.constructor);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(descriptor);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @log&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    bar() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; test = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Foo();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test.bar();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/decorator1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由此可以看出，target 就是被装饰的类本身，name 为被装饰的属性名，descriptor 与前述 Object.defineProperty 方法的属性描述符完全一样。&lt;/p&gt;
&lt;p&gt;这仅仅是作为类属性的装饰器而言。实际上 decorator 有两种使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装饰 Class，作为类装饰器&lt;/li&gt;
&lt;li&gt;装饰类的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为类装饰器时，由于类本身是一个函数，因此 decorator 仅有 &lt;code&gt;target&lt;/code&gt; 这一个参数。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;decorator 不能用于函数，因为存在函数提升&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;3-decorator-的使用场景&quot;&gt;&lt;a href=&quot;#3-decorator-的使用场景&quot; class=&quot;headerlink&quot; title=&quot;3. decorator 的使用场景&quot;&gt;&lt;/a&gt;3. decorator 的使用场景&lt;/h4&gt;&lt;p&gt;如前面所提到的 AOP 的用途，我们可以通过 decorator 实现横切逻辑，如日志上报，鉴权等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jayphelps/core-decorators/tree/master/src&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;core-decorators&lt;/a&gt; 中实现了一系列基础常用的装饰器，可以参考一下其中的实现。&lt;/p&gt;
&lt;p&gt;平时开发中难免遇到需要使用定时器的场景，于是：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  doSomething();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;遇到一个就得写一个，函数被包裹来包裹去，并不是很美观。可以编写一个简单的 &lt;code&gt;timeout&lt;/code&gt; 装饰器来重构：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timeout&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;milliseconds = 0&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt; target, key, descriptor &lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fn = descriptor.value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    descriptor.value = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fn.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;, milliseconds);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; descriptor;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Demo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  @timeout()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  doSomething() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  @timmeout(&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  doAnotherThing() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码结构清晰多了，装饰器也起到了注释的作用。&lt;/p&gt;
&lt;h4 id=&quot;4-decorator-在什么时候运行？&quot;&gt;&lt;a href=&quot;#4-decorator-在什么时候运行？&quot; class=&quot;headerlink&quot; title=&quot;4. decorator 在什么时候运行？&quot;&gt;&lt;/a&gt;4. decorator 在什么时候运行？&lt;/h4&gt;&lt;p&gt;尝试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;message&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(message);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;before class&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@log(&lt;span class=&quot;string&quot;&gt;&#39;class Bar&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Bar&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @log(&lt;span class=&quot;string&quot;&gt;&#39;class method bar&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    bar() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @log(&lt;span class=&quot;string&quot;&gt;&#39;class property foo&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    foo = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;after class&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bar = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    @log(&lt;span class=&quot;string&quot;&gt;&#39;object method bar&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    bar() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出结果：&lt;br&gt;&lt;img src=&quot;/images/decorator2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由此我们可以看出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器是在声明期就起效的，并不需要类进行实例化。&lt;/p&gt;
&lt;p&gt;类实例化并不会致使装饰器多次执行，因此不会对实例化带来额外的开销。&lt;/p&gt;
&lt;p&gt;按编码时的声明顺序执行，并不会将属性、方法、访问器进行重排序。&lt;/p&gt;
&lt;p&gt;因为以上这 2 个规则，我们需要特别注意一点，在装饰器运行时，你所能得到的环境是空的，在 Bar.prototype 或者 Bar 上的属性是获取不到的，也就是说整个 target 里其实只有 constructor 这一个属性。&lt;/p&gt;
&lt;p&gt;换句话说，装饰器运行时所有的属性和方法均未定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四、React-高阶组件&quot;&gt;&lt;a href=&quot;#四、React-高阶组件&quot; class=&quot;headerlink&quot; title=&quot;四、React 高阶组件&quot;&gt;&lt;/a&gt;四、React 高阶组件&lt;/h3&gt;&lt;p&gt;之所以会有&lt;code&gt;高阶组件 higher-order component(HOC)&lt;/code&gt;这个东西，主要是为了实现&lt;strong&gt;组件的抽象&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;1-Mixin&quot;&gt;&lt;a href=&quot;#1-Mixin&quot; class=&quot;headerlink&quot; title=&quot;1. Mixin&quot;&gt;&lt;/a&gt;1. Mixin&lt;/h4&gt;&lt;p&gt;想了解 HOC 干了啥，以及为啥需要它。依然要用 Vue 举例，Vue 的 &lt;code&gt;mixins&lt;/code&gt; 混入方法实现了组件的混入，借此我们可以将组件粒度切细，使得项目高度配置化。&lt;/p&gt;
&lt;p&gt;官网示例：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个混入对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myMixin = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  created: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.hello()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  methods: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    hello: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello from mixin!&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义一个使用混入对象的组件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Component = Vue.extend(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  mixins: [myMixin]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; component = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Component() &lt;span class=&quot;comment&quot;&gt;// =&amp;gt; &quot;hello from mixin!&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Vue 中的 mixin 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时&lt;strong&gt;以组件数据优先&lt;/strong&gt;。这也是实现 mixin 的重点逻辑。&lt;/p&gt;
&lt;p&gt;看看 &lt;code&gt;core-decorators&lt;/code&gt; 中 mixin 的核心实现：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; getOwnPropertyDescriptors &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./private/utils&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; defineProperty &amp;#125; = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleClass&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target, mixins&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!mixins.length) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;SyntaxError&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;`@mixin() class &lt;span class=&quot;subst&quot;&gt;$&amp;#123;target.name&amp;#125;&lt;/span&gt; requires at least one mixin as an argument`&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, l = mixins.length; i &amp;lt; l; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; descs = getOwnPropertyDescriptors(mixins[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; keys = getOwnKeys(descs);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, k = keys.length; j &amp;lt; k; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; key = keys[j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(hasProperty(key, target.prototype))) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        defineProperty(target.prototype, key, descs[key]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mixin&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...mixins&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; mixins[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; handleClass(mixins[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], []);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; target =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; handleClass(target, mixins);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中把待 mixin 对象的每个方法都叠加到了 target 对象的原型上。其中通过 &lt;code&gt;defineProperty&lt;/code&gt; 这个方法避免了覆盖 target 的原有属性。&lt;/p&gt;
&lt;p&gt;但是 mixin 有很多弊病，这也是为什么最后我们选择了高阶组件来实现组件的 compose。主要问题有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;破坏组件原有封装&lt;/strong&gt;：被 mixin 进来的组件都有自己的 props 和 state，导致在引入的时候需要千般小心，去维护那些我们不可见的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名冲突&lt;/strong&gt;：mixin 是一个平面结构，不同 mixin 中的命名不可知，譬如 &lt;code&gt;handleChange&lt;/code&gt; 这种常见名就很容易冲突，无形中增加了开发和维护成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此高阶组件应运而生。&lt;/p&gt;
&lt;h4 id=&quot;2-高阶组件&quot;&gt;&lt;a href=&quot;#2-高阶组件&quot; class=&quot;headerlink&quot; title=&quot;2. 高阶组件&quot;&gt;&lt;/a&gt;2. 高阶组件&lt;/h4&gt;&lt;p&gt;&lt;code&gt;高阶组件（higher-order component）&lt;/code&gt;的概念类似于&lt;code&gt;高阶函数&lt;/code&gt;，它接受 React 组件作为输入，输出一个新的 React 组件：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; EnhancedComponent = higherOrderComponent(WrappedComponent);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;先看一个最简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React, &amp;#123; Component &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; simpleHoc &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./simple-hoc&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Normal&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 可以做很多自定义逻辑&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props, &lt;span class=&quot;string&quot;&gt;&#39;props&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;lt;div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Usual&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; simpleHoc(Normal);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React, &amp;#123; Component &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; simpleHoc = WrappedComponent =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;im a hoc!&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;lt;WrappedComponent &amp;#123;...this.props&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;export default simpleHoc;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们所定义的 Normal 组件通过 simpleHoc 的包裹后输出的新组件后，在 Normal 本身的功能上可以多打一个 Log，并继承了 simpleHoc 的 props。这是最简单的一个例子啦，高阶组件做的事情也比较逊。我们继续看看~&lt;/p&gt;
&lt;p&gt;实现高阶组件的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性代理（&lt;code&gt;props proxy&lt;/code&gt;）：高阶组件通过 WrappedComponent 来操作 props&lt;/li&gt;
&lt;li&gt;反向代理（&lt;code&gt;inheritance inversion&lt;/code&gt;）：高阶组件继承于 WrappedComponent&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法的使用场景也各不相同。&lt;/p&gt;
&lt;h3 id=&quot;五、实现高阶组件的两种方法与使用场景&quot;&gt;&lt;a href=&quot;#五、实现高阶组件的两种方法与使用场景&quot; class=&quot;headerlink&quot; title=&quot;五、实现高阶组件的两种方法与使用场景&quot;&gt;&lt;/a&gt;五、实现高阶组件的两种方法与使用场景&lt;/h3&gt;&lt;h4 id=&quot;1-属性代理&quot;&gt;&lt;a href=&quot;#1-属性代理&quot; class=&quot;headerlink&quot; title=&quot;1. 属性代理&quot;&gt;&lt;/a&gt;1. 属性代理&lt;/h4&gt;&lt;p&gt;这是较为常见的一种方法，上面的 &lt;code&gt;simpleHoc&lt;/code&gt; 的实现其实就属于属性代理。&lt;strong&gt;通过高阶组件传递 props 的方法就是属性代理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作 &lt;code&gt;props&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Refs&lt;/code&gt; 访问到组件实例&lt;/li&gt;
&lt;li&gt;提取 &lt;code&gt;state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用其他元素包裹 &lt;code&gt;WrappedComponent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们主要介绍一下最常见的，操作 props。其它三种应用在网上也能找到具体例子，不赘述了（文章到这里感觉已经非常长了……）&lt;/p&gt;
&lt;p&gt;我们可以通过属性代理，来读取，编辑，增加或是删除 WrappedComponent 的 props。但应该注意小心编辑、删除重要的 props，尽量通过&lt;strong&gt;对高阶组件的 props 作新的命名来避免混淆&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHOC&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;WrappedComponent&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHoc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newProps = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        user: currentLoggedInUser&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;lt;WrappedComponent &amp;#123;...this.props&amp;#125; &amp;#123;...newProps&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，输出的新组件就可以通过 &lt;code&gt;this.props.user&lt;/code&gt; 来获得当前登录人的信息。&lt;/p&gt;
&lt;p&gt;使用的时候可以通过 decorator 来简化：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;@myHoc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyComponent&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  render() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; MyComponent;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-反向继承&quot;&gt;&lt;a href=&quot;#2-反向继承&quot; class=&quot;headerlink&quot; title=&quot;2. 反向继承&quot;&gt;&lt;/a&gt;2. 反向继承&lt;/h4&gt;&lt;p&gt;先看例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHOC&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;WrappedComponent&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHoc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WrappedComponent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.render()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;高阶组件返回的组件继承于 WrappedComponent，因此被称为 &lt;code&gt;Inheritance Inversion&lt;/code&gt; 反向继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向继承模式下的高阶组件可以通过 this 访问到 WrappedComponent 的 state、props、组件生命周期方法和 render 方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渲染劫持（&lt;code&gt;Render Highjacking&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;操作 &lt;code&gt;state&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;渲染劫持是指高阶组件可以控制 WrappedComponent 的渲染过程并修改渲染结果，这意味着可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在由 render &lt;strong&gt;输出&lt;/strong&gt;的任何 React 元素中读取、添加、编辑、删除 props&lt;/li&gt;
&lt;li&gt;读取和修改由 render 输出的 React 元素树&lt;/li&gt;
&lt;li&gt;有条件地渲染元素树&lt;/li&gt;
&lt;li&gt;把样式包裹进元素树（就像在 &lt;code&gt;Props Proxy&lt;/code&gt; 中的那样）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHOC&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;WrappedComponent&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Enhancer&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WrappedComponent&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.show) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.render()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面提到了高阶组件可以通过 this 访问到 WrappedComponent 的 state，可以对其进行编辑、删除，但这会使得 WrappedComponent 的内部状态混乱，难以维护，应避免这样使用。&lt;/p&gt;
&lt;p&gt;最后，我们来看下高阶组件与 Mixin 的区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/decorator3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;高阶组件更符合函数式编程思想，原组件不会感知到高阶组件的存在，最后我们所使用的都是一个新组件，从而避免了 Mixin 的那些弊病。&lt;/p&gt;
&lt;h3 id=&quot;五、参考内容&quot;&gt;&lt;a href=&quot;#五、参考内容&quot; class=&quot;headerlink&quot; title=&quot;五、参考内容&quot;&gt;&lt;/a&gt;五、参考内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26918038/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《深入React技术栈》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://efe.baidu.com/blog/introduction-to-es-decorator/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ES Decorators简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24776678&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入理解 React 高阶组件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*o6Q0MpSmQni2Q_sB5y9jig.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;五月是学习的好时节啊，翻翻书继续学习一下设计模式吧。&lt;/p&gt;
&lt;p&gt;该到&lt;code&gt;装饰者模式&lt;/code&gt;了。来，学习一下。&lt;/p&gt;
&lt;p&gt;书里的 &lt;code&gt;AOP&lt;/code&gt; 是啥？学习一下。&lt;/p&gt;
&lt;p&gt;新时代了再看看 ES7 规范的 &lt;code&gt;decorator&lt;/code&gt; 吧，学习一下。。&lt;/p&gt;
&lt;p&gt;啊还有 &lt;code&gt;React 高阶组件&lt;/code&gt;的事儿呢，都学到这了，不差这一会儿。。。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript react" scheme="https://blog.colafornia.me/categories/javascript-react/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 原理应知应会</title>
    <link href="https://blog.colafornia.me/post/2018/dive-into-git/"/>
    <id>https://blog.colafornia.me/post/2018/dive-into-git/</id>
    <published>2018-05-08T05:10:00.000Z</published>
    <updated>2019-10-24T02:22:04.197Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;初学编程时，Git 算是最令人心有余悸的 Boss 了，毕竟相比于写出 Bug 这种常见事情，把自己/别人代码弄丢这种事更为可怕。&lt;/p&gt;
&lt;p&gt;本文只介绍 Git 原理中最为硬核的部分，如果想把所有原理都探究明白，内容多到可以写本书。因此，本文只试图解答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Git 是怎么存储内容的？存到哪里了？&lt;/li&gt;
&lt;li&gt;工作区，暂存区，版本库，各种教程里这仨名词一看就晕，能说人话吗？&lt;/li&gt;
&lt;li&gt;git reset 来，git reset 去，感觉啥都能 reset，我到底在干啥？&lt;/li&gt;
&lt;li&gt;Git 快在哪里？大神都说 Git 好用，怎么还这么难学？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s go!&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、Git-简介&quot;&gt;&lt;a href=&quot;#一、Git-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Git 简介&quot;&gt;&lt;/a&gt;一、Git 简介&lt;/h3&gt;&lt;p&gt;首先回顾一下 Git 是什么，Git 是一个&lt;code&gt;分布式版本控制系统（Distributed Version Control System - DVCS）&lt;/code&gt;。由 Linux 之父 Linus Torvalds 用两周时间写出了第一个版本。经过十多年的发展，Git 的内部设计基本没有变化。&lt;/p&gt;
&lt;p&gt;它与先前流行的版本控制系统 &lt;code&gt;SVN&lt;/code&gt; 相比，区别在于，除了中央仓库，还有本地仓库。中央仓库仅负责同步团队代码，其它如查看历史，提交代码等操作可以在成员的本地仓库中进行。除此之外，SVN 存储的是版本间的文件差异，Git 存储的则是每一个版本的&lt;code&gt;快照&lt;/code&gt;，后面我们将详细说明。&lt;/p&gt;
&lt;h3 id=&quot;二、Git-文件系统&quot;&gt;&lt;a href=&quot;#二、Git-文件系统&quot; class=&quot;headerlink&quot; title=&quot;二、Git 文件系统&quot;&gt;&lt;/a&gt;二、Git 文件系统&lt;/h3&gt;&lt;p&gt;我们对于 Git 的使用，都是在使用命令，例如 &lt;code&gt;git add&lt;/code&gt;，&lt;code&gt;git commit&lt;/code&gt; 等，它们都属于 Git 的&lt;code&gt;高层命令&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;git help -a&lt;/code&gt; 查看所有的 Git 命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git1.jpg&quot; alt=&quot;dive-into-git1&quot;&gt;&lt;/p&gt;
&lt;p&gt;实际上，Git 有一百多个命令，其中&lt;code&gt;底层命令&lt;/code&gt;被设计为 Unix 风格，由脚本调用，并不常用。我们平时所使用的&lt;code&gt;高层命令&lt;/code&gt;设计的更为友好（可以理解为是被高度封装过的现成工具）。因此，想要了解 Git 原理就必须从&lt;code&gt;底层命令&lt;/code&gt;入手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yanhaijing.com/blog/464.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每当执行 &lt;code&gt;git init&lt;/code&gt; 时，Git 便会创建一个 &lt;code&gt;.git&lt;/code&gt; 目录，几乎 Git 所储存，操作的所有内容都在这个目录下（如果想拷贝一个 Git 仓库，拷贝这个目录即可）。了解 Git 原理也可以称为了解这个这个目录各部分是做什么的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git2.jpg&quot; alt=&quot;dive-into-git2&quot;&gt;&lt;br&gt;（图中是我的一个小项目的 &lt;code&gt;.git&lt;/code&gt; 目录）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指针 (HEAD, FETCH_HEAD, ORIG_HEAD)&lt;/li&gt;
&lt;li&gt;对象&lt;ul&gt;
&lt;li&gt;objects/（所有的对象，包括blob， tree， commit）&lt;/li&gt;
&lt;li&gt;refs/ （所有的引用）&lt;ul&gt;
&lt;li&gt;local branch&lt;/li&gt;
&lt;li&gt;remote branch&lt;/li&gt;
&lt;li&gt;tag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;index (索引)&lt;/li&gt;
&lt;li&gt;config (设置)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们来重点介绍一下 objects 和 refs 两个部分。&lt;/p&gt;
&lt;h4 id=&quot;1-objects&quot;&gt;&lt;a href=&quot;#1-objects&quot; class=&quot;headerlink&quot; title=&quot;1. objects&quot;&gt;&lt;/a&gt;1. objects&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git7.jpg&quot; alt=&quot;dive-into-git7&quot;&gt;&lt;br&gt;（刚初始化的项目，objects 目录下只有两个空文件夹）&lt;/p&gt;
&lt;p&gt;首先看一下最基本的部分，objects 目录，Git 所存储的数据都在这里。我们来看看 Git 到底是怎么存储内容的吧。&lt;/p&gt;
&lt;p&gt;前面提到了 Git 存储的是&lt;code&gt;快照&lt;/code&gt;，这实际上说的是 &lt;code&gt;SHA-1 哈希值&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Git 为每份内容生成一个文件，取得其 SHA-1 哈希值，用哈希值的前两个字符为名称创建子目录，用剩下 38 个字符为文件命名 (保存至子目录下)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来有点绕口，我们可以动手操作实验一下，通过底层命令 &lt;code&gt;hash-object&lt;/code&gt; 可以计算内容的 SHA-1 值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git3.jpg&quot; alt=&quot;dive-into-git3&quot;&gt;&lt;br&gt;字符串 hello git 的哈希结果是 &lt;code&gt;8d0e41234f24b6da002d962a26c2495ea16a425f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把这段字符串保存在一个文件中再计算 SHA-1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git4.jpg&quot; alt=&quot;dive-into-git4&quot;&gt;&lt;/p&gt;
&lt;p&gt;得到了一样的哈希值。&lt;/p&gt;
&lt;p&gt;改变一下文件的文本内容，哈希值则发生了改变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git5.jpg&quot; alt=&quot;dive-into-git5&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经知道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Git 由文件内容计算其哈希值&lt;/li&gt;
&lt;li&gt;哈希值相同则文件内容相同（即使我们将一个文件拷贝到不同目录下，Git 也仅存储一份内容）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们把 hello.txt 文件提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git8.jpg&quot; alt=&quot;dive-into-git8&quot;&gt;&lt;/p&gt;
&lt;p&gt;再看一下 objects 目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现多了三个文件夹！其中 8d 文件夹和子文件名加起来（&lt;code&gt;8d0e4123...&lt;/code&gt;）正好是字符串 hello git 的哈希结果。而 10 文件夹则是本次 commit 的哈希值。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;hash-object&lt;/code&gt; 命令之外，还有一个好用的底层命令 &lt;code&gt;cat-file&lt;/code&gt;，它可以将数据内容取回，传入 &lt;code&gt;-p&lt;/code&gt; 参数可以让该命令输出数据内容的类型。我们拿 commit 的哈希值试一试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git9.jpg&quot; alt=&quot;dive-into-git9&quot;&gt;&lt;br&gt;我们得到了 commit 对象，其中包含了本次提交的时间，commit message，提交者信息，以及一个类型为 &lt;code&gt;tree&lt;/code&gt; 的哈希值 07ed5a7。对其取值查看，发现了第三个哈希对象，类型为 blob，其哈希值为 hello.txt 内容的哈希值。&lt;/p&gt;
&lt;p&gt;三个哈希对象之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git10.jpg&quot; alt=&quot;dive-into-git10&quot;&gt;&lt;br&gt;在此，我们已经知道了三种 &lt;code&gt;Git 基本对象&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blob 对象：对单个文件的压缩存储&lt;/li&gt;
&lt;li&gt;Tree 对象：对文件目录树的存储&lt;/li&gt;
&lt;li&gt;Commit 对象：对 tree 对象的包装，带有其它提交信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此仓库中的一个常规项目结构，在 .git 中会存储为右图所示的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git12.jpg&quot; alt=&quot;dive-into-git12&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们再把 bye.txt 也提交了。可以发现新的 commit 哈希对象中还包含了 parent 信息，其值为上一个 commit 的哈希值。&lt;/p&gt;
&lt;p&gt;Git history 中的各个 commit 其实是一个&lt;code&gt;单向链表&lt;/code&gt;的结构，通过 parent 关联父节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git11.jpg&quot; alt=&quot;dive-into-git11&quot;&gt;&lt;br&gt;其中每个 commit 中都包含了当时仓库的目录结构与文件内容。这便是达成版本管理的基础。&lt;/p&gt;
&lt;h4 id=&quot;2-refs&quot;&gt;&lt;a href=&quot;#2-refs&quot; class=&quot;headerlink&quot; title=&quot;2. refs&quot;&gt;&lt;/a&gt;2. refs&lt;/h4&gt;&lt;p&gt;refs 目录存储了所有的引用文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git13.jpg&quot; alt=&quot;dive-into-git13&quot;&gt;&lt;br&gt;引用文件的内容也都是 40 位的 SHA-1 值。先看一下 master 是什么：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat .git/refs/heads/master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;哈希值为 &lt;code&gt;38779e1ee3e4959e21e599ad0974a2c915613d9e&lt;/code&gt;，就是第二次提交 commit 的哈希值。我们可以猜测，&lt;strong&gt;branch 其实就是 commit 的引用&lt;/strong&gt;。为了验证一下这个想法，我们新建一个分支试试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git14.jpg&quot; alt=&quot;dive-into-git14&quot;&gt;&lt;br&gt;可以发现，refs 目录中多了一个与新分支同名的文件，且其哈希值依然为第二次提交 commit 的哈希值。所以我们的猜想没错。&lt;/p&gt;
&lt;p&gt;但是当我们新建 new-branch 分支时，Git 是怎么知道最后一次提交的 SHA-1 值呢？答案就是 &lt;code&gt;HEAD 文件&lt;/code&gt;。&lt;strong&gt;&lt;code&gt;HEAD 文件&lt;/code&gt;是一个指向你当前所在分支的引用标识符&lt;/strong&gt;。也就是我们每次查找 log 时看到的 HEAD 标记：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git15.jpg&quot; alt=&quot;dive-into-git15&quot;&gt;&lt;/p&gt;
&lt;p&gt;介绍到这里，我们可以发现&lt;strong&gt;Git 中的引用是非常廉价的&lt;/strong&gt;，开新的 branch 和 tag 都只是多了一个引用文件，而有些中央式版本控制系统开分支时会复制一份内容，非常耗费资源。&lt;/p&gt;
&lt;p&gt;分支是一种移动的引用。而标签则是静止的引用。&lt;code&gt;.git/refs&lt;/code&gt; 目录下的 tags 目录就是保存标签信息的地方，标签同样也是 commit 对象的引用，只是它&lt;strong&gt;永远指向同一个 commit，不会变化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后一种引用类型是 &lt;code&gt;remote reference 远程引用&lt;/code&gt;，我们每次执行将提交 push 到远端后，&lt;code&gt;.git/refs/remotes/&lt;/code&gt; 目录下就会记录此次与远端通信的最后一个 commit 的哈希值。&lt;/p&gt;
&lt;p&gt;与 Git 的引用文件强相关的高层命令是 &lt;code&gt;git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&amp;lt;commit&amp;gt;]&lt;/code&gt;，虽然这个命令后面可以加很多参数，但实际上它们所操作的都是 &lt;code&gt;.git/refs/heads&lt;/code&gt; 目录下当前分支对应的引用文件。&lt;/p&gt;
&lt;h3 id=&quot;三、Git-暂存区&quot;&gt;&lt;a href=&quot;#三、Git-暂存区&quot; class=&quot;headerlink&quot; title=&quot;三、Git 暂存区&quot;&gt;&lt;/a&gt;三、Git 暂存区&lt;/h3&gt;&lt;p&gt;工作区，暂存区，版本库，这三个名词是我一开始看各种 Git 教程时最脑阔疼的东西，每次都要小心辨认，再心里默念一遍才分的清楚。其中工作区和版本库还好理解，&lt;code&gt;暂存区&lt;/code&gt; 是最为懵逼的一个概念。&lt;/p&gt;
&lt;p&gt;所以来看看 Git 暂存区到底是什么，为什么需要这个东西呢。&lt;/p&gt;
&lt;p&gt;在 .git 目录下中有一个 index 文件它与暂存区的概念相关，我们动手实验看看它是干啥的。就着前面的实验，我们继续操作一下，改一下 hello.txt 的内容，然后执行 &lt;code&gt;git checkout&lt;/code&gt; 撤销对这个文件的修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git16.jpg&quot; alt=&quot;dive-into-git16&quot;&gt;&lt;br&gt;撤销后工作区已经没有文件改动了，发现 &lt;code&gt;.git/index&lt;/code&gt;文件的时间戳是 17:02:00。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git17.jpg&quot; alt=&quot;dive-into-git17&quot;&gt;&lt;br&gt;再通过 &lt;code&gt;git status&lt;/code&gt; 看一下工作区状态，发现 &lt;code&gt;.git/index&lt;/code&gt; 文件的时间戳没有变化。&lt;/p&gt;
&lt;p&gt;我们用 Linux 命令 &lt;code&gt;touch&lt;/code&gt; 改一下 hello.txt 的时间戳再看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/dive-into-git/dive-into-git18.jpg&quot; alt=&quot;dive-into-git18&quot;&gt;&lt;br&gt;发现虽然文件没有变化，&lt;code&gt;.git/index&lt;/code&gt; 文件的时间戳却发生了改变。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是因为 &lt;code&gt;git status&lt;/code&gt; 命令查看工作区状态时，先根据 .git/index 文件中记录的时间戳，长度等信息判断工作区文件是否改变。如果时间戳变了，说明文件&lt;strong&gt;有可能&lt;/strong&gt;发生改变，Git 需要读取文件，与原始文件进行对比，去判断它是否发生变化。如果没有改变，则将文件新的时间戳记录到 .git/index 文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为判断文件是否更改，使用时间戳、文件长度等信息进行比较要比通过文件内容比较要快的多&lt;/strong&gt;，所以 Git 这样的实现方式可以让工作区状态扫描更快速的执行，这也是 Git 高效的因素之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;.git/index 文件实际上是一个包含文件索引的目录树，就是所谓的&lt;code&gt;暂存区&lt;/code&gt;&lt;/strong&gt;，它记录了文件的名称，时间戳，长度等信息，但并不储存文件，文件内容依然位于 &lt;code&gt;.git/objects&lt;/code&gt; 中。&lt;code&gt;.git/index&lt;/code&gt; 中的索引建立了文件和对象库中对象实体之间的对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.worldhello.net/wpfiles/2010/11/git-stage.png&quot; alt=&quot;index&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中版本库中的 index 区域就是暂存区，可以看到 index 区域与 master 区域其实都是对 objects 中存储的文件内容的索引。与先前了解到的一致，游标形状的 &lt;code&gt;HEAD&lt;/code&gt; 是一个指向当前所在分支的标识符。&lt;/p&gt;
&lt;p&gt;图中还列出了 Git 命令是如何影响工作区与暂存区的。值得注意的是 &lt;code&gt;git reset HEAD&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt; 有两种使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&amp;lt;commit&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset [-q] [&amp;lt;commit&amp;gt;] [--] &amp;lt;paths&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在前面我们了解到第一种使用方法实际上是改变了引用文件。 git reset 的第二种使用方法并不会改变引用，它会用已经 commit 到版本库的文件替换掉暂存区中的文件。因此，&lt;code&gt;git reset HEAD &amp;lt;paths&amp;gt;&lt;/code&gt; 就是取消之前执行 &lt;code&gt;git commit &amp;lt;paths&amp;gt;&lt;/code&gt; 时所改变的暂存区。&lt;/p&gt;
&lt;h3 id=&quot;四、Git-的痛点&quot;&gt;&lt;a href=&quot;#四、Git-的痛点&quot; class=&quot;headerlink&quot; title=&quot;四、Git 的痛点&quot;&gt;&lt;/a&gt;四、Git 的痛点&lt;/h3&gt;&lt;p&gt;粗浅地了解了以上原理之后，对于 Git 的痛点也可以窥知一二。&lt;/p&gt;
&lt;p&gt;Git 的诞生经历和 JavaScript 有些相似，都是短时间内打造的兵器，其设计思路一开始就是很粗糙的，甚至有些不合理反人类的地方。（但是 JavaScript 还有 ECMAScript 一年一年的修补，Git 却没啥指望改进了……）&lt;/p&gt;
&lt;p&gt;最明显的一个痛点是，一个 Git 命令身兼数职的情况非常多（git rebase，git reset，git checkout 是重灾区），这也是造成新手入门时每天一脸懵逼的一个主要原因。&lt;/p&gt;
&lt;p&gt;Git 本身的设计理念是非常清晰明确的，如果可以重新设计的话，希望指令可以与其设计思路统一，指令分为四类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;操作当前指针&lt;/li&gt;
&lt;li&gt;操作分支&lt;/li&gt;
&lt;li&gt;操作版本&lt;/li&gt;
&lt;li&gt;操作工作环境&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一篇论文&lt;a href=&quot;https://groups.csail.mit.edu/sdg/pubs/2016/gitless-oopsla16.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Purposes, Concepts, Misfits, and a Redesign of Git》&lt;/a&gt;专门分析 Git 的设计问题。最后设计了一款新工具叫 Gitless。&lt;/p&gt;
&lt;p&gt;除了这一点之外，由于 Git 存储的是文件快照，如果项目需要频繁修改大文件的话很容易造成存储库的膨胀，这一点虽然有&lt;a href=&quot;https://blog.colafornia.me/2018/03/09/slove-git-clone-speed/&quot;&gt;解决方案&lt;/a&gt;，但不可否认依然是其痛点之一。&lt;/p&gt;
&lt;h3 id=&quot;五、最后&quot;&gt;&lt;a href=&quot;#五、最后&quot; class=&quot;headerlink&quot; title=&quot;五、最后&quot;&gt;&lt;/a&gt;五、最后&lt;/h3&gt;&lt;p&gt;除了以上介绍到的内容，git rebase，git reflog，git checkout，git cherry-pick 也都是值得探究的命令。&lt;/p&gt;
&lt;h4 id=&quot;参考内容：&quot;&gt;&lt;a href=&quot;#参考内容：&quot; class=&quot;headerlink&quot; title=&quot;参考内容：&quot;&gt;&lt;/a&gt;参考内容：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git Internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gotgit.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git 权威指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yanhaijing.com/git/2017/02/08/deep-git-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;起底Git-Git内部原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/dive-into-git/cover.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;初学编程时，Git 算是最令人心有余悸的 Boss 了，毕竟相比于写出 Bug 这种常见事情，把自己/别人代码弄丢这种事更为可怕。&lt;/p&gt;
&lt;p&gt;本文只介绍 Git 原理中最为硬核的部分，如果想把所有原理都探究明白，内容多到可以写本书。因此，本文只试图解答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Git 是怎么存储内容的？存到哪里了？&lt;/li&gt;
&lt;li&gt;工作区，暂存区，版本库，各种教程里这仨名词一看就晕，能说人话吗？&lt;/li&gt;
&lt;li&gt;git reset 来，git reset 去，感觉啥都能 reset，我到底在干啥？&lt;/li&gt;
&lt;li&gt;Git 快在哪里？大神都说 Git 好用，怎么还这么难学？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s go!&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://blog.colafornia.me/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Thrift 速记</title>
    <link href="https://blog.colafornia.me/post/2018/thrift-note/"/>
    <id>https://blog.colafornia.me/post/2018/thrift-note/</id>
    <published>2018-03-27T03:11:00.000Z</published>
    <updated>2019-10-24T02:22:04.206Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Apache Thrift&lt;/code&gt; 是一款 &lt;code&gt;RPC&lt;/code&gt; (跨语言的服务)框架，传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/thrift.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;RPC-是什么&quot;&gt;&lt;a href=&quot;#RPC-是什么&quot; class=&quot;headerlink&quot; title=&quot;RPC 是什么&quot;&gt;&lt;/a&gt;RPC 是什么&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Remote Procedure Call&lt;/code&gt; 即远程过程调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RPC 是一个 &lt;code&gt;计算机通信协议&lt;/code&gt;。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 —— 中文维基&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。&lt;/p&gt;
&lt;p&gt;标准化的 RPC 大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。&lt;/p&gt;
&lt;p&gt;相比于 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/09/restful&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RESTful&lt;/a&gt;，RPC 的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用二进制的传输格式，相比于 RESTful 采用的 JSON 格式体积更小速度更快&lt;/li&gt;
&lt;li&gt;支持多种传输协议与传输格式&lt;/li&gt;
&lt;li&gt;支持同步和异步通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Thrift-文件概览&quot;&gt;&lt;a href=&quot;#Thrift-文件概览&quot; class=&quot;headerlink&quot; title=&quot;Thrift 文件概览&quot;&gt;&lt;/a&gt;Thrift 文件概览&lt;/h3&gt;&lt;p&gt;以 &lt;code&gt;.thrift&lt;/code&gt; 为后缀的文件，是服务消费方（Consumer）与服务提供方（Provider）之间用来进行接口描述（IDL）的文件。&lt;/p&gt;
&lt;h4 id=&quot;1-代码示例：&quot;&gt;&lt;a href=&quot;#1-代码示例：&quot; class=&quot;headerlink&quot; title=&quot;1.代码示例：&quot;&gt;&lt;/a&gt;1.代码示例：&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// thrift 文件一般包含两部分的内容&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1) 类型说明，类似于前后端所约定的请求对象有哪些字段值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2) 接口服务 Service 说明，包含一系列的方法，类似于前后端之间约定的请求方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// IDL 中可以定义以下一些类型：基本数据类型，结构体，容器，异常、服务&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下 IDL 定义了一个叫 Sample 的服务，其有一个叫 getOrderById 的方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;struct Order &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:i64 id;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:i32 status;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;service Sample&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Order &lt;span class=&quot;title&quot;&gt;getOrderById&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:i64 id)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-基本类型：&quot;&gt;&lt;a href=&quot;#2-基本类型：&quot; class=&quot;headerlink&quot; title=&quot;2.基本类型：&quot;&gt;&lt;/a&gt;2.基本类型：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;bool&lt;/code&gt;: 布尔类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;byte&lt;/code&gt;: 有符号字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;i16/i32/i64&lt;/code&gt;: 16/32/64位有符号整型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;double&lt;/code&gt;: 64位浮点数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;: 未知编码或者二进制的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-容器：&quot;&gt;&lt;a href=&quot;#3-容器：&quot; class=&quot;headerlink&quot; title=&quot;3.容器：&quot;&gt;&lt;/a&gt;3.容器：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;list&amp;lt;t1&amp;gt;&lt;/code&gt;: 排序数组，可以重复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;set&amp;lt;t1&amp;gt;&lt;/code&gt;: 集合，每个元素唯一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;map&amp;lt;t1, t2&amp;gt;&lt;/code&gt;: key/value 键值对（key 的类型是 t1且 key 唯一，value 类型是 t2）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-通过-IDL-文件生成代码&quot;&gt;&lt;a href=&quot;#4-通过-IDL-文件生成代码&quot; class=&quot;headerlink&quot; title=&quot;4.通过 IDL 文件生成代码&quot;&gt;&lt;/a&gt;4.通过 IDL 文件生成代码&lt;/h4&gt;&lt;p&gt;通过 IDL 一般生成两种类型的文件，1）类型文件 2）接口文件&lt;/p&gt;
&lt;p&gt;形如 &lt;code&gt;xxx_types.js&lt;/code&gt; 即是将 IDL 文件中的类型说明输出为类型文件。&lt;/p&gt;
&lt;p&gt;形如 &lt;code&gt;xxxService.js&lt;/code&gt; 即是接口文件，服务消费方通过接口文件来创建和 Provider 的连接。&lt;/p&gt;
&lt;p&gt;在通信的过程中，thrift 会对数据进行序列化后传递给另一方，在接收方则对数据进行反序列化后映射成对应的语言对象。于是，我们就可以不关心数据格式和类型转换，直接调用远程服务了。&lt;/p&gt;
&lt;h3 id=&quot;Node-Thrift-应用&quot;&gt;&lt;a href=&quot;#Node-Thrift-应用&quot; class=&quot;headerlink&quot; title=&quot;Node Thrift 应用&quot;&gt;&lt;/a&gt;Node Thrift 应用&lt;/h3&gt;&lt;h4 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h4&gt;&lt;p&gt;除了&lt;a href=&quot;http://thrift.apache.org/docs/install/os_x&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网下载&lt;/a&gt;，Mac 下比较方便的安装方式是使用 homebrew：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brew install thrift&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-生成代码&quot;&gt;&lt;a href=&quot;#2-生成代码&quot; class=&quot;headerlink&quot; title=&quot;2.生成代码&quot;&gt;&lt;/a&gt;2.生成代码&lt;/h4&gt;&lt;p&gt;语法为 &lt;code&gt;thrift --gen &amp;lt;language&amp;gt; &amp;lt;Thrift filename&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成 Node.js 代码的话：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;thrift --gen js:node Service.thrift&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在实际项目中一般会封装多个 shell 脚本来做这件事，方便维护与使用。&lt;/p&gt;
&lt;h4 id=&quot;3-使用&quot;&gt;&lt;a href=&quot;#3-使用&quot; class=&quot;headerlink&quot; title=&quot;3.使用&quot;&gt;&lt;/a&gt;3.使用&lt;/h4&gt;&lt;p&gt;Apache 已经推出了 &lt;a href=&quot;http://thrift.apache.org/tutorial/nodejs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方的 Node.js 库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Client:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 此示例代码大致浏览即可&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; thrift = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;thrift&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Calculator = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./gen-nodejs/Calculator&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ttypes = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./gen-nodejs/tutorial_types&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; assert = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;assert&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; transport = thrift.TBufferedTransport;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; protocol = thrift.TBinaryProtocol;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; connection = thrift.createConnection(&lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9090&lt;/span&gt;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  transport : transport,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  protocol : protocol&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connection.on(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  assert(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;, err);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create a Calculator client with the connection&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; client = thrift.createClient(Calculator, connection);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;client.ping(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;ping()&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;client.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;1+1=&quot;&lt;/span&gt; + response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，就可以调用其它语言编写的服务了。&lt;/p&gt;
&lt;p&gt;公司内部有一个封装好了连接过程的 thrift 包，使用起来更简单些，把端口号，ip 等信息传进去即可使用。&lt;/p&gt;
&lt;p&gt;更多语言和使用示例可参考 &lt;a href=&quot;http://thrift-tutorial.readthedocs.io/en/latest/usage-example.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;thrift-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;微服务概览&quot;&gt;&lt;a href=&quot;#微服务概览&quot; class=&quot;headerlink&quot; title=&quot;微服务概览&quot;&gt;&lt;/a&gt;微服务概览&lt;/h3&gt;&lt;p&gt;一直以来都是使用 HTTP 协议进行接口调用，只知道有一些“后端之间的服务调用”是使用 Thrift 接口，没有想过前端项目中也会直接调用。&lt;/p&gt;
&lt;p&gt;之所以会用到 Thrift，是因为公司采用的是“面向服务的架构”，我们所开发的 Web 应用也是一个服务，其中还会依赖其它服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SOA（Service-Oriented Architecture，面向服务的架构）&lt;/code&gt;是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。&lt;/p&gt;
&lt;p&gt;微服务架构是 SOA 的一种特定方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-3-microservices.png&quot; alt=&quot;microservices&quot;&gt;&lt;/p&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://book.douban.com/subject/26772677/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《微服务设计》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Apache Thrift&lt;/code&gt; 是一款 &lt;code&gt;RPC&lt;/code&gt; (跨语言的服务)框架，传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/thrift.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;RPC-是什么&quot;&gt;&lt;a href=&quot;#RPC-是什么&quot; class=&quot;headerlink&quot; title=&quot;RPC 是什么&quot;&gt;&lt;/a&gt;RPC 是什么&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Remote Procedure Call&lt;/code&gt; 即远程过程调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RPC 是一个 &lt;code&gt;计算机通信协议&lt;/code&gt;。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 —— 中文维基&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="thrift" scheme="https://blog.colafornia.me/categories/thrift/"/>
    
    
  </entry>
  
  <entry>
    <title>解决 git clone 慢的问题</title>
    <link href="https://blog.colafornia.me/post/2018/slove-git-clone-speed/"/>
    <id>https://blog.colafornia.me/post/2018/slove-git-clone-speed/</id>
    <published>2018-03-09T08:20:00.000Z</published>
    <updated>2019-10-24T02:22:04.205Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/2018-3-git.png&quot; alt=&quot;git-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;年后这段时间连续遇到了两次 git clone 龟速缓慢，一天之内都 clone 不下来的问题。这里记录一下解决方法和原理。&lt;/p&gt;
&lt;p&gt;git clone 太慢的常规原因有两种，&lt;strong&gt;第一种是 git 仓库本身导致的，第二种是我们使用者的网络问题&lt;/strong&gt;。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、Git-仓库体积太大&quot;&gt;&lt;a href=&quot;#一、Git-仓库体积太大&quot; class=&quot;headerlink&quot; title=&quot;一、Git 仓库体积太大&quot;&gt;&lt;/a&gt;一、Git 仓库体积太大&lt;/h2&gt;&lt;p&gt;大体积 Git 仓库一般也有两种，一是 commit 历史长，协作分支多导致的仓库自身体积变大，二是有过多的二进制文件。&lt;/p&gt;
&lt;h4 id=&quot;1-commit-历史长，协作分支多导致的仓库自身体积变大&quot;&gt;&lt;a href=&quot;#1-commit-历史长，协作分支多导致的仓库自身体积变大&quot; class=&quot;headerlink&quot; title=&quot;1. commit 历史长，协作分支多导致的仓库自身体积变大&quot;&gt;&lt;/a&gt;1. commit 历史长，协作分支多导致的仓库自身体积变大&lt;/h4&gt;&lt;p&gt;Git 会把文件的每一个差异化版本都存储起来，随着 commit 越来越多，每一次小的修改 Git 都会存储一个新的快照，自然版本库体积也会越来越大。&lt;/p&gt;
&lt;h5 id=&quot;①-浅克隆-shallow-clone&quot;&gt;&lt;a href=&quot;#①-浅克隆-shallow-clone&quot; class=&quot;headerlink&quot; title=&quot;① 浅克隆 shallow clone&quot;&gt;&lt;/a&gt;① 浅克隆 shallow clone&lt;/h5&gt;&lt;p&gt;&lt;code&gt;git clone --depth n git://someserver/somerepo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很多时候我们只对版本库的最近几次提交感兴趣，就可以通过 shallow clone 仅仅克隆最新的 n 条记录到本地，节省了非常多的时间。这种方法适用于当我们想对查看研究某远端库时使用，如果想在浅克隆的库上推送提交，会有一些限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过浅克隆方式克隆出来的版本库，每一个提交的 SHA1 哈希值和源版本库的相同，包括提交的根节点也是如次，但是 git 通过特殊的实现，使得浅克隆的根节点提交看起来没有父提交。正因为浅克隆的提交对象的 SHA1 哈希值和源版本库一致，所以浅克隆版本库可以执行 git fetch 或者 git pull 从源版本库获取新的提交。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;②-只-clone-一个分支&quot;&gt;&lt;a href=&quot;#②-只-clone-一个分支&quot; class=&quot;headerlink&quot; title=&quot;② 只 clone 一个分支&quot;&gt;&lt;/a&gt;② 只 clone 一个分支&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git clone URL --branch branch_name --single-branch [folder]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般可以指定只 clone master 分支到本地，同样了节省了很多时间。&lt;/p&gt;
&lt;h4 id=&quot;2-有过多的二进制文件&quot;&gt;&lt;a href=&quot;#2-有过多的二进制文件&quot; class=&quot;headerlink&quot; title=&quot;2. 有过多的二进制文件&quot;&gt;&lt;/a&gt;2. 有过多的二进制文件&lt;/h4&gt;&lt;p&gt;Git 主要适用于对文本文件进行版本控制，并不能很好地处理二进制文件的增量提交，每次更新一个二进制文件就会把这份文件的完整内容存储一份，随着更新修改越来越多，版本库的体积也会非常大，影响代码的拉取速度（这应该也是游戏团队主要还在使用 SVN 的原因）。&lt;/p&gt;
&lt;p&gt;这种情况较少会发生在前端项目仓库中，针对这种原因造成的 git clone 慢依然可以通过上面两种方法来节省克隆时间，除此之外在此简单介绍一下&lt;strong&gt;如何解决由于二进制文件造成的版本库体积过大问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;①-稀疏检出-sparse-checkout&quot;&gt;&lt;a href=&quot;#①-稀疏检出-sparse-checkout&quot; class=&quot;headerlink&quot; title=&quot;① 稀疏检出 sparse checkout&quot;&gt;&lt;/a&gt;① 稀疏检出 sparse checkout&lt;/h4&gt;&lt;p&gt;通过 Git 在 1.7.0 版本之后提供的稀疏检出功能，可以设置只 checkout 出自己想要的内容。此时就可以通过它来跳过二进制文件。Worktree 中就只有我们指定检出的文件了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git config core.sparseCheckout true // 开启稀疏检出功能&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;path1/&amp;quot; &amp;gt;&amp;gt; .git/info/sparse-checkout // 指定检出路径&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;原理是 git 在暂存区为每个文件提供一个名为 &lt;code&gt;skip-worktree&lt;/code&gt; 标识位，如果标识位开启则无论工作区对应的文件存在与否，是否被修改，git 都认为该文件的版本是最新的，没有变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;②-大文件储存-Git-LFS&quot;&gt;&lt;a href=&quot;#②-大文件储存-Git-LFS&quot; class=&quot;headerlink&quot; title=&quot;② 大文件储存 Git LFS&quot;&gt;&lt;/a&gt;② 大文件储存 Git LFS&lt;/h4&gt;&lt;p&gt;Github 和 Gitlab 目前都已经使用 &lt;a href=&quot;https://git-lfs.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git LFS&lt;/a&gt; 来支持二进制大文件的版本控制，将二进制文件存在版本库之外，在版本库内使用文本指针来代替。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-lfs.github.com/images/facebook-promo.png&quot; alt=&quot;Git LFS&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、网络被墙&quot;&gt;&lt;a href=&quot;#二、网络被墙&quot; class=&quot;headerlink&quot; title=&quot;二、网络被墙&quot;&gt;&lt;/a&gt;二、网络被墙&lt;/h2&gt;&lt;p&gt;我这两次遇到的问题其实都是网络问题。春节前后辽宁那边的网络都是这个状况，年后回来我司的网络也被 github 墙了。这里介绍一下给 Git 设置代理的方法。&lt;/p&gt;
&lt;p&gt;git clone 有两种协议可供选择：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git-clone-shot.jpeg&quot; alt=&quot;git clone&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里介绍的是针对 HTTPS 协议的代理。&lt;/p&gt;
&lt;p&gt;首先来看一下自己的 SS 代理设置 socks5 监听端口是多少，比如我的端口就是1086：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ss.jpeg&quot; alt=&quot;ss&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git config --global http.https://github.com.proxy socks5://127.0.0.1:1086&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git config --global https.https://github.com.proxy socks5://127.0.0.1:1086&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个设置只代理了 github，不会对国内仓库使用代理。&lt;/p&gt;
&lt;h4 id=&quot;参考内容&quot;&gt;&lt;a href=&quot;#参考内容&quot; class=&quot;headerlink&quot; title=&quot;参考内容&quot;&gt;&lt;/a&gt;参考内容&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GotGit： 稀疏检出和浅克隆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000118837&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;segmentfault：如何为 Git 设置代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018-3-git.png&quot; alt=&quot;git-cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;年后这段时间连续遇到了两次 git clone 龟速缓慢，一天之内都 clone 不下来的问题。这里记录一下解决方法和原理。&lt;/p&gt;
&lt;p&gt;git clone 太慢的常规原因有两种，&lt;strong&gt;第一种是 git 仓库本身导致的，第二种是我们使用者的网络问题&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://blog.colafornia.me/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>回顾一下 JavaScript 中的深浅拷贝以及内存管理</title>
    <link href="https://blog.colafornia.me/post/2018/review-copy-in-javascript/"/>
    <id>https://blog.colafornia.me/post/2018/review-copy-in-javascript/</id>
    <published>2018-01-13T01:05:00.000Z</published>
    <updated>2019-10-24T02:22:04.205Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/review-copy-in-javascript.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 &lt;code&gt;JSON.parse(JSON.stringify(target))&lt;/code&gt; 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;基本类型-VS-引用类型，值传递-VS-引用传递&quot;&gt;&lt;a href=&quot;#基本类型-VS-引用类型，值传递-VS-引用传递&quot; class=&quot;headerlink&quot; title=&quot;基本类型 VS 引用类型，值传递 VS 引用传递&quot;&gt;&lt;/a&gt;基本类型 VS 引用类型，值传递 VS 引用传递&lt;/h3&gt;&lt;p&gt;首先回顾一下高程中的基本概念。&lt;/p&gt;
&lt;p&gt;ECMAScript 变量包含两种数据类型的值：基本类型值与引用类型值。基本类型指的是简单的数据段，如 &lt;code&gt;Undefined&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt;（ES6 中出现的 &lt;code&gt;Symbol&lt;/code&gt; 也属于基本类型）。引用类型指的是可能由多个值构成的对象。&lt;/p&gt;
&lt;p&gt;基本类型是按值访问的，&lt;strong&gt;可以操作保存在变量中的实际的值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;引用类型的值是保存在内存中的对象，&lt;strong&gt;JavaScript 不允许直接访问内存中的位置&lt;/strong&gt;，因此我们在操作对象时，是在操作对象的引用而不是实际的对象。&lt;/p&gt;
&lt;p&gt;然而访问变量有按值和按引用两种方式，而 &lt;strong&gt;参数只能按值传递&lt;/strong&gt;。在向参数传递引用类型的值时，会把值在内存中的地址复制给另一个局部变量。&lt;/p&gt;
&lt;h3 id=&quot;深入内存&quot;&gt;&lt;a href=&quot;#深入内存&quot; class=&quot;headerlink&quot; title=&quot;深入内存&quot;&gt;&lt;/a&gt;深入内存&lt;/h3&gt;&lt;p&gt;以上虽然不难理解，但是不深层挖掘一下还是很难完全记住。所以来看看内存中到底发生了什么吧。&lt;/p&gt;
&lt;p&gt;先看看内存的生命周期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dt-fe/weekly/master/assets/29/1.jpg&quot; alt=&quot;life&quot;&gt;&lt;/p&gt;
&lt;p&gt;即 内存分配 =&amp;gt; 内存读写 =&amp;gt; 内存释放&lt;/p&gt;
&lt;p&gt;JavaScript 在定义变量时即完成了内存分配。&lt;strong&gt;运算符= 就是创建或修改变量在内存中的指向。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123; b: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;; &lt;span class=&quot;comment&quot;&gt;// a 为引用类型，给 a 分配内存 &amp;#123; b: 1 &amp;#125;， a 存储的即为 &amp;#123; b: 1 &amp;#125; 的地址&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c = a; &lt;span class=&quot;comment&quot;&gt;// 给 c 分配内存 指向 a 存储的地址，即 &amp;#123; b: 1 &amp;#125; 的地址&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 修改 a 的内存指向到 2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(c); &lt;span class=&quot;comment&quot;&gt;// c 存储的仍为 &amp;#123; b: 1 &amp;#125; 的地址，因此结果为 &amp;#123; b: 1 &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前两行代码在内存中的分布为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;变量&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;{ b: 1 } 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;c&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;{ b: 1 } 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第三行修改了内存指向：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;变量&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;变量 c 仍然指向 { b: 1 } 的地址。&lt;/p&gt;
&lt;p&gt;再看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; m = &amp;#123; a: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, b: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; n = m; &lt;span class=&quot;comment&quot;&gt;// 复制引用类型的值，使 n 和 m 指向同一地址&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;n.a = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(m.a);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还是先看前两行：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;变量&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;m&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;{ a: 10, b: 20 } 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;{ a: 10, b: 20 } 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第三行通过 n.a 修改了变量，但 m 和 n 仍然指向同一地址不变，因此 m.a 的值也为 15&lt;/p&gt;
&lt;p&gt;对于参数传递过程中的内存变化不是本文重点，可以观摩 &lt;a href=&quot;https://github.com/mqyqingfeng/Blog/issues/10&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript深入之参数按值传递&lt;/a&gt; 下面精彩的评论来学习。&lt;/p&gt;
&lt;p&gt;有很多博文还针对 JavaScript 的内存空间，栈内存与堆内存进行了讲解，但是对于这方面实在没有经验，没什么鉴别能力，暂时先不说了。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-中的深浅拷贝&quot;&gt;&lt;a href=&quot;#JavaScript-中的深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的深浅拷贝&quot;&gt;&lt;/a&gt;JavaScript 中的深浅拷贝&lt;/h3&gt;&lt;p&gt;回顾完以上知识点后，可以发现对于对象的拷贝，其实分为两种情况（这里，将被拷贝对象称为源对象）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shallow clone 浅拷贝：如果对象中某个属性值是对象的话，浅拷贝的只是内存指针，当内存中的值发生变化后，拷贝对象与源对象与都会发生改变。&lt;/li&gt;
&lt;li&gt;deep clone 深拷贝：拷贝对象与源对象是完全单独的对象，没有属性值是指向同一内存指针的，源对象发生任何修改都不会引起拷贝对象发生变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意一点，ES6 中 Object 的新方法 &lt;code&gt;Object.assign&lt;/code&gt; 执行的就是浅拷贝，Stack Overflow 上有一个高票回答误将其答为深拷贝，我就踩了坑，避免加深错误印象，这里不放链接了。&lt;/p&gt;
&lt;p&gt;ES6 中的 Object &lt;code&gt;rest/spread destructuring&lt;/code&gt; 也是浅拷贝：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; existing = &amp;#123; a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, c: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; ...clone &amp;#125; = existing;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于深拷贝，可想而知，需要对嵌套对象进行递归遍历，但是真正实现 deep clone 没有想象的简单，主要原因在于 deep clone 的定义并不统一，以及 edge case 非常多，包含 DOM/BOM 对象如何处理，函数如何处理，原型链如何处理等问题。但是希望 “做出修改不影响其它引用” 确实是一个常见场景。&lt;/p&gt;
&lt;p&gt;最简单的方法就是开头提到的 &lt;code&gt;JSON.parse(JSON.stringify(target))&lt;/code&gt;。缺点在于无法处理 Date、Function 等类型的属性值。&lt;/p&gt;
&lt;p&gt;因此在业务中推荐使用 lodash 的 &lt;a href=&quot;https://lodash.com/docs/4.17.4#cloneDeep&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;_.cloneDeep&lt;/a&gt; 实现深拷贝，简洁可靠。&lt;/p&gt;
&lt;p&gt;实际上，在 &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;immutable.js&lt;/a&gt; 出现后，实现数据结构的持久化有了更优雅的方式。&lt;/p&gt;
&lt;h3 id=&quot;希望之光-Immutable&quot;&gt;&lt;a href=&quot;#希望之光-Immutable&quot; class=&quot;headerlink&quot; title=&quot;希望之光 Immutable&quot;&gt;&lt;/a&gt;希望之光 Immutable&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/4c698f4cef2ae6b69873aa7de91f6d10f28162e1/687474703a2f2f696d672e616c6963646e2e636f6d2f7470732f69312f544231796b395f4b585858585862565846585845745848387058582d3930302d3334322e706e67&quot; alt=&quot;Immutable&quot;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript 中的对象一般都是可变的（mutable），虽然节省了内存，却给复杂的大型应用造成很多隐患。Immutable Data 为一旦创建，就不能再被修改的数据。通过 &lt;strong&gt;Persistent Data Structure&lt;/strong&gt;（持久化数据结构）使得在使用旧数据创建新数据时，也保证了旧数据同时可用且不变。&lt;/p&gt;
&lt;p&gt;前面所述的 deep clone 方法是把所有节点都复制一遍，性能损耗非常大。Immutable 使用了 &lt;strong&gt;Structural Sharing&lt;/strong&gt;（结构共享），性能提升很多。&lt;/p&gt;
&lt;p&gt;通过 immutable.js 实现 deep clone:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; defaultConfig = Immutable.fromJS(&amp;#123;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config = defaultConfig.merge(initConfig); &lt;span class=&quot;comment&quot;&gt;// defaultConfig不会改变，返回新值给 config&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; config = defaultConfig.mergeDeep(initConfig); &lt;span class=&quot;comment&quot;&gt;// 深层merge&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;immutable.js 提供了7种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record。&lt;/p&gt;
&lt;p&gt;虽然 immutable.js 通常与 facebook 同厂出品的 React 一起使用，但是它其实是一个完全独立的库，无论基于什么框架都可以使用。说它是希望之光并没有言过其实。更多内容可以查看 &lt;a href=&quot;https://github.com/camsong/blog/issues/3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Immutable 详解及 React 中实践&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/review-copy-in-javascript.png&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近在组内 code review 中遇到了一处业务代码中需要深拷贝的地方，同学简单地通过 &lt;code&gt;JSON.parse(JSON.stringify(target))&lt;/code&gt; 来进行，在讨论中发现了一些好玩的东西，特此来回顾一下。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://blog.colafornia.me/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>2017 年度总结</title>
    <link href="https://blog.colafornia.me/post/2017/2017-review/"/>
    <id>https://blog.colafornia.me/post/2017/2017-review/</id>
    <published>2017-12-31T04:00:00.000Z</published>
    <updated>2019-10-24T02:22:04.194Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/tokyo-in-2017.jpg&quot; alt=&quot;tokyo in 2017&quot;&gt;&lt;/p&gt;
&lt;p&gt;2017: no silver bullet.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h4&gt;&lt;p&gt;二月底入职了美团，到现在也快一年了。&lt;/p&gt;
&lt;p&gt;借助于在下厨房时一行一行代码 review 出的好习惯以及一些技术选型上的经验红利，这大半年包括职级晋升也过得还是很顺利。在此非常感谢也怀念在下厨房的那些菜鸟日子。&lt;/p&gt;
&lt;p&gt;美团的知识wiki 藏龙卧虎，有完善的新人培养以及 Mentor 机制，每天各个 BU 都有些质量很不错的技术分享，精力足够的话在新人期是有非常多的机会去学习观摩的。在终端组时还有被要求记录 work log，虽然一开始有些痛苦，最后还是养成了注重人效与时间管理的习惯。&lt;/p&gt;
&lt;p&gt;除了以上，最大的感受还是在于，一直被培养“做事的方法”，要求注重软素质。在大厂当螺丝钉，基本不会遇到每天应付 PM 改需求，调整开发时间这类事。PM 包办了项目管理，与业务方的沟通等事情，作为 FE 只需要确定好自己的估时排期，关注后端提供的接口定义就可以。好处显而易见，坏处就是过于螺丝钉了，没什么机会去做自身领域外的事情。今后还是需要自己多努力扩展能力边界。&lt;/p&gt;
&lt;h4 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h4&gt;&lt;p&gt;四月的时候去了趟日本，走了东京和伊东两座城市。在东京六本木的观景台拍了题图这张夜景。伊豆半岛的性价比很高，和牛比在东京吃的更好吃，因为没什么游客，看到了蛮多更市井的场景。感觉出来玩还是慢悠悠的会比较有意思。&lt;/p&gt;
&lt;p&gt;生活中最重要的事是，年底把户口迁到了成都。买房和定居还不一定是什么时候，应该要等工作能力再提高一些，不那么菜之后再说。时隔三年又去了一次成都，除了好吃更感觉是真的安逸。&lt;/p&gt;
&lt;p&gt;就在跨年这两天，我搬家到了望京这边，换了一个一居室，更适合猫猫住。离公司近一些，节省了通勤时间，想把节省的时间用在健身上。毕业一年半，体质是稳步地下降，精力不太够用，嗜糖这一坏习惯也没有多大好转。再这样下去应该是迟早 💊。&lt;/p&gt;
&lt;p&gt;今年有在做基金定投，收益 10% 左右，只是年底由于订明年出行的机票酒店吃了波土，最后两个月没有继续投入了。这种强制储蓄的理财方式确实很实用，只是需要每月都在发薪日投出去，免得最后又花超了变月光。&lt;/p&gt;
&lt;h4 id=&quot;📚-和-🎬&quot;&gt;&lt;a href=&quot;#📚-和-🎬&quot; class=&quot;headerlink&quot; title=&quot;📚 和 🎬&quot;&gt;&lt;/a&gt;📚 和 🎬&lt;/h4&gt;&lt;p&gt;今年一共看了 13 本书，去年制定的看书计划基本完成了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;《学习JavaScript数据结构与算法》&lt;/li&gt;
&lt;li&gt;《禅与摩托车维修艺术》&lt;/li&gt;
&lt;li&gt;《程序员修炼之道 : 从小工到专家》&lt;/li&gt;
&lt;li&gt;《Node.js实战》&lt;/li&gt;
&lt;li&gt;《图解HTTP》&lt;/li&gt;
&lt;li&gt;《Web全栈工程师的自我修养》&lt;/li&gt;
&lt;li&gt;《牛津通识读本 : 数学》&lt;/li&gt;
&lt;li&gt;《刻意练习》&lt;/li&gt;
&lt;li&gt;《淘宝技术这十年》&lt;/li&gt;
&lt;li&gt;《亲密关系》&lt;/li&gt;
&lt;li&gt;《地球与太空》&lt;/li&gt;
&lt;li&gt;《一首小夜曲》&lt;/li&gt;
&lt;li&gt;《死神的精确度》&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;只是技术上没看什么大部头，还有几本已经看到最后几章但是计划被打乱迟迟没有看完。&lt;/p&gt;
&lt;p&gt;电影看了 79 部，从豆瓣的报告来看还是院线片居多，可能也反映出了心态比较浮躁吧。&lt;/p&gt;
&lt;h4 id=&quot;新的计划&quot;&gt;&lt;a href=&quot;#新的计划&quot; class=&quot;headerlink&quot; title=&quot;新的计划&quot;&gt;&lt;/a&gt;新的计划&lt;/h4&gt;&lt;p&gt;这里只列举一些急切需要完成（三个月内）的事。在此推荐一个最近感觉很好用的 APP， &lt;a href=&quot;https://www.v2ex.com/t/413134#reply11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的小目标&lt;/a&gt;，是由一名 iOS 开发者独立开发的个人作品，其中集成了番茄钟与单核工作法，金币积攒与消耗这种类似于打怪升级的模式很适合我。&lt;/p&gt;
&lt;p&gt;待办事项：&lt;br&gt;1.读完《JavaScript 设计模式与开发实践》&lt;br&gt;2.完成《Git 原理解析》的 blog &amp;amp;&amp;amp; 分享&lt;br&gt;3.移动端预渲染方案&lt;/p&gt;
&lt;p&gt;习惯养成：&lt;br&gt;1.leetcode每周一题&lt;br&gt;2.每周健身一次（看看前五周降体脂的效果如何&lt;br&gt;3.每周在掘金翻译计划校对/推荐文章一次&lt;/p&gt;
&lt;h4 id=&quot;Less-is-more&quot;&gt;&lt;a href=&quot;#Less-is-more&quot; class=&quot;headerlink&quot; title=&quot;Less is more&quot;&gt;&lt;/a&gt;Less is more&lt;/h4&gt;&lt;p&gt;最后还是总结一下，生活和工作上都没有银弹，好好管理生活与代码的复杂度。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/tokyo-in-2017.jpg&quot; alt=&quot;tokyo in 2017&quot;&gt;&lt;/p&gt;
&lt;p&gt;2017: no silver bullet.&lt;/p&gt;
    
    </summary>
    
      <category term="summary" scheme="https://blog.colafornia.me/categories/summary/"/>
    
    
  </entry>
  
  <entry>
    <title>《Pragmatic Programmer》</title>
    <link href="https://blog.colafornia.me/post/2017/reading-pragmatic-programmer/"/>
    <id>https://blog.colafornia.me/post/2017/reading-pragmatic-programmer/</id>
    <published>2017-09-15T15:32:00.000Z</published>
    <updated>2019-10-24T02:22:04.204Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;豆瓣地址&lt;/a&gt;&lt;br&gt;这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。&lt;br&gt;定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、工程意识&quot;&gt;&lt;a href=&quot;#一、工程意识&quot; class=&quot;headerlink&quot; title=&quot;一、工程意识&quot;&gt;&lt;/a&gt;一、工程意识&lt;/h3&gt;&lt;p&gt;① &lt;code&gt;Don&amp;#39;t Live with Broken Windows: 不要容忍破窗户&lt;/code&gt;&lt;br&gt;这其实就是所说的“破窗理论”，破窗户（低劣的设计，糟糕的代码，临时凑合出的可以 work 的奇怪 hack function）具有传染性，只会导致项目中破窗户越来越多，一堆临时的 hack 修补引起连环问题，直到难以修复，程序崩溃。&lt;br&gt;熵增定律告诉我们，一个封闭系统总是趋向于熵增，也就是系统的无序程度只会不断增加。软件开发中也是如此，不要容忍破窗户，尽快修复任何已察觉到的问题。&lt;/p&gt;
&lt;p&gt;② &lt;code&gt;DRY - Don&amp;#39;t Repeat Yourself 不要重复你自己&lt;/code&gt;&lt;br&gt;   &lt;code&gt;Make It Easy to Reuse 让复用变得容易&lt;/code&gt;&lt;br&gt;   &lt;code&gt;There Are No Final Decisions 不存在最终决策&lt;/code&gt;&lt;br&gt;也是非常有名的 &lt;code&gt;DRY&lt;/code&gt; 原则，与在《重构》与《设计模式》中学习到的类似，应使得我们的程序更&lt;br&gt;介绍了几种可能出现重复的场景，应使得程序具有正交性，不仅出于好维护的目的，也为了避免由于需求变更而扩展性不够导致需要重写。（从这里看来软件开发的常见问题这么多年都没啥变化）&lt;br&gt;要警惕自己出于懒惰而做的 Copy&amp;amp;Paste，它不仅对项目没什么好处，也是一种“恶劣习惯”的开始。&lt;br&gt;维持代码正交性的方法（其实也是重构原则）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让你的代码保持解耦：&lt;code&gt;Law of Demeter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免使用全局数据&lt;/li&gt;
&lt;li&gt;避免编写相似的函数：可以通过策略模式实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;③ &lt;code&gt;Estimate to Avoid Superises: 估算，以避免发生意外&lt;/code&gt;&lt;br&gt;   &lt;code&gt;Iterate the Schedule with the Code: 通过代码对进度表进行迭代&lt;/code&gt;&lt;br&gt;书中提到“使用的时间单位会对结果的解读造成影响”，并由此提到了相应的建议估算单位，这个还是很有意思的:&lt;br&gt;&lt;img src=&quot;https://file.sankuai.com/pan/im/1/image/AQhd2cqjdxpb_PAKXwAAElX88ApY@640w_1l?t=b&amp;amp;w=640&amp;amp;h=222&quot; alt=&quot;estimate&quot;&gt;&lt;/p&gt;
&lt;p&gt;这只算一些估算经验，真正想进行准确有效的估算，还是要不断复盘检测，建立自己的系统模型，组织开发中所用的步骤，进行合理的模块划分来估算项目进度。&lt;/p&gt;
&lt;p&gt;④ &lt;code&gt;Keep Knowledge in Plain Text: 用纯文本保存知识&lt;/code&gt;&lt;br&gt;   &lt;code&gt;Configure, Don&amp;#39;t Integrate: 要配置，不要集成&lt;/code&gt;&lt;br&gt;   &lt;code&gt;Put Abstractions in Code, Details in Metdata: 将抽象放进代码，细节放进元数据&lt;/code&gt;&lt;br&gt;这里提到了使耦合减少至最少的一个方法，使用 &lt;code&gt;Metadata&lt;/code&gt; 元数据，让我们的系统变得高度可配置。元数据是关于数据的数据，比如说数据库 &lt;code&gt;schema&lt;/code&gt;，对字段进行描述。&lt;br&gt;通过以声明方式思考，由元数据驱动的应用将迫使我们解除设计耦合，推迟细节处理并大大提到了可复用性，能快速响应由需求变更导致的改动。&lt;/p&gt;
&lt;p&gt;⑤ &lt;code&gt;Don&amp;#39;t Program by Coincidence 不要靠巧合编程&lt;/code&gt;&lt;br&gt;这是一个很简单也显而易见的事，然而还是会经常出现“好不容易跑起来了，哪都不要动，先这样吧”。不仅如此，很多时候也是会不经意地忽略这件事，需要警惕，此时能实现很可能是由于正处于边界条件，只是偶然。&lt;br&gt;因此不仅要用 case 测试我们的代码，还要对测试 case 进行深思，通过一些覆盖不全、偶然情况的 case 并不意味着代码是 OK 的。&lt;/p&gt;
&lt;h3 id=&quot;二、开始实际的开发&quot;&gt;&lt;a href=&quot;#二、开始实际的开发&quot; class=&quot;headerlink&quot; title=&quot;二、开始实际的开发&quot;&gt;&lt;/a&gt;二、开始实际的开发&lt;/h3&gt;&lt;p&gt;① &lt;code&gt;Estimate the Order of Your Algorithms 算法速率&lt;/code&gt;&lt;br&gt;书中也简单介绍了 &lt;code&gt;大O表示法&lt;/code&gt; 与一些常见算法的复杂度。在这里要牢记，要根据实际情况做出选择，过度追求算法上的优化而增加了测试维护的成本得不偿失。&lt;/p&gt;
&lt;p&gt;② &lt;code&gt;Don&amp;#39;t Gather Requirement - Dig for Them 不要搜集需求——挖掘它们&lt;/code&gt;&lt;br&gt;&lt;code&gt;Abstractions Live Longer than Details 抽象比细节活得更长久&lt;/code&gt;&lt;br&gt;要对需求敏感，不假思索完全按照 PM 提过来的需求描述进行开发，可能会导致项目中的代码扩展性不好。举个例子，“只有人事部门可以查看档案”与“只有指定人员才能查看员工档案”这就是两个不一样的概念。完全按照前者来开发，很有可能只是将人事部门的组织id写入代码，而后者意味着我们可能需要做一个权限服务而与业务逻辑分离。&lt;/p&gt;
&lt;p&gt;因此，应该 &lt;strong&gt;把政策的文档与需求的文档分开，使需求称为一般陈述，并把政策信息作为例子发给开发者，作为在具体视线中需要支持的一个 Case，最后政策可以称为应用中的元数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;找出用户为何要做特定事情的&lt;code&gt;起因&lt;/code&gt;，而不只是他们目前做这件事的&lt;code&gt;方式&lt;/code&gt;。因为作为开发者是要解决用户的商业问题，而不只是满足用户陈述的需求，解决需求的方式是很有可能发生变化的，而深入挖掘到要解决的根本问题，才是可以使得系统高效，开发人员也不必为需求疲于奔命的解决方式。&lt;/p&gt;
&lt;p&gt;在编写我们开发人员自己使用、查阅的需求文档时，应注重&lt;code&gt;保持抽象&lt;/code&gt;，在涉及需求的地方，最简单的，能够准确地反映商业需要的陈述才是最好的，必须把&lt;code&gt;底层的语义不变项&lt;/code&gt;当做需求进行捕捉。如上个例子，控制可以查看档案的权限，即是语义不变项。&lt;/p&gt;
&lt;p&gt;③ &lt;code&gt;Listen to Nagging Doubts -Start When You&amp;#39;re Ready 等你准备好再开始&lt;/code&gt;&lt;br&gt;这里讨论了“启动恐惧症”，这件事我也经常遇到，但是并没有反思在什么情况下会出现启动恐惧症，每次都是拖延许久最后在无限抵触和焦虑中把项目赶完了。&lt;/p&gt;
&lt;p&gt;书中提出应该注意到自己的疑虑，在长时间的积累后，我们的直觉也会很有用处。除此之外，如果我们发现这种疑虑只是出于拖延的话，应该 &lt;strong&gt;选择一个你觉得会有困难的地方，开始进行某种“概念验证”&lt;/strong&gt;，这样可以有效快速地使启动起来了，因为行动结果无非有两种，一种是我们发现，这个困难可以解决然后就可以消除疑虑正式投入开发，另一种我们发现这个地方确实有问题，然后通过求助外界或者更改需求来推进它，总之项目是有了一个不小的进展。&lt;/p&gt;
&lt;p&gt;上述只是记了一些我在阅读中感触比较多的地方，实际上这本书虽然是一个蛮远久的“名著”，其中概念都很经典并不过时，书中每页都有启示。还是希望我在实习期就有机会看到这本书的，现在开始也并不晚，并且应该多回顾，随着开发经验的增多应该收获也会越来越多。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=140159398,1086926125&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot;&gt;豆瓣地址&lt;/a&gt;&lt;br&gt;这本书的中文版被翻译为《程序员修炼之道——从小工到专家》，看起来有点中二，其实原名直译《注重实效的程序员》就很合适了。&lt;br&gt;定位于给初级开发人员阅读，涉及到软件工程开发的方方面面，摒弃平时所关注的语言特性，技术细节，而是高屋建瓴，着眼于正确的软件设计方法和应该具备的软件工程意识。（也是一个机会了解行业术语与典故）&lt;br&gt;
    
    </summary>
    
      <category term="programmer reading" scheme="https://blog.colafornia.me/categories/programmer-reading/"/>
    
    
  </entry>
  
</feed>
