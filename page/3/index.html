<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Minibase</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2017/make-shell-and-git-better/" class="post-title-link">Make Shell/Git Better</a></h2><div class="post-info">Sep 15, 2017</div><div class="post-content"><h2 id="1-起手式-oh-my-zsh"><a href="#1-起手式-oh-my-zsh" class="headerlink" title="1.起手式 oh-my-zsh"></a>1.起手式 oh-my-zsh</h2><p><img src="https://camo.githubusercontent.com/5c385f15f3eaedb72cfcfbbaf75355b700ac0757/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6f686d797a73682f6f682d6d792d7a73682d6c6f676f2e706e67" alt="oh-my-zsh"></p>
<p>zsh 被称作是最强大的 shell，而 oh-my-zsh 则是最流行的 zsh 配置文件，提供了丰富的主题以及大量插件，极大地扩展了 zsh 的功能。<br>可以无脑引入，便得到了最基本又好用的文件夹跳转，路径、命令、参数补全等便利操作。<br>推荐 plugin: git, <a href="https://github.com/wting/autojump/wiki">autojump</a>, <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx">osx</a></p>
<h2 id="2-优化你的-Git"><a href="#2-优化你的-Git" class="headerlink" title="2.优化你的 Git"></a>2.优化你的 Git</h2><p><strong>① 美化 diff</strong><br>Git 自己的 git diff 还是蛮不好用也不好看的，文件名和 diff 内容不太好定位。<br>基于 <a href="https://github.com/so-fancy/diff-so-fancy">diff-so-fancy</a> 我们可以做一些美化工作。</p></div><a href="/post/2017/make-shell-and-git-better/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2017/fix-chinese-input-listener/" class="post-title-link">解决中文拼音输入法在input监听的问题</a></h2><div class="post-info">Aug 22, 2017</div><div class="post-content"><h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><p><img src="/images/chinese-pinyin.gif" alt="cover"></p>
<p>在通过监听用户输入，将输入作为 Keyword 进行查询时（做了防抖）发现有如图问题，使用中文拼音输入法时，未选中所要的字词前，会自动将输入法分词过的拼音作为文本，由于实时监听输入，就存在将 ce’shi 作为 keyword 查询的问题了。<br>在这里，前端需要对拼音输入法的这种情况进行处理。<br></div><a href="/post/2017/fix-chinese-input-listener/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2017/from-settimeout-to-event-loop/" class="post-title-link">You Don't Know setTimeout</a></h2><div class="post-info">Jun 4, 2017</div><div class="post-content"><p><img src="/images/jstips-animation.gif" alt="cover"></p>
<h3 id="几个可能不知道的定时器⏲特性"><a href="#几个可能不知道的定时器⏲特性" class="headerlink" title="几个可能不知道的定时器⏲特性"></a>几个可能不知道的定时器⏲特性</h3><p>首先，<strong>setTimeout()/setInterval()</strong> 方法不是 ECMAScript 规范定义的内容，而是属于 BOM 提供的功能，也就是说定时器作为 BOM 对象和方法的一部分才能在浏览器中使用。</p>
<p>需要注意的是 <strong>setTimeout() 与 setInterval() 在触发周期的定义上完全不一样</strong>，在下面例子 setTimeout() 代码中，要在前一个 callback 回调执行结束并延迟 10ms 以后才能再次执行 setTimeout()，即延迟是要求运行时(runtime) 处理请求所需的最小时间，但不是有所保证的时间。而 setInterval() 则是每隔 10ms 就执行一次 callback 回调，不会关注 callback 何时执行结束。</p></div><a href="/post/2017/from-settimeout-to-event-loop/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2017/observer-pattern-in-vue/" class="post-title-link">观察者模式以及在 Vue 源码中的实践</a></h2><div class="post-info">Mar 14, 2017</div><div class="post-content"><p><img src="/images/vue-reactive.jpg" alt="vue"></p>
<p>在 ES6 把 Promise 写进语言标准前，为实现异步编程，经常会采用 <strong>观察者模式（发布-订阅模式）</strong> 作为替代传递回调函数的方案。</p>
<p>它定义了一种一对多的关系，让多个观察者订阅同一主题对象，当主题状态发生改变则立即发布，通知所有的订阅者。发布者和订阅者之间完全解耦，仅仅是共享同一自定义事件的名称。当新的订阅者出现，发布者无需做任何修改，反之亦然。</p></div><a href="/post/2017/observer-pattern-in-vue/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/basic-review-from-anonymous-function-to-iife/" class="post-title-link">由匿名函数展开的一系列知识点</a></h2><div class="post-info">Nov 23, 2016</div><div class="post-content"><p><img src="/images/iife.png" alt="cover"></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近在进行 <a href="https://github.com/Colafornia/underscore-analysis">underscore.js 源码分析</a>，也顺便看了些别的库的大致封装方式<br>underscore:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> root = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">    <span class="keyword">this</span>._wrapped = obj;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// blabla</span></div><div class="line">&#125;());</div></pre></td></tr></table></figure></div><a href="/post/2016/basic-review-from-anonymous-function-to-iife/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/javascript-patterns/" class="post-title-link">Before learning the functional programming and design patterns</a></h2><div class="post-info">Nov 17, 2016</div><div class="post-content"><p><img src="images/JavaScript-for-Kids.png" alt="cover"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="OOP-In-JavaScript"><a href="#OOP-In-JavaScript" class="headerlink" title="OOP In JavaScript"></a>OOP In JavaScript</h3><h4 id="Duck-Typing-鸭子类型"><a href="#Duck-Typing-鸭子类型" class="headerlink" title="Duck Typing 鸭子类型"></a>Duck Typing 鸭子类型</h4><p>JavaScript 是一门动态类型语言，与静态类型语言相比，在进行变量赋值时并不需要考虑它的类型。在动态类型语言的面向对象设计中， <code>鸭子类型</code> 的概念非常重要：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型 (duck typing)</a> 的通俗说法是““当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”” 鸭子类型指导我们只关注对象的行为，而不专注对象本身，即关注 HAS-A,而不是IS-A。</p>
</blockquote>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态的含义是“同一操作作用于不同对象上面，可以产生不同的解释和执行结果”，背后的思想是把“不变的事物”与“可能改变的事物”分离开来，把不变的部分隔离出来，把可变的部分封装起来，使得代码变得可扩展，修改代码也变得更加安全。 <strong>不必再向对象询问“你是什么类型”再根据得到的答案调用对象的某个行为，直接调用就是了</strong> 。JavaScript 的多态性与生俱来，它在编译时没有类型检查的过程。</p></div><a href="/post/2016/javascript-patterns/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/high-performance-javascript-b/" class="post-title-link">阅读《高性能JavaScript》(下)</a></h2><div class="post-info">Oct 3, 2016</div><div class="post-content"><p><img src="/images/javascript-is-fast.png" alt="cover"></p>
<p>接<a href="https://blog.colafornia.me/2016/09/26/high-performance-javascript-a/">前四节的总结</a></p>
<h2 id="5-字符串和正则表达式"><a href="#5-字符串和正则表达式" class="headerlink" title="5.字符串和正则表达式"></a>5.字符串和正则表达式</h2><h4 id="字符串构建原理"><a href="#字符串构建原理" class="headerlink" title="字符串构建原理"></a>字符串构建原理</h4><p><code>str += &#39;one&#39; + &#39;two&#39;</code></p>
<p>这行代码运行时会经历四个步骤：</p>
<blockquote>
<p>1.在内存中创建一个临时字符串<br>2.链接后的字符串 ‘onetwo’ 被赋值给该临时字符串<br>3.临时字符串与 str 当前值连接<br>4.结果赋给 str</p>
</blockquote></div><a href="/post/2016/high-performance-javascript-b/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/high-performance-javascript-a/" class="post-title-link">阅读《高性能JavaScript》(上)</a></h2><div class="post-info">Sep 26, 2016</div><div class="post-content"><p><img src="https://img1.doubanio.com/lpic/s28879959.jpg" alt="cover"></p>
<p>这篇只包含前四章节。</p>
<h2 id="1-加载与执行"><a href="#1-加载与执行" class="headerlink" title="1.加载与执行"></a>1.加载与执行</h2><p>浏览器使用单一进程来处理用户界面UI刷新和JavaScript脚本执行。脚本执行过程中会阻塞页面渲染。</p>
<p>减少脚本执行对性能影响的方法：</p>
<ul>
<li>把所有 <code>&lt;script&gt;</code> 标签尽可能放到 <code>&lt;body&gt;</code> 标签底部。</li>
<li>合并脚本，减少HTTP请求带来的额外性能开销。</li>
<li>无阻塞下载执行JavaScript脚本：<ul>
<li><code>&lt;script&gt;</code> 的 <code>defer</code> 属性可以使脚本下载后先不执行，老版本浏览器不支持</li>
<li>书中未提到的 HTML5 <code>async</code> 属性可以使脚本异步加载执行</li>
<li>使用XHR对象动态加载脚本</li>
</ul>
</li>
</ul></div><a href="/post/2016/high-performance-javascript-a/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/basic-fetch-api/" class="post-title-link">一些关于 fetch api 的基本设定</a></h2><div class="post-info">Aug 22, 2016</div><div class="post-content"><p>长久以来，我们一直都通过XMLHttpRequest(XHR)来执行异步请求，但它有很多缺陷与不便之处，W3C官方则推出了新的api <code>Fetch</code>来替换它。</p>
<h3 id="XMLHttpRequest的缺陷"><a href="#XMLHttpRequest的缺陷" class="headerlink" title="XMLHttpRequest的缺陷"></a>XMLHttpRequest的缺陷</h3><p>先看一个典型的XHR例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.responseType = <span class="string">'json'</span>;</div><div class="line"></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(xhr.response);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Booo"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p>
<p>可以看出，XHR是基于事件的异步模型，在设计上不符合分离原则，输入、输出和用事件来跟踪的状态混杂在一个对象里。我们必须创建实例来发送请求。相比于ES6发布的Promise，Generator，基于事件的模型是非常落后难用的。</p></div><a href="/post/2016/basic-fetch-api/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/2016/browser-cache-summary/" class="post-title-link">关于浏览器缓存</a></h2><div class="post-info">Jul 18, 2016</div><div class="post-content"><p>浏览器缓存就是将web资源保存在本地，就不用再每次都向服务器请求相同的资源。当下一个请求发起，如果是同样的url，浏览器会根据缓存机制来决定是读取本地的内容还是向服务器发送请求。显而易见，浏览器缓存可以减少带宽消耗，加快用户的访问速度同时减轻服务器压力。</p>
<p>浏览器的缓存机制主要分为两种，http协议定义的缓存机制和非http协议定义的缓存机制。后者主要通过在html文件中设置<code>meta标签</code>来实现。</p>
<h2 id="与缓存相关的首部字段"><a href="#与缓存相关的首部字段" class="headerlink" title="与缓存相关的首部字段"></a>与缓存相关的首部字段</h2><p><img src="http://o7ts2uaks.bkt.clouddn.com/CACHE.png" alt="http首部字段"></p></div><a href="/post/2016/browser-cache-summary/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="prev">PREV</a><a href="/page/4/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>