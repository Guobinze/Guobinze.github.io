<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 装饰者模式 => AOP => ES7 decorator => React 高阶组件 · Minibase</title><meta name="description" content="装饰者模式 =&gt; AOP =&gt; ES7 decorator =&gt; React 高阶组件 - Colafornia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">装饰者模式 => AOP => ES7 decorator => React 高阶组件</h1><div class="post-info">May 19, 2018</div><div class="post-content"><p><img src="https://cdn-images-1.medium.com/max/1600/1*o6Q0MpSmQni2Q_sB5y9jig.png" alt=""></p>
<p>五月是学习的好时节啊，翻翻书继续学习一下设计模式吧。</p>
<p>该到<code>装饰者模式</code>了。来，学习一下。</p>
<p>书里的 <code>AOP</code> 是啥？学习一下。</p>
<p>新时代了再看看 ES7 规范的 <code>decorator</code> 吧，学习一下。。</p>
<p>啊还有 <code>React 高阶组件</code>的事儿呢，都学到这了，不差这一会儿。。。</p>
<a id="more"></a>
<h3 id="一、装饰者模式是什么"><a href="#一、装饰者模式是什么" class="headerlink" title="一、装饰者模式是什么"></a>一、装饰者模式是什么</h3><p>先看一下最为精确的英文维基定义：</p>
<blockquote>
<p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.</p>
</blockquote>
<p>对于传统的 OOP 语言来说，给对象(object)添加功能通常使用继承的方式，这不仅导致了超类与子类间的强耦合，也违反了<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">单一职责原则</a>。</p>
<p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。</p>
<h3 id="二、装饰者模式的典型应用：AOP"><a href="#二、装饰者模式的典型应用：AOP" class="headerlink" title="二、装饰者模式的典型应用：AOP"></a>二、装饰者模式的典型应用：AOP</h3><p>AOP 全称为 <code>Aspect-oriented programming</code>，即<code>面向切面编程</code>。主要适用于需要有横切逻辑的场景，比如数据上报，错误处理，鉴权，请求拦截等。</p>
<p>理解这个概念之后，实际操作就并不复杂。可以通过在原型上设置 <code>Function.prototype.before</code> 方法和 <code>Function.prototype.after</code> 方法，实现 <code>AOP 装饰函数</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这两个装饰函数都接收函数作为参数，只是所接收参数的执行顺序不同。</p>
<p>同理，我们也可以给 service 编写装饰函数，作为接口拦截器。如 <a href="https://github.com/axios/axios" target="_blank" rel="external">axios</a> 中的 <code>Interceptors</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给请求添加拦截器</span></div><div class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在发起请求前 do something</span></div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// 处理错误</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 给返回添加拦截器</span></div><div class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="comment">// 处理返回数据</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// 处理错误</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>这样，我们就可以在拦截器中统一处理错误与数据，不再需要在每一个 Promise 中都写一遍了，也便于统一项目中的处理方式。</p>
<p>关于 AOP 简单介绍到这里。</p>
<h3 id="三、ES7-Decorator"><a href="#三、ES7-Decorator" class="headerlink" title="三、ES7 Decorator"></a>三、ES7 Decorator</h3><p>ES7 的 decorator 装饰器借鉴于 Python 的思想，由 Yehuda Katz 提出，这里有<a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">提案的细节设计与语法糖在 ES6/ES5 中的转换</a>。</p>
<p>定义非常简短：</p>
<blockquote>
<p>Decorators make it possible to annotate and modify classes and properties at design time.</p>
</blockquote>
<p>”装饰器可以让我们在设计时对类和类的属性进行注解和修改“</p>
<p>有点抽象，我们先全盘了解这些讯息再来研究到底是怎么回事。</p>
<p>想理解 <code>decorator</code> 的用法，离不开 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty</a>，ES7 也正是利用 <code>Object.defineProperty</code> 实现装饰器特性。</p>
<h4 id="1-前置知识：Object-defineProperty"><a href="#1-前置知识：Object-defineProperty" class="headerlink" title="1. 前置知识：Object.defineProperty"></a>1. 前置知识：Object.defineProperty</h4><p>如果了解过 Vue 双向绑定的实现原理，对 <code>Object.defineProperty</code> 就一定不陌生。</p>
<blockquote>
<p><code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p>可以在对象上定义新属性，或修改已有属性，并将对象返回</p>
<p>参数 <code>obj</code>：要在其上添加或修改属性的对象</p>
<p>参数 <code>prop</code>：属性名</p>
<p>参数 <code>descriptor</code>：属性描述符，可以设置属性的数据属性与访问器属性</p>
</blockquote>
<p>其中 <code>descriptor</code> 可设置的属性有：</p>
<p>通用描述符：</p>
<ul>
<li>enumerable：Boolean，属性可否枚举</li>
<li>configurable：Boolean，若为 false，任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</li>
</ul>
<p>数据描述符 data descriptor：</p>
<ul>
<li>value：属性值</li>
<li>writable：Boolean，是否可写</li>
</ul>
<p>访问器描述符 accessor descriptor：</p>
<ul>
<li>get： 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</li>
<li>set：一旦目标属性被赋值，就会调回此方法。</li>
</ul>
<p>（Vue 就是在 get 和 set 函数中进行了拦截，判断数据是否变化，发送通知到订阅器中，详情可参考<a href="https://blog.colafornia.me/2017/03/14/observer-pattern-in-vue/">《观察者模式以及在 Vue 源码中的实践》</a>）</p>
<h4 id="2-ES7-Decorator-的用法"><a href="#2-ES7-Decorator-的用法" class="headerlink" title="2. ES7 Decorator 的用法"></a>2. ES7 Decorator 的用法</h4><p>ES7 Decorator 的使用场景不少，我们先看最简单典型的一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">  descriptor.writable = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> descriptor</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</div><div class="line">    @readonly</div><div class="line">    say() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'喵'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Cat();</div><div class="line">tom.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'汪'</span>);</div><div class="line">&#125;</div><div class="line">tom.say()    <span class="comment">// 喵</span></div></pre></td></tr></table></figure>
<p>readonly 就是一个 decorator 装饰器，它通过设置修饰符的 <code>writable</code> 属性，使得被装饰的 <code>say()</code> 只读。</p>
<p>装饰器本身是一个函数，接受三个参数，target，name 和 descriptor。</p>
<p>写一个 log 装饰器来看看这仨参数都是啥：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(target);</div><div class="line">    <span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">'constructor'</span>));</div><div class="line">    <span class="built_in">console</span>.log(target.constructor);</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">    <span class="built_in">console</span>.log(descriptor);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    @log</div><div class="line">    bar() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Foo();</div><div class="line">test.bar();</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/images/decorator1.jpg" alt=""></p>
<p>由此可以看出，target 就是被装饰的类本身，name 为被装饰的属性名，descriptor 与前述 Object.defineProperty 方法的属性描述符完全一样。</p>
<p>这仅仅是作为类属性的装饰器而言。实际上 decorator 有两种使用方法：</p>
<ul>
<li>装饰 Class，作为类装饰器</li>
<li>装饰类的属性</li>
</ul>
<p>作为类装饰器时，由于类本身是一个函数，因此 decorator 仅有 <code>target</code> 这一个参数。</p>
<p>需要注意的是，<strong>decorator 不能用于函数，因为存在函数提升</strong>。</p>
<h4 id="3-decorator-的使用场景"><a href="#3-decorator-的使用场景" class="headerlink" title="3. decorator 的使用场景"></a>3. decorator 的使用场景</h4><p>如前面所提到的 AOP 的用途，我们可以通过 decorator 实现横切逻辑，如日志上报，鉴权等。</p>
<p><a href="https://github.com/jayphelps/core-decorators/tree/master/src" target="_blank" rel="external">core-decorators</a> 中实现了一系列基础常用的装饰器，可以参考一下其中的实现。</p>
<p>平时开发中难免遇到需要使用定时器的场景，于是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  doSomething();</div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure>
<p>遇到一个就得写一个，函数被包裹来包裹去，并不是很美观。可以编写一个简单的 <code>timeout</code> 装饰器来重构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">milliseconds = 0</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> target, key, descriptor </span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> fn = descriptor.value;</div><div class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        fn.apply(<span class="keyword">this</span>, args);</div><div class="line">       &#125;, milliseconds);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> descriptor;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">  @timeout()</div><div class="line">  doSomething() &#123;&#125;</div><div class="line">  @timmeout(<span class="number">2000</span>)</div><div class="line">  doAnotherThing() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码结构清晰多了，装饰器也起到了注释的作用。</p>
<h4 id="4-decorator-在什么时候运行？"><a href="#4-decorator-在什么时候运行？" class="headerlink" title="4. decorator 在什么时候运行？"></a>4. decorator 在什么时候运行？</h4><p>尝试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'before class'</span>);</div><div class="line"></div><div class="line">@log(<span class="string">'class Bar'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">    @log(<span class="string">'class method bar'</span>)</div><div class="line">    bar() &#123;&#125;</div><div class="line"></div><div class="line">    @log(<span class="string">'class property foo'</span>)</div><div class="line">    foo = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'after class'</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> bar = &#123;</div><div class="line">    @log(<span class="string">'object method bar'</span>)</div><div class="line">    bar() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>输出结果：<br><img src="/images/decorator2.jpg" alt=""></p>
<p>由此我们可以看出：</p>
<blockquote>
<p>装饰器是在声明期就起效的，并不需要类进行实例化。</p>
<p>类实例化并不会致使装饰器多次执行，因此不会对实例化带来额外的开销。</p>
<p>按编码时的声明顺序执行，并不会将属性、方法、访问器进行重排序。</p>
<p>因为以上这 2 个规则，我们需要特别注意一点，在装饰器运行时，你所能得到的环境是空的，在 Bar.prototype 或者 Bar 上的属性是获取不到的，也就是说整个 target 里其实只有 constructor 这一个属性。</p>
<p>换句话说，装饰器运行时所有的属性和方法均未定义。</p>
</blockquote>
<h3 id="四、React-高阶组件"><a href="#四、React-高阶组件" class="headerlink" title="四、React 高阶组件"></a>四、React 高阶组件</h3><p>之所以会有<code>高阶组件 higher-order component(HOC)</code>这个东西，主要是为了实现<strong>组件的抽象</strong>。</p>
<h4 id="1-Mixin"><a href="#1-Mixin" class="headerlink" title="1. Mixin"></a>1. Mixin</h4><p>想了解 HOC 干了啥，以及为啥需要它。依然要用 Vue 举例，Vue 的 <code>mixins</code> 混入方法实现了组件的混入，借此我们可以将组件粒度切细，使得项目高度配置化。</p>
<p>官网示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个混入对象</span></div><div class="line"><span class="keyword">var</span> myMixin = &#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.hello()</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个使用混入对象的组件</span></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></div></pre></td></tr></table></figure>
<p>Vue 中的 mixin 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时<strong>以组件数据优先</strong>。这也是实现 mixin 的重点逻辑。</p>
<p>看看 <code>core-decorators</code> 中 mixin 的核心实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; getOwnPropertyDescriptors &#125; <span class="keyword">from</span> <span class="string">'./private/utils'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; defineProperty &#125; = <span class="built_in">Object</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClass</span>(<span class="params">target, mixins</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!mixins.length) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`@mixin() class <span class="subst">$&#123;target.name&#125;</span> requires at least one mixin as an argument`</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = mixins.length; i &lt; l; i++) &#123;</div><div class="line">    <span class="keyword">const</span> descs = getOwnPropertyDescriptors(mixins[i]);</div><div class="line">    <span class="keyword">const</span> keys = getOwnKeys(descs);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, k = keys.length; j &lt; k; j++) &#123;</div><div class="line">      <span class="keyword">const</span> key = keys[j];</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!(hasProperty(key, target.prototype))) &#123;</div><div class="line">        defineProperty(target.prototype, key, descs[key]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> mixins[<span class="number">0</span>] === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> handleClass(mixins[<span class="number">0</span>], []);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> target =&gt; &#123;</div><div class="line">      <span class="keyword">return</span> handleClass(target, mixins);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中把待 mixin 对象的每个方法都叠加到了 target 对象的原型上。其中通过 <code>defineProperty</code> 这个方法避免了覆盖 target 的原有属性。</p>
<p>但是 mixin 有很多弊病，这也是为什么最后我们选择了高阶组件来实现组件的 compose。主要问题有：</p>
<ul>
<li><strong>破坏组件原有封装</strong>：被 mixin 进来的组件都有自己的 props 和 state，导致在引入的时候需要千般小心，去维护那些我们不可见的状态。</li>
<li><strong>命名冲突</strong>：mixin 是一个平面结构，不同 mixin 中的命名不可知，譬如 <code>handleChange</code> 这种常见名就很容易冲突，无形中增加了开发和维护成本。</li>
</ul>
<p>因此高阶组件应运而生。</p>
<h4 id="2-高阶组件"><a href="#2-高阶组件" class="headerlink" title="2. 高阶组件"></a>2. 高阶组件</h4><p><code>高阶组件（higher-order component）</code>的概念类似于<code>高阶函数</code>，它接受 React 组件作为输入，输出一个新的 React 组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</div></pre></td></tr></table></figure>
<p>先看一个最简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// 可以做很多自定义逻辑</span></div><div class="line">  render() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        Usual</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> simpleHoc(Normal);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> simpleHoc = WrappedComponent =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'im a hoc!'</span>);</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125;/&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">export default simpleHoc;</div></pre></td></tr></table></figure>
<p>我们所定义的 Normal 组件通过 simpleHoc 的包裹后输出的新组件后，在 Normal 本身的功能上可以多打一个 Log，并继承了 simpleHoc 的 props。这是最简单的一个例子啦，高阶组件做的事情也比较逊。我们继续看看~</p>
<p>实现高阶组件的方法有两种：</p>
<ol>
<li>属性代理（<code>props proxy</code>）：高阶组件通过 WrappedComponent 来操作 props</li>
<li>反向代理（<code>inheritance inversion</code>）：高阶组件继承于 WrappedComponent</li>
</ol>
<p>这两种方法的使用场景也各不相同。</p>
<h3 id="五、实现高阶组件的两种方法与使用场景"><a href="#五、实现高阶组件的两种方法与使用场景" class="headerlink" title="五、实现高阶组件的两种方法与使用场景"></a>五、实现高阶组件的两种方法与使用场景</h3><h4 id="1-属性代理"><a href="#1-属性代理" class="headerlink" title="1. 属性代理"></a>1. 属性代理</h4><p>这是较为常见的一种方法，上面的 <code>simpleHoc</code> 的实现其实就属于属性代理。<strong>通过高阶组件传递 props 的方法就是属性代理</strong>。</p>
<p>使用场景：</p>
<ul>
<li>操作 <code>props</code></li>
<li>通过 <code>Refs</code> 访问到组件实例</li>
<li>提取 <code>state</code></li>
<li>用其他元素包裹 <code>WrappedComponent</code></li>
</ul>
<p>我们主要介绍一下最常见的，操作 props。其它三种应用在网上也能找到具体例子，不赘述了（文章到这里感觉已经非常长了……）</p>
<p>我们可以通过属性代理，来读取，编辑，增加或是删除 WrappedComponent 的 props。但应该注意小心编辑、删除重要的 props，尽量通过<strong>对高阶组件的 props 作新的命名来避免混淆</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span> (<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">myHoc</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">const</span> newProps = &#123;</div><div class="line">        user: currentLoggedInUser</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，输出的新组件就可以通过 <code>this.props.user</code> 来获得当前登录人的信息。</p>
<p>使用的时候可以通过 decorator 来简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@myHoc</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</div></pre></td></tr></table></figure>
<h4 id="2-反向继承"><a href="#2-反向继承" class="headerlink" title="2. 反向继承"></a>2. 反向继承</h4><p>先看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">myHoc</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高阶组件返回的组件继承于 WrappedComponent，因此被称为 <code>Inheritance Inversion</code> 反向继承。</p>
<p><strong>反向继承模式下的高阶组件可以通过 this 访问到 WrappedComponent 的 state、props、组件生命周期方法和 render 方法</strong>。</p>
<p>使用场景：</p>
<ul>
<li>渲染劫持（<code>Render Highjacking</code>）</li>
<li>操作 <code>state</code></li>
</ul>
<p>渲染劫持是指高阶组件可以控制 WrappedComponent 的渲染过程并修改渲染结果，这意味着可以：</p>
<ul>
<li>在由 render <strong>输出</strong>的任何 React 元素中读取、添加、编辑、删除 props</li>
<li>读取和修改由 render 输出的 React 元素树</li>
<li>有条件地渲染元素树</li>
<li>把样式包裹进元素树（就像在 <code>Props Proxy</code> 中的那样）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.show) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render()</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面提到了高阶组件可以通过 this 访问到 WrappedComponent 的 state，可以对其进行编辑、删除，但这会使得 WrappedComponent 的内部状态混乱，难以维护，应避免这样使用。</p>
<p>最后，我们来看下高阶组件与 Mixin 的区别：</p>
<p><img src="/images/decorator3.jpg" alt=""></p>
<p>高阶组件更符合函数式编程思想，原组件不会感知到高阶组件的存在，最后我们所使用的都是一个新组件，从而避免了 Mixin 的那些弊病。</p>
<h3 id="五、参考内容"><a href="#五、参考内容" class="headerlink" title="五、参考内容"></a>五、参考内容</h3><ul>
<li><a href="https://book.douban.com/subject/26918038/" target="_blank" rel="external">《深入React技术栈》</a></li>
<li><a href="http://efe.baidu.com/blog/introduction-to-es-decorator/" target="_blank" rel="external">ES Decorators简介</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="external">深入理解 React 高阶组件</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/post/2018/gpu-animation-render-pipeline/" class="prev">PREV</a><a href="/post/2018/dive-into-git/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>