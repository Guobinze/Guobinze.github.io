<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React Hooks 起手式 · Minibase</title><meta name="description" content="React Hooks 起手式 - Colafornia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Hooks 起手式</h1><div class="post-info">Jan 6, 2020</div><div class="post-content"><p><img src="/images/react-hooks-cover.jpeg" alt="react hooks cover"></p>
<p>React Hooks 在 React@16.8 版本中正式发布，之后在两个项目中尝鲜使用了一下，很大提升了开发效率和体验，尤其是在 WebRTC 直播项目里，简直是救我狗命的存在。在此来整理一下相关知识，用一个舒适的顺序剖析关于 React Hooks 的方方面面。</p>
<a id="more"></a>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>They let you use state and other React features without writing a class.</p>
<p>React hooks 可以让你在 Class 之外使用 state 以及 React 的其它特性</p>
</blockquote>
<p>React 的官方文档中明确说明了引入 React Hooks 是为了解决以下问题：</p>
<ol>
<li><p>难以在组件间复用逻辑</p>
<p>之前是通过 render props 和 高阶组件（HOC）来解决的，但这大大提升了程序的复杂度，多个高阶组件的嵌套也会形成嵌套地狱（Wrapper Hell）。</p>
</li>
<li><p>组件越来越复杂，难以理解难以维护</p>
</li>
</ol>
<p>​       复杂的生命周期机制，每个生命周期方法里都是几种不相干的逻辑代码和副作用。事件监听的代码在 <code>componentDidMount</code>里，解绑的清理代码在 <code>componentWillUnmount</code> 里，这让组件更难拆分了。</p>
<ol>
<li>Class 让人和计算机都难以理解</li>
</ol>
<p>​      光 <code>this</code> 指针这一项就已经有点难用了，除此之外，Class 对于代码压缩与热加载也并不友好，会有一些边界 Case。</p>
<p>因此，我们可以理解为 React Hooks 的<strong>设计目标</strong>就是：</p>
<ol>
<li>免去编写 Class 的复杂性，解决生命周期的复杂性</li>
<li>解决逻辑复用难的问题</li>
</ol>
<p>接下来，我们来看看是怎么实现的。</p>
<h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>看到前面的动机，可能心里会有个念头“既然 Class 这么难用，当初为什么要这么设计非要使用 Class 来编写组件呢”。这当然有其历史必然性了。</p>
<p>React 中有两种组件形式，Class 类组件与 Function 函数组件：</p>
<p><code>Class Component</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="comment">//...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      <span class="keyword">this</span>.fetchData()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    render() &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Function Component</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">links</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            &#123;links.map((&#123;href, title&#125;)=&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;href&#125;</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> )&#125;</div><div class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类组件中会维护内部状态，函数组件则是无状态的。</p>
<p>这就是关键之处，<strong>函数组件无法保存状态</strong>，每次重新运行函数都会导致其作用域内所有函数被重置，也无法像类组件一样通过继承  <code>React.Component</code> 原型上的方法 <code>setState</code> 来更新自己的状态。所以，在过去，如果我们想让一个函数组件具有状态，就不得不将其转为类组件。</p>
<p>那么，如果我们想抛弃 Class，转向函数组件的话，必须解决的事便是让函数组件也能保留、修改、持久化自己的状态。</p>
<p>怎么能让函数状态持久化？</p>
<p>答案是 <strong>闭包</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/06/ly6NJ1.md.png" alt="closure"></p>
<p>惊不惊喜，意不意外？就是初学 JavaScript 时阴魂不散的闭包，简直闭包天天见。</p>
<h4 id="Based-on-closures"><a href="#Based-on-closures" class="headerlink" title="Based on closures"></a>Based on closures</h4><p>所以，以 <code>useState</code> 为例，我们可以简单实现（以下均为简单实现，非源码）为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _state</div><div class="line"><span class="keyword">const</span> useState = (initialValue) =&gt; &#123;</div><div class="line">  _state = _state || initialValue</div><div class="line">  <span class="keyword">const</span> setState = (newValue) =&gt; &#123;</div><div class="line">    _state = newValue</div><div class="line">    render()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> [_state, setState]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么支持组件内维护多个状态？最简单的方式当然是用数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _hooks = []</div><div class="line"><span class="keyword">let</span> _cursor = <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue</span>) </span>&#123;</div><div class="line">  _hooks[_cursor] = _hooks[_cursor] || initialValue</div><div class="line">  <span class="keyword">const</span> setStateHookCursor = _cursor</div><div class="line">  <span class="keyword">const</span> setState = (newVal) =&gt; &#123;</div><div class="line">    _hooks[setStateHookCursor] = newVal</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> [hooks[_cursor++], setState]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>维护一个数组变量，一个锚点 cursor 就可以指哪打哪，准确读取、修改状态值了。</p>
<p><code>useEffect</code> 也是类似的，只是状态数组里保存的是 deps，除此之外再增加一个浅比较 deps 是否有变化的逻辑即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, depArray</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> hasNoDeps = !depArray</div><div class="line">  <span class="keyword">const</span> deps = _hooks[_cursor]</div><div class="line">  <span class="keyword">const</span> hasChangedDeps =</div><div class="line">    !deps || !depArray.every((el, i) =&gt; el === deps[i])</div><div class="line">  <span class="keyword">if</span> (hasNoDeps || hasChangedDeps) &#123;</div><div class="line">    callback()</div><div class="line">    hooks[_cursor] = depArray</div><div class="line">  &#125;</div><div class="line">  _cursor++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>React 的源码实现当然比上面复杂的多，事实上，React Hooks 是在 Fiber 架构基础上实现的。</p>
<h4 id="Based-on-Fiber"><a href="#Based-on-Fiber" class="headerlink" title="Based on Fiber"></a>Based on Fiber</h4><p>按照<a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="external">官方的说法</a>，<code>React Fiber</code> 是<strong>对核心算法的一次重新实现</strong>，也可以说它是一个新的 <code>Reconciler</code>。所以，  <code>Reconciler</code> 是什么呢？</p>
<p>React 的源码可以分为三个主要部分：</p>
<blockquote>
<p><code>React Core</code></p>
<p>这一部分只涵盖了与定义组件相关的顶层 API</p>
<p><code>Renderers</code></p>
<p>渲染器模块负责管理 React 树如何被具体底层平台所调用，Web 则为 DOM API，React Native 的话则是安卓 iOS 的视图 API。</p>
<p>除此之外还有 <a href="https://github.com/facebook/react/tree/master/packages/react-test-renderer" target="_blank" rel="external">React Test Renderer</a> 渲染器，可以把 React 组件转化为 JSON 树，供 Jest 这类测试框架做快照测试使用</p>
<p><code>Reconcilers</code></p>
<p>Reconciler 是一种 diff 算法用以确定在状态改变时需要更新那些 DOM 元素。它没有公开的 API，因此也没被独立打包，它只被 React DOM 和 React Native 这类渲染器使用</p>
<p>在推出 v16 的 Fiber 架构后，新的 Reconciler 被称为 <code>Fiber Reconciler</code>，v15 及之前的实现则被称为 <code>Stack Reconciler</code></p>
</blockquote>
<p><img src="https://blog.atulr.com/static/cc397bd7316079f477f29f36fd058a80/832fe/common-reconciler.png" alt="react codebase"></p>
<p>了解到这里， <code>Fiber Reconciler</code> 是为了解决 React v15 的DOM元素多，频繁刷新场景下的主线程阻塞问题，直观显示，则是“掉帧”问题。v15 是一次同步处理整个组件树，通过递归的方式进行渲染，使用 JavaScript 引擎自身的函数调用栈，它会一直执行到栈空位置，一旦工作量大就会阻塞整个主线程（就像前面说的用 HOC 方式形成 Wrapper Hell 的话不仅 debug 难，对性能也会产生严重影响）。然而我们的更新工作可能并不需要一次性同步完成，其中是可以按照优先级调整工作，把整个过程分片处理的，这就是 Fiber 想做的事。</p>
<p> <code>Fiber Reconciler</code> 以<strong>链表</strong>的形式遍历组件数，可以灵活的暂停、继续、放弃当前任务。通过 Scheduler 调度器来进行任务分配，每次只做一个小任务，通过 <code>requestIdleCallback</code> 回到主线程看看有没有更高优先级的任务需要处理，如果有就暂停当前任务，去做优先级更高的，否则就继续执行。</p>
<p><img src="https://s2.ax1x.com/2020/01/06/lycVOO.md.png" alt="Fiber"></p>
<p>关于 Fiber 的内容可以了解的还有更多，包括它是怎么划分优先级的，对现有代码的影响等等。但是还是先回到关于 Hooks 的实现。</p>
<p>Fiber 的类型定义在<a href="https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiber.js#L127" target="_blank" rel="external">源码的 react-reconciler/src/ReactFiber.js 文件里</a>，我们抽取一下需要了解的字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type Fiber = &#123;</div><div class="line">  tag: WorkTag,</div><div class="line">  key: <span class="literal">null</span> | string,</div><div class="line">  type: any,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  memoizedState: any</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>memoizedState</code> 就是用来储存当前渲染节点的最终状态值。</p>
<p>我们再看一下 <a href="https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiberHooks.js#L142" target="_blank" rel="external">Hook 的类型定义</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type Hook = &#123;</div><div class="line">  memoizedState: any,        <span class="comment">// 上一次更新之后的最终状态值</span></div><div class="line">  queue: UpdateQueue | <span class="literal">null</span>, <span class="comment">// 更新队列，存储多次更新操作</span></div><div class="line"></div><div class="line">  next: Hook | <span class="literal">null</span>,         <span class="comment">// 指向链表的下一个 Hook</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">type Update &#123;</div><div class="line">  action: any,</div><div class="line">  next: Update,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">type UpdateQueue &#123;</div><div class="line">  last: Update,</div><div class="line">  dispatch: any,</div><div class="line">  lastRenderedState: any,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不难看到，在实际的实现中，React Hooks 并没有采用数组，而是通过单向链表的方式来存储多个 Hooks。</p>
<p>除此之外，可以看到 Queue 有个 last 字段，我们可以调用 <a href="https://github.com/facebook/react/blob/7dc9745427046d462506e9788878ba389e176b8a/packages/react-reconciler/src/ReactFiberHooks.js#L1224" target="_blank" rel="external">dispatchAction</a>（即更新 state 的方法） 多次，也只有最后那次会生效，生效为 last 存储的最后一次 update 的 state 值。</p>
<p>因此，在每个组件内，都会有个 Fiber 对象以这样的形式来存储：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [catName, setCatName] = useState(<span class="string">'Tom'</span>);</div><div class="line"><span class="keyword">const</span> [mouseName, setMouseName] = useState(<span class="string">'Jerry'</span>);</div><div class="line">setCatName(<span class="string">'Tommy'</span>)</div><div class="line"></div><div class="line"><span class="comment">// FiberNode</span></div><div class="line"><span class="keyword">const</span> fiber = &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    memoizedState: &#123;</div><div class="line">        memoizedState: <span class="string">'Tom'</span>, </div><div class="line">        queue: &#123;</div><div class="line">            last: &#123;</div><div class="line">                action: <span class="string">'Tommy'</span></div><div class="line">            &#125;,  </div><div class="line">            dispatch: dispatch,</div><div class="line">            lastRenderedState: <span class="string">'Tommy'</span></div><div class="line">        &#125;,</div><div class="line">        next: &#123;</div><div class="line">            memoizedState: <span class="string">'Jerry'</span>,</div><div class="line">            queue: &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;,</div><div class="line">            next: <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 Hook API 实际上就是新增一个 Hook 实例并将其追加到 Hooks 链表上，返回给组件的是这个 Hook 的 state 和对应的 setter，链表的结构决定了 re-render 时 React 并不会知道这个 setter 对应的是哪个 hooks，因此它会从链表的头开始一一执行（这是采用了链表结构的弊端，但是如果通过 HashMap 来存储的话，每次调用 Hook API 都需要显示地传入一个 Key 值来区分不同 Hook，更复杂了）。</p>
<p>这个 Hooks 链表是在 mount 阶段时构造的，所以声明 Hook 时的<strong>顺序很重要</strong>，这也是为什么我们只能在函数组件顶部作用域调用Hook API，不能在条件语句、循环、子函数里调用 Hooks。</p>
<h3 id="Notice-Capture-Value"><a href="#Notice-Capture-Value" class="headerlink" title="Notice: Capture Value"></a>Notice: Capture Value</h3><p>这是一个新手常见坑，首先来看一段代码（<a href="https://codesandbox.io/s/k5pmk0omx7" target="_blank" rel="external">在线地址</a>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> handleAlertClick = useCallback(</div><div class="line">    () =&gt; &#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        alert(<span class="string">"You clicked on: "</span> + count);</div><div class="line">      &#125;, <span class="number">3000</span>);</div><div class="line">    &#125;,</div><div class="line">    [count]</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;增加 count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleAlertClick&#125;</span>&gt;</span>显示 count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先点击 “显示 count” 按钮，然后快速点击 “增加 count” 两下，会发现 alert 弹窗上显示的是 0，然而 p 标签里已经是2了。这就是 React Hook 的 <code>Capture Value</code> 快照特性。</p>
<p><img src="https://s2.ax1x.com/2020/01/17/lziPWn.png" alt="image-20200106180246276"></p>
<blockquote>
<p><strong>Each Render Has Its Own Props and State</strong></p>
<p>记住，每次 Render 都有自己的 Props 和 State</p>
</blockquote>
<p>每次 Render 的内容都会形成一个快照并保存下来，因此当状态变更而 re-render 时，就有了 N 个快照，每个都拥有自己独立的，固定不变的 Props 和 State。在每个快照之间（在这段代码里即每次点击之间），count 只是一个常量，不存在数据绑定，watcher 或者 proxy 之类的东西，它只是一个常量数字。因此点击“显示 count” 按钮时，当前快照内 count 值为 0，alert 弹窗为 0，后面无论点击多少次“增加 count” 按钮，都是新的快照，与它无关了。</p>
<p><code>Capture Value</code> 特性存在于除 <code>useRef</code> 之外的所有 Hook API 中（因为<strong>非 useRef 相关的 Hook API，本质上都形成了闭包，闭包有自己独立的状态，这就是 Capture Value 的本质</strong>）。所以如果想避免上述例子中取不到 state 最新值的情况，可以通过 <code>useRef</code> 把所需的 state 值保存下来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  <span class="keyword">const</span> countRef = useRef(<span class="literal">null</span>)</div><div class="line"></div><div class="line">  <span class="keyword">const</span> handleAlertClick = useCallback(</div><div class="line">    () =&gt; &#123;</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        alert(<span class="string">"You clicked on: "</span> + countRef.current);</div><div class="line">      &#125;, <span class="number">3000</span>);</div><div class="line">    &#125;,</div><div class="line">    [count]</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</div><div class="line">        countRef.current = count + 1</div><div class="line">        setCount(count + 1)</div><div class="line">      &#125;&#125;&gt;增加 count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleAlertClick&#125;</span>&gt;</span>显示 count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Hooks-API"><a href="#Hooks-API" class="headerlink" title="Hooks API"></a>Hooks API</h3><p>接下来简单介绍一下官方的几个有意思的 Hooks 的常规用法和注意事项。</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>前面在 Capture Value 也介绍了，它是唯一返回 mutable 数据的 Hook，它不仅可以 DOM 引用，还可以存储任意 JavaScript 值。</p>
<p>修改 useRef 的值必须改其 current 属性，否则不会触发 re-render</p>
<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>useCallback 可以保证在 re-render 之间返回的始终是同一回调引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只要 a 或 b 不变，这个值就不会变化</span></div><div class="line"><span class="keyword">const</span> memoizedCallback = useCallback(() =&gt; &#123;</div><div class="line">  doSomething(a, b);</div><div class="line">&#125;, [a, b]);</div></pre></td></tr></table></figure>
<p>需要注意的是，用 useCallback 包裹的函数所用参数，也必须在 hook 的 deps 数组里。</p>
<p>使用场景：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</div><div class="line">  <span class="keyword">const</span> handleIncrement = useCallback(() =&gt; &#123;</div><div class="line">    setCount(count + <span class="number">1</span>)</div><div class="line">  &#125;, [count])</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      &#123;count&#125;:</div><div class="line">      <span class="tag">&lt;<span class="name">ComplexButton</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncrement&#125;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">ComplexButton</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不使用 useCallback 来包住回调函数的话，那么每次点击按钮修改 count 值时触发 re-render 生成新的回调函数，传入 ComplexButton 的 props 发生变化，导致了 ComplexButton 重新渲染。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</div></pre></td></tr></table></figure>
<p>仅当依赖项发生改变时，才会重新计算  memoizedValue，常被用于缓存昂贵计算函数的返回值。</p>
<p><strong><code>useCallback(fn, deps)</code>== <code>useMemo(() =&gt; fn, deps)</code></strong></p>
<p>React 提供了一个与类组件的 <code>PureComponent</code> 相同功能的 API <code>React.memo</code>，会在自身 re-render 时，对每一个 <code>props</code> 项进行浅比较，如果引用没有变化，就不会触发重渲染。</p>
<h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</div></pre></td></tr></table></figure>
<p>useState 用于相对扁平结构的状态，useReducer 则用于复杂结构的状态。而其返回的 dispatch 方法可以放心传递给子组件，而不会造成子组件的 re-render</p>
<p>具体可参考 <a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="external">Dan Abramov 的示例代码</a></p>
<p>先写到这里，后面希望可以再学习整理一下 React Hooks 的逻辑复用实践~</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.youtube.com/watch?v=KJP1E-Y-xyo&amp;t=930s" target="_blank" rel="external">Getting Closure on React Hooks by Shawn Wang | JSConf.Asia 2019 - YouTube</a></li>
<li><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="external">Making Sense of React Hooks - Dan Abramov - Medium</a></li>
<li><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="external">React hooks: not magic, just arrays - Medium</a></li>
<li><a href="https://blog.atulr.com/react-custom-renderer-1/" target="_blank" rel="external">Beginners guide to Custom React Renderers</a></li>
<li><a href="https://www.infoq.cn/article/fiWNgsIOLaCmt-hphLYC" target="_blank" rel="external">React Hook 构建过程：没有设计就是最好的设计</a></li>
<li><a href="https://github.com/chemdemo/chemdemo.github.io/issues/15" target="_blank" rel="external">React Hooks完全上手指南</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/post/2020/2020-interviews/" class="prev">PREV</a><a href="/post/2019/2019-review/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>