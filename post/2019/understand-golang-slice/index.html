<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 理解 Go 语言中的 Slice · Minibase</title><meta name="description" content="理解 Go 语言中的 Slice - Colafornia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.colafornia.me/atom.xml" title="Minibase"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/colafornia" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">理解 Go 语言中的 Slice</h1><div class="post-info">Nov 5, 2019</div><div class="post-content"><p><img src="/images/go-slice.png" alt="go-slice"></p>
<p>数组是面向过程的编程语言里最重要的概念之一。</p>
<a id="more"></a>
<h2 id="一、翻车现场"><a href="#一、翻车现场" class="headerlink" title="一、翻车现场"></a>一、翻车现场</h2><p>在短暂的 Go 语言学习使用中，已经连续两次踩进了下面这个坑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vals := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">  vals = <span class="built_in">append</span>(vals, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fmt.Println(vals)</div><div class="line"></div><div class="line"><span class="comment">// Playground: https://play.golang.org/p/7PgUqBdZ6Z</span></div></pre></td></tr></table></figure>
<p>输出结果是 <code>[0 0 0 0 0 0 1 2 3 4]</code></p>
<p><strong>回顾一下翻车现场：</strong></p>
<ol>
<li><p>开始是通过 <code>var vals []int</code> 来进行变量声明</p>
</li>
<li><p>后续逻辑开发完成，自测完成，一切 ok，发布上线，一切 ok</p>
</li>
<li><p>某天在项目里跑了一下 <code>golangci-lint</code>，发现了一吨报错，其中有：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Consider preallocating <span class="string">`vals`</span> (prealloc)</div><div class="line">        <span class="keyword">var</span> vals []<span class="keyword">int</span></div><div class="line">        ^</div></pre></td></tr></table></figure>
<ol>
<li><p>遂修改为 <code>vals := make([]int, 5)</code>，再改完那一吨报错，基本都是关于写法的修正，lint 不再报错，提交发布</p>
</li>
<li><p>线上，Duang💥💥💥（看用在哪里啦。。很有可能也不会💥，只会是一个隐秘的 Bug）</p>
</li>
</ol>
<p>挺刺激的。第一次遇到这个问题的时候其实已经有个印象不能这么声明 slice，再 append 了，但还是被打的不够疼，又有了第二次。</p>
<p>所以还是来学习理解一下具体是怎么回事吧。</p>
<h2 id="二、Array-vs-Slice"><a href="#二、Array-vs-Slice" class="headerlink" title="二、Array vs Slice"></a>二、Array vs Slice</h2><p>Go 语言中有数组 array，也有切片 slice。二者有很多区别，但是本次想讨论的主要是，<strong>array 的大小是固定的且不会改变，其 length 就是其类型的一部分，而 slice 的大小是动态变化的</strong>，因为 slice 是 array 的 <strong>wrapper</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aArray := [<span class="number">2</span>]<span class="keyword">string</span>&#123;<span class="string">"Tom"</span>, <span class="string">"Jerry"</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, aArray) <span class="comment">// Print "[2]string"</span></div></pre></td></tr></table></figure>
<p>所以说，声明一个数组：<code>var a [10]int</code> a 的大小就已经固定，不会改变。调用 <code>len(a)</code> 的结果永远为 10。如果想要再向数组里添加、删除任何元素，都必须要重新声明一个新的类型。</p>
<p>这种固定大小的数组设计在某些场景下是非常有用的（官方文档的举例是矩阵变换），但是大多数情况下，工程中还是需要一个可变大小可增删的数组容器。而这就是设计 Slice 的原因。</p>
<p>切片 Slice 是基于数组实现的，它描述了数组的一个连续片段，所以叫切片还是很生动形象的。切片其实就是动态数组，它的长度并不固定，可以追加元素并会在切片容量不足时进行扩容。</p>
<p><img src="http://static.git-star.com/go-slices-usage-and-internals_slice-struct.png" alt="img"></p>
<p>如上图，<code>Slice</code> 的结构本质上是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</div><div class="line">    Ptr <span class="keyword">uintptr</span></div><div class="line">    Len  <span class="keyword">int</span></div><div class="line">    Cap  <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Ptr 作为一个指针指向数组的第一个元素，其实就是指向一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组其实就是一片连续的内存空间，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量标识。</p>
<p>Length 是 slice 中所包含的元素个数，而<code>Capacity</code>则记录了其底层数组的大小（从切片指针引用的元素开始，直到底层数组的最后一个元素）。因此，必然会有 <code>Capacity &gt;= Length</code> 。试图把切片扩展到超出容量就会和访问超出数组/切片范围的索引一样，导致 panic。</p>
<p>因此如果我们声明 <code>slice := iBuffer[0:0]</code>，其 header 则为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">slice := SliceHeader&#123;</div><div class="line">    Len:  <span class="number">0</span>,</div><div class="line">    Cap:  <span class="number">10</span>,</div><div class="line">    Ptr: &amp;iBuffer[<span class="number">0</span>],</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引入 slice header 的这个概念非常有助于理解 slice 的特点和一些坑。</p>
<p>再来看看几种声明 slice 的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字面量</span></div><div class="line">letters := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// make</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span> []<span class="title">T</span></span></div><div class="line"><span class="title">s</span> := <span class="title">make</span><span class="params">([]<span class="keyword">byte</span>, 5)</span></div><div class="line"></div><div class="line">// <span class="title">re</span>-<span class="title">slice</span></div><div class="line"><span class="title">s</span> = <span class="title">s</span>[2:4]</div></pre></td></tr></table></figure>
<p>第三种 re-slice 方式并没有拷贝原 slice 中的数据，它只是创建了一个新的切片，并将其指针指向同一个底层数组。</p>
<p>如果更改了 slice 中某些元素的值，实际上是在改变 slice 所指向的数组元素的值。因此，在下面这种通过 re-slice 生成了子切片，又通过索引修改元素值的行为，会导致所有指向这个底层数组的 slice 的值都发生改变。<strong>即 Slice 的结构会导致多个 slice 实际引用的是同一个数组，要谨慎修改 slice 中元素的值</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>) <span class="comment">// 被初始化为 [0 0 0 0 0]</span></div><div class="line">foo[<span class="number">3</span>] = <span class="number">42</span></div><div class="line">foo[<span class="number">4</span>] = <span class="number">100</span></div><div class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</div><div class="line">bar[<span class="number">1</span>] = <span class="number">99</span></div><div class="line">fmt.Println(foo) <span class="comment">// [0 0 99 42 100]</span></div><div class="line">fmt.Println(bar) <span class="comment">// [0 99 42]</span></div></pre></td></tr></table></figure>
<h2 id="修改-Slice-中元素的值与-header"><a href="#修改-Slice-中元素的值与-header" class="headerlink" title="修改 Slice 中元素的值与 header"></a>修改 Slice 中元素的值与 header</h2><p>修改这两者的方法并不一样。</p>
<h3 id="Example1-将-slice-作为参数传入函数，修改-slice-中元素的值"><a href="#Example1-将-slice-作为参数传入函数，修改-slice-中元素的值" class="headerlink" title="Example1:  将 slice 作为参数传入函数，修改 slice 中元素的值"></a>Example1:  将 slice 作为参数传入函数，修改 slice 中元素的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddOneToEachElement</span><span class="params">(slice [])</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> slice &#123;</div><div class="line">        slice[i]++</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">    fmt.Println(<span class="string">"before"</span>, slice)</div><div class="line">    AddOneToEachElement(slice)</div><div class="line">    fmt.Println(<span class="string">"after"</span>, slice)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// before [0 0 0 0 0]</span></div><div class="line"><span class="comment">// after [1 1 1 1 1]</span></div></pre></td></tr></table></figure>
<p>修改成功。虽然作为函数参数所传递的只是 slice 的值，但是其实在函数中我们所操作修改的是指向同一底层数组的 <code>newSlice</code>，底层数组的元素被修改，因此当函数执行完毕，修改后的元素值可由原 slice 访问到。</p>
<h3 id="Example2-将-slice-作为参数传入函数，修改-slice-的长度"><a href="#Example2-将-slice-作为参数传入函数，修改-slice-的长度" class="headerlink" title="Example2:  将 slice 作为参数传入函数，修改 slice 的长度"></a>Example2:  将 slice 作为参数传入函数，修改 slice 的长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubtractOneFromLength</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</div><div class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</div><div class="line">    <span class="keyword">return</span> slice</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">    fmt.Println(<span class="string">"Before: len(slice) ="</span>, <span class="built_in">len</span>(slice))</div><div class="line">    newSlice := SubtractOneFromLength(slice)</div><div class="line">    fmt.Println(<span class="string">"After:  len(slice) ="</span>, <span class="built_in">len</span>(slice))</div><div class="line">    fmt.Println(<span class="string">"After:  len(newSlice) ="</span>, <span class="built_in">len</span>(newSlice))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Before: len(slice) = 5</span></div><div class="line"><span class="comment">// After:  len(slice) = 5</span></div><div class="line"><span class="comment">// After:  len(newSlice) = 4</span></div></pre></td></tr></table></figure>
<p>储存在 slice header 中的 length 属性并不会被函数修改，传入函数的只是其拷贝。 如果我们想通过一个函数来修改 slice  的 header 的话，必须通过把修改过的返回结果重新赋值给待修改的 slice。</p>
<h3 id="Example3-将-slice-的指针作为参数传入函数，修改其-header"><a href="#Example3-将-slice-的指针作为参数传入函数，修改其-header" class="headerlink" title="Example3:  将 slice 的指针作为参数传入函数，修改其 header"></a>Example3:  将 slice 的指针作为参数传入函数，修改其 header</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrSubtractOneFromLength</span><span class="params">(slicePtr *[]<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	slice := *slicePtr</div><div class="line">	*slicePtr = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)<span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">	fmt.Println(<span class="string">"Before: len(slice) ="</span>, <span class="built_in">len</span>(slice))</div><div class="line">	PtrSubtractOneFromLength(&amp;slice)</div><div class="line">	fmt.Println(<span class="string">"After:  len(slice) ="</span>, <span class="built_in">len</span>(slice))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Before: len(slice) = 5</span></div><div class="line"><span class="comment">// After:  len(slice) = 4</span></div></pre></td></tr></table></figure>
<h2 id="三、Append"><a href="#三、Append" class="headerlink" title="三、Append"></a>三、Append</h2><p>内置的 <code>append</code>方法有这几个功能特点：</p>
<ol>
<li>向 slice 附加一个或多个元素</li>
<li>分配足够大的 slice （如果 append 后的长度超出了现有的容量）</li>
<li>总会成功，除非机器内存耗光</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是官方实现的用来说明功能特性的版本，并不是源码</span></div><div class="line"><span class="comment">// Append appends the elements to the slice.</span></div><div class="line"><span class="comment">// Efficient version.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span><span class="params">(slice []<span class="keyword">int</span>, elements ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</div><div class="line">    n := <span class="built_in">len</span>(slice)</div><div class="line">    total := <span class="built_in">len</span>(slice) + <span class="built_in">len</span>(elements)</div><div class="line">    <span class="keyword">if</span> total &gt; <span class="built_in">cap</span>(slice) &#123;</div><div class="line">        <span class="comment">// Reallocate. Grow to 1.5 times the new size, so we can still grow.</span></div><div class="line">        <span class="comment">// 一次分配更多的内存通常都比多次分配少量内存的开销更小且速度更快</span></div><div class="line">        newSize := total*<span class="number">3</span>/<span class="number">2</span> + <span class="number">1</span></div><div class="line">        newSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, total, newSize)</div><div class="line">        <span class="built_in">copy</span>(newSlice, slice)</div><div class="line">        slice = newSlice</div><div class="line">    &#125;</div><div class="line">    slice = slice[:total]</div><div class="line">    <span class="built_in">copy</span>(slice[n:], elements)</div><div class="line">    <span class="keyword">return</span> slice</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、回顾一下翻车现场"><a href="#四、回顾一下翻车现场" class="headerlink" title="四、回顾一下翻车现场"></a>四、回顾一下翻车现场</h2><p>回到我们一开始演示翻车现场的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vals := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">  vals = <span class="built_in">append</span>(vals, i)</div><div class="line">&#125;</div><div class="line">fmt.Println(vals)</div></pre></td></tr></table></figure>
<p>在声明 <code>vals</code> 的时候，把它的 <code>length</code> 和 <code>capacity</code>都设置为5，它被初始化为空值 slice : <code>[0 0 0 0 0]</code>，再进行 append 操作，它假设我们是想在初始的 5 个元素后添加新元素，因此得到的结果是 <code>[0 0 0 0 0 0 1 2 3 4]</code>。</p>
<p>那在 golang-lint 要求我们必须通过 <code>prealloc</code> 的方式初始化 vals，或是我们为了避免每个循环中都 re-allocate 造成的过大开销，或是我们并不能确定执行<code>append</code> 后的切片大小的情况下，要怎么避免这种翻车情况呢？</p>
<p>有两种方式：</p>
<h3 id="1-直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）"><a href="#1-直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）" class="headerlink" title="1. 直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）"></a>1. 直接通过索引对切片元素赋值（只针对遍历操作后的数组大小已知的情况）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vals := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">  vals[i] = i</div><div class="line">&#125;</div><div class="line">fmt.Println(vals)</div></pre></td></tr></table></figure>
<p>这种方案并不难理解。</p>
<h3 id="2-设置长度为-0，指定切片的-Capacity"><a href="#2-设置长度为-0，指定切片的-Capacity" class="headerlink" title="2. 设置长度为 0，指定切片的 Capacity"></a>2. 设置长度为 <code>0</code>，指定切片的 Capacity</h3><p>并不是所有场景下我们都可以精确一一对应到每个索引下该存储的元素是什么，比如说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vals := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">  items := getItems(i)</div><div class="line">  vals = <span class="built_in">append</span>(vals, items...)</div><div class="line">&#125;</div><div class="line">fmt.Println(vals)</div></pre></td></tr></table></figure>
<p>每次将一个不定长度的 slice 铺平追加到切片，最终得到的切片的长度无法提前确定。</p>
<p>那只能通过设置长度为 <code>0</code>，指定切片的容量来解决了。即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vals := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">  items := getItems(i)</div><div class="line">  vals = <span class="built_in">append</span>(vals, items...)</div><div class="line">&#125;</div><div class="line">fmt.Println(vals)</div></pre></td></tr></table></figure>
<p>当然我们初始化时指定的容量5很有可能比最终切片长度小，循环过程中还是会发生 re-allocate，但这样已经避免了前面的翻车现场，也减少了 re-allocate 次数，可以作为这种场景下的折中解决方案了。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="external">Arrays, slices (and strings): The mechanics of ‘append’</a></li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="external">Go Slices: usage and internals</a></li>
<li><a href="https://www.calhoun.io/how-to-use-slice-capacity-and-length-in-go/" target="_blank" rel="external">How to use slice capacity and length in Go</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/post/2019/2019-review/" class="prev">PREV</a><a href="/post/2019/e2e-test-cypress/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://blog.colafornia.me">Colafornia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-84469017-1",'auto');ga('send','pageview');</script></body></html>